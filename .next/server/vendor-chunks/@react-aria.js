"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-aria";
exports.ids = ["vendor-chunks/@react-aria"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-aria/interactions/node_modules/clsx/dist/clsx.m.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@react-aria/interactions/node_modules/clsx/dist/clsx.m.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction r(e) {\n    var t, f, n = \"\";\n    if (\"string\" == typeof e || \"number\" == typeof e) n += e;\n    else if (\"object\" == typeof e) if (Array.isArray(e)) for(t = 0; t < e.length; t++)e[t] && (f = r(e[t])) && (n && (n += \" \"), n += f);\n    else for(t in e)e[t] && (n && (n += \" \"), n += t);\n    return n;\n}\nfunction clsx() {\n    for(var e, t, f = 0, n = \"\"; f < arguments.length;)(e = arguments[f++]) && (t = r(e)) && (n && (n += \" \"), n += t);\n    return n;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clsx);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsU0FBU0EsRUFBRUMsQ0FBQztJQUFFLElBQUlDLEdBQUVDLEdBQUVDLElBQUU7SUFBRyxJQUFHLFlBQVUsT0FBT0gsS0FBRyxZQUFVLE9BQU9BLEdBQUVHLEtBQUdIO1NBQU8sSUFBRyxZQUFVLE9BQU9BLEdBQUUsSUFBR0ksTUFBTUMsT0FBTyxDQUFDTCxJQUFHLElBQUlDLElBQUUsR0FBRUEsSUFBRUQsRUFBRU0sTUFBTSxFQUFDTCxJQUFJRCxDQUFDLENBQUNDLEVBQUUsSUFBR0MsQ0FBQUEsSUFBRUgsRUFBRUMsQ0FBQyxDQUFDQyxFQUFFLE1BQUtFLENBQUFBLEtBQUlBLENBQUFBLEtBQUcsR0FBRSxHQUFHQSxLQUFHRCxDQUFBQTtTQUFRLElBQUlELEtBQUtELEVBQUVBLENBQUMsQ0FBQ0MsRUFBRSxJQUFHRSxDQUFBQSxLQUFJQSxDQUFBQSxLQUFHLEdBQUUsR0FBR0EsS0FBR0YsQ0FBQUE7SUFBRyxPQUFPRTtBQUFDO0FBQVEsU0FBU0k7SUFBTyxJQUFJLElBQUlQLEdBQUVDLEdBQUVDLElBQUUsR0FBRUMsSUFBRSxJQUFHRCxJQUFFTSxVQUFVRixNQUFNLEVBQUUsQ0FBQ04sSUFBRVEsU0FBUyxDQUFDTixJQUFJLEtBQUlELENBQUFBLElBQUVGLEVBQUVDLEVBQUMsS0FBS0csQ0FBQUEsS0FBSUEsQ0FBQUEsS0FBRyxHQUFFLEdBQUdBLEtBQUdGLENBQUFBO0lBQUcsT0FBT0U7QUFBQztBQUFDLGlFQUFlSSxJQUFJQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2Fyem9uZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS9pbnRlcmFjdGlvbnMvbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm0uanM/NGNlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtlbHNlIGZvcih0IGluIGUpZVt0XSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiO2Y8YXJndW1lbnRzLmxlbmd0aDspKGU9YXJndW1lbnRzW2YrK10pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiXSwibmFtZXMiOlsiciIsImUiLCJ0IiwiZiIsIm4iLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJjbHN4IiwiYXJndW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/interactions/node_modules/clsx/dist/clsx.m.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/focus/dist/import.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@react-aria/focus/dist/import.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusRing: () => (/* binding */ $907718708eab68af$export$1a38b4ad7f578e1d),\n/* harmony export */   FocusScope: () => (/* binding */ $9bf71ea28793e738$export$20e40289641fbbb6),\n/* harmony export */   FocusableProvider: () => (/* binding */ $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5),\n/* harmony export */   createFocusManager: () => (/* binding */ $9bf71ea28793e738$export$c5251b9e124bf29),\n/* harmony export */   focusSafely: () => (/* binding */ $6a99195332edec8b$export$80f3e147d781571c),\n/* harmony export */   getFocusableTreeWalker: () => (/* binding */ $9bf71ea28793e738$export$2d6ec8fc375ceafa),\n/* harmony export */   isElementInChildOfActiveScope: () => (/* binding */ $9bf71ea28793e738$export$1258395f99bf9cbf),\n/* harmony export */   useFocusManager: () => (/* binding */ $9bf71ea28793e738$export$10c5169755ce7bd7),\n/* harmony export */   useFocusRing: () => (/* binding */ $f7dceffc5ad7768b$export$4e328f61c538687f),\n/* harmony export */   useFocusable: () => (/* binding */ $e6afbd83fe6ebbd2$export$4c014de7c8940b4c),\n/* harmony export */   useHasTabbableChild: () => (/* binding */ $83013635b024ae3d$export$eac1895992b9f3d6)\n/* harmony export */ });\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-aria/interactions */ \"(ssr)/./node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/import.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6a99195332edec8b$export$80f3e147d781571c(element) {\n    // If the user is interacting with a virtual cursor, e.g. screen reader, then\n    // wait until after any animated transitions that are currently occurring on\n    // the page before shifting focus. This avoids issues with VoiceOver on iOS\n    // causing the page to scroll when moving focus if the element is transitioning\n    // from off the screen.\n    const ownerDocument = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(element);\n    if ((0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_3__.getInteractionModality)() === \"virtual\") {\n        let lastFocusedElement = ownerDocument.activeElement;\n        (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.runAfterTransition)(()=>{\n            // If focus did not move and the element is still in the document, focus it.\n            if (ownerDocument.activeElement === lastFocusedElement && element.isConnected) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.focusWithoutScrolling)(element);\n        });\n    } else (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.focusWithoutScrolling)(element);\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $645f2e67b85a24c9$var$isStyleVisible(element) {\n    const windowObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerWindow)(element);\n    if (!(element instanceof windowObject.HTMLElement) && !(element instanceof windowObject.SVGElement)) return false;\n    let { display: display, visibility: visibility } = element.style;\n    let isVisible = display !== \"none\" && visibility !== \"hidden\" && visibility !== \"collapse\";\n    if (isVisible) {\n        const { getComputedStyle: getComputedStyle } = element.ownerDocument.defaultView;\n        let { display: computedDisplay, visibility: computedVisibility } = getComputedStyle(element);\n        isVisible = computedDisplay !== \"none\" && computedVisibility !== \"hidden\" && computedVisibility !== \"collapse\";\n    }\n    return isVisible;\n}\nfunction $645f2e67b85a24c9$var$isAttributeVisible(element, childElement) {\n    return !element.hasAttribute(\"hidden\") && (element.nodeName === \"DETAILS\" && childElement && childElement.nodeName !== \"SUMMARY\" ? element.hasAttribute(\"open\") : true);\n}\nfunction $645f2e67b85a24c9$export$e989c0fffaa6b27a(element, childElement) {\n    return element.nodeName !== \"#comment\" && $645f2e67b85a24c9$var$isStyleVisible(element) && $645f2e67b85a24c9$var$isAttributeVisible(element, childElement) && (!element.parentElement || $645f2e67b85a24c9$export$e989c0fffaa6b27a(element.parentElement, element));\n}\nconst $9bf71ea28793e738$var$FocusContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(null);\nlet $9bf71ea28793e738$var$activeScope = null;\nfunction $9bf71ea28793e738$export$20e40289641fbbb6(props) {\n    let { children: children, contain: contain, restoreFocus: restoreFocus, autoFocus: autoFocus } = props;\n    let startRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let endRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let scopeRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    let { parentNode: parentNode } = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($9bf71ea28793e738$var$FocusContext) || {};\n    // Create a tree node here so we can add children to it even before it is added to the tree.\n    let node = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: scopeRef\n        }), [\n        scopeRef\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n        // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n        // that is being added should get the activeScope as its parent.\n        let parent = parentNode || $9bf71ea28793e738$export$d06fae2ee68b101e.root;\n        if ($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $9bf71ea28793e738$var$activeScope && !$9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, parent.scopeRef)) {\n            let activeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n            if (activeNode) parent = activeNode;\n        }\n        // Add the node to the parent, and to the tree.\n        parent.addChild(node);\n        $9bf71ea28793e738$export$d06fae2ee68b101e.addNode(node);\n    }, [\n        node,\n        parentNode\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        let node = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n        if (node) node.contain = !!contain;\n    }, [\n        contain\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        var _startRef_current;\n        // Find all rendered nodes between the sentinels and add them to the scope.\n        let node = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;\n        let nodes = [];\n        while(node && node !== endRef.current){\n            nodes.push(node);\n            node = node.nextSibling;\n        }\n        scopeRef.current = nodes;\n    }, [\n        children\n    ]);\n    $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain);\n    $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus);\n    // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n    // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const activeElement = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;\n        let scope = null;\n        if ($9bf71ea28793e738$var$isElementInScope(activeElement, scopeRef.current)) {\n            // We need to traverse the focusScope tree and find the bottom most scope that\n            // contains the active element and set that as the activeScope.\n            for (let node of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse())if (node.scopeRef && $9bf71ea28793e738$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;\n            if (scope === $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $9bf71ea28793e738$var$activeScope = scope.scopeRef;\n        }\n    }, [\n        scopeRef\n    ]);\n    // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n    // in useRestoreFocus cleanup runs.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        return ()=>{\n            var _focusScopeTree_getTreeNode_parent, _focusScopeTree_getTreeNode;\n            var _focusScopeTree_getTreeNode_parent_scopeRef;\n            // Scope may have been re-parented.\n            let parentScope = (_focusScopeTree_getTreeNode_parent_scopeRef = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : (_focusScopeTree_getTreeNode_parent = _focusScopeTree_getTreeNode.parent) === null || _focusScopeTree_getTreeNode_parent === void 0 ? void 0 : _focusScopeTree_getTreeNode_parent.scopeRef) !== null && _focusScopeTree_getTreeNode_parent_scopeRef !== void 0 ? _focusScopeTree_getTreeNode_parent_scopeRef : null;\n            if ((scopeRef === $9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope(scopeRef, $9bf71ea28793e738$var$activeScope)) && (!parentScope || $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parentScope))) $9bf71ea28793e738$var$activeScope = parentScope;\n            $9bf71ea28793e738$export$d06fae2ee68b101e.removeTreeNode(scopeRef);\n        };\n    }, [\n        scopeRef\n    ]);\n    let focusManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$9bf71ea28793e738$var$createFocusManagerForScope(scopeRef), []);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            focusManager: focusManager,\n            parentNode: node\n        }), [\n        node,\n        focusManager\n    ]);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($9bf71ea28793e738$var$FocusContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement(\"span\", {\n        \"data-focus-scope-start\": true,\n        hidden: true,\n        ref: startRef\n    }), children, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement(\"span\", {\n        \"data-focus-scope-end\": true,\n        hidden: true,\n        ref: endRef\n    }));\n}\nfunction $9bf71ea28793e738$export$10c5169755ce7bd7() {\n    var _useContext;\n    return (_useContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($9bf71ea28793e738$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;\n}\nfunction $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {\n    return {\n        focusNext (opts = {}) {\n            let scope = scopeRef.current;\n            let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;\n            let node = from || (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(scope[0]).activeElement;\n            let sentinel = scope[0].previousElementSibling;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = sentinel;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = {}) {\n            let scope = scopeRef.current;\n            let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;\n            let node = from || (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(scope[0]).activeElement;\n            let sentinel = scope[scope.length - 1].nextElementSibling;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = sentinel;\n                previousNode = walker.previousNode();\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        },\n        focusFirst (opts = {}) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable, accept: accept } = opts;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[0].previousElementSibling;\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = {}) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable, accept: accept } = opts;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[scope.length - 1].nextElementSibling;\n            let previousNode = walker.previousNode();\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        }\n    };\n}\nconst $9bf71ea28793e738$var$focusableElements = [\n    \"input:not([disabled]):not([type=hidden])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"button:not([disabled])\",\n    \"a[href]\",\n    \"area[href]\",\n    \"summary\",\n    \"iframe\",\n    \"object\",\n    \"embed\",\n    \"audio[controls]\",\n    \"video[controls]\",\n    \"[contenteditable]\"\n];\nconst $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(\":not([hidden]),\") + \",[tabindex]:not([disabled]):not([hidden])\";\n$9bf71ea28793e738$var$focusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\nfunction $9bf71ea28793e738$var$getScopeRoot(scope) {\n    return scope[0].parentElement;\n}\nfunction $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {\n    let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n    while(scope && scope.scopeRef !== scopeRef){\n        if (scope.contain) return false;\n        scope = scope.parent;\n    }\n    return true;\n}\nfunction $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {\n    let focusedNode = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let raf = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        let scope = scopeRef.current;\n        if (!contain) {\n            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n            if (raf.current) {\n                cancelAnimationFrame(raf.current);\n                raf.current = undefined;\n            }\n            return;\n        }\n        const ownerDocument = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(scope ? scope[0] : undefined);\n        // Handle the Tab key to contain focus within the scope\n        let onKeyDown = (e)=>{\n            if (e.key !== \"Tab\" || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef)) return;\n            let focusedElement = ownerDocument.activeElement;\n            let scope = scopeRef.current;\n            if (!scope || !$9bf71ea28793e738$var$isElementInScope(focusedElement, scope)) return;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: true\n            }, scope);\n            if (!focusedElement) return;\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!nextElement) {\n                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;\n                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            }\n            e.preventDefault();\n            if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n        };\n        let onFocus = (e)=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(e.target, scopeRef.current)) {\n                $9bf71ea28793e738$var$activeScope = scopeRef;\n                focusedNode.current = e.target;\n            } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(e.target, scopeRef)) {\n                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n                // restore focus to the previously focused node or the first tabbable element in the active scope.\n                if (focusedNode.current) focusedNode.current.focus();\n                else if ($9bf71ea28793e738$var$activeScope && $9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n            } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;\n        };\n        let onBlur = (e)=>{\n            // Firefox doesn't shift focus back to the Dialog properly without this\n            if (raf.current) cancelAnimationFrame(raf.current);\n            raf.current = requestAnimationFrame(()=>{\n                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n                if (ownerDocument.activeElement && $9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(ownerDocument.activeElement, scopeRef)) {\n                    $9bf71ea28793e738$var$activeScope = scopeRef;\n                    if (ownerDocument.body.contains(e.target)) {\n                        var _focusedNode_current;\n                        focusedNode.current = e.target;\n                        (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();\n                    } else if ($9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n                }\n            });\n        };\n        ownerDocument.addEventListener(\"keydown\", onKeyDown, false);\n        ownerDocument.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusout\", onBlur, false));\n        return ()=>{\n            ownerDocument.removeEventListener(\"keydown\", onKeyDown, false);\n            ownerDocument.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusout\", onBlur, false));\n        };\n    }, [\n        scopeRef,\n        contain\n    ]);\n    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n    // eslint-disable-next-line arrow-body-style\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        return ()=>{\n            if (raf.current) cancelAnimationFrame(raf.current);\n        };\n    }, [\n        raf\n    ]);\n}\nfunction $9bf71ea28793e738$var$isElementInAnyScope(element) {\n    return $9bf71ea28793e738$var$isElementInChildScope(element);\n}\nfunction $9bf71ea28793e738$var$isElementInScope(element, scope) {\n    if (!element) return false;\n    if (!scope) return false;\n    return scope.some((node)=>node.contains(element));\n}\nfunction $9bf71ea28793e738$var$isElementInChildScope(element, scope = null) {\n    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n    if (element instanceof Element && element.closest(\"[data-react-aria-top-layer]\")) return true;\n    // node.contains in isElementInScope covers child scopes that are also DOM children,\n    // but does not cover child scopes in portals.\n    for (let { scopeRef: s } of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope))){\n        if (s && $9bf71ea28793e738$var$isElementInScope(element, s.current)) return true;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$export$1258395f99bf9cbf(element) {\n    return $9bf71ea28793e738$var$isElementInChildScope(element, $9bf71ea28793e738$var$activeScope);\n}\nfunction $9bf71ea28793e738$var$isAncestorScope(ancestor, scope) {\n    var _focusScopeTree_getTreeNode;\n    let parent = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;\n    while(parent){\n        if (parent.scopeRef === ancestor) return true;\n        parent = parent.parent;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$var$focusElement(element, scroll = false) {\n    if (element != null && !scroll) try {\n        (0, $6a99195332edec8b$export$80f3e147d781571c)(element);\n    } catch (err) {\n    // ignore\n    }\n    else if (element != null) try {\n        element.focus();\n    } catch (err) {\n    // ignore\n    }\n}\nfunction $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {\n    let sentinel = scope[0].previousElementSibling;\n    let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n    let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n        tabbable: tabbable\n    }, scope);\n    walker.currentNode = sentinel;\n    let nextNode = walker.nextNode();\n    // If the scope does not contain a tabbable element, use the first focusable element.\n    if (tabbable && !nextNode) {\n        scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n        walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n            tabbable: false\n        }, scope);\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode();\n    }\n    $9bf71ea28793e738$var$focusElement(nextNode);\n}\nfunction $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {\n    const autoFocusRef = (0, react__WEBPACK_IMPORTED_MODULE_0__).useRef(autoFocus);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (autoFocusRef.current) {\n            $9bf71ea28793e738$var$activeScope = scopeRef;\n            const ownerDocument = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);\n            if (!$9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, $9bf71ea28793e738$var$activeScope.current) && scopeRef.current) $9bf71ea28793e738$var$focusFirstInScope(scopeRef.current);\n        }\n        autoFocusRef.current = false;\n    }, [\n        scopeRef\n    ]);\n}\nfunction $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain) {\n    // tracks the active scope, in case restore and contain are both false.\n    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        if (restore || contain) return;\n        let scope = scopeRef.current;\n        const ownerDocument = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(scope ? scope[0] : undefined);\n        let onFocus = (e)=>{\n            let target = e.target;\n            if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;\n            else if (!$9bf71ea28793e738$var$isElementInAnyScope(target)) $9bf71ea28793e738$var$activeScope = null;\n        };\n        ownerDocument.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        return ()=>{\n            ownerDocument.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n        };\n    }, [\n        scopeRef,\n        restore,\n        contain\n    ]);\n}\nfunction $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef) {\n    let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n    while(scope && scope.scopeRef !== scopeRef){\n        if (scope.nodeToRestore) return false;\n        scope = scope.parent;\n    }\n    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;\n}\nfunction $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain) {\n    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n    // eslint-disable-next-line no-restricted-globals\n    const nodeToRestoreRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof document !== \"undefined\" ? (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined).activeElement : null);\n    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n    // restoring-non-containing scopes should only care if they become active so they can perform the restore\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        let scope = scopeRef.current;\n        const ownerDocument = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(scope ? scope[0] : undefined);\n        if (!restoreFocus || contain) return;\n        let onFocus = ()=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;\n        };\n        ownerDocument.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        return ()=>{\n            ownerDocument.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        scopeRef,\n        contain\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        const ownerDocument = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);\n        if (!restoreFocus) return;\n        // Handle the Tab key so that tabbing out of the scope goes to the next element\n        // after the node that had focus when the scope mounted. This is important when\n        // using portals for overlays, so that focus goes to the expected element when\n        // tabbing out of the overlay.\n        let onKeyDown = (e)=>{\n            if (e.key !== \"Tab\" || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef)) return;\n            let focusedElement = ownerDocument.activeElement;\n            if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scopeRef.current)) return;\n            let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n            if (!treeNode) return;\n            let nodeToRestore = treeNode.nodeToRestore;\n            // Create a DOM tree walker that matches all tabbable elements\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(ownerDocument.body, {\n                tabbable: true\n            });\n            // Find the next tabbable element after the currently focused element\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {\n                nodeToRestore = undefined;\n                treeNode.nodeToRestore = undefined;\n            }\n            // If there is no next element, or it is outside the current scope, move focus to the\n            // next element after the node to restore to instead.\n            if ((!nextElement || !$9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n                walker.currentNode = nodeToRestore;\n                // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n                while ($9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current));\n                e.preventDefault();\n                e.stopPropagation();\n                if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n                else // then move focus to the body.\n                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n                if (!$9bf71ea28793e738$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();\n                else $9bf71ea28793e738$var$focusElement(nodeToRestore, true);\n            }\n        };\n        if (!contain) ownerDocument.addEventListener(\"keydown\", onKeyDown, true);\n        return ()=>{\n            if (!contain) ownerDocument.removeEventListener(\"keydown\", onKeyDown, true);\n        };\n    }, [\n        scopeRef,\n        restoreFocus,\n        contain\n    ]);\n    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        const ownerDocument = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);\n        if (!restoreFocus) return;\n        let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n        if (!treeNode) return;\n        var _nodeToRestoreRef_current;\n        treeNode.nodeToRestore = (_nodeToRestoreRef_current = nodeToRestoreRef.current) !== null && _nodeToRestoreRef_current !== void 0 ? _nodeToRestoreRef_current : undefined;\n        return ()=>{\n            let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n            if (!treeNode) return;\n            let nodeToRestore = treeNode.nodeToRestore;\n            // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps\n            ($9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === ownerDocument.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {\n                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n                let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();\n                requestAnimationFrame(()=>{\n                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n                    if (ownerDocument.activeElement === ownerDocument.body) {\n                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n                        let treeNode = clonedTree.getTreeNode(scopeRef);\n                        while(treeNode){\n                            if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {\n                                $9bf71ea28793e738$var$focusElement(treeNode.nodeToRestore);\n                                return;\n                            }\n                            treeNode = treeNode.parent;\n                        }\n                        // If no nodeToRestore was found, focus the first element in the nearest\n                        // ancestor scope that is still in the tree.\n                        treeNode = clonedTree.getTreeNode(scopeRef);\n                        while(treeNode){\n                            if (treeNode.scopeRef && treeNode.scopeRef.current && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {\n                                $9bf71ea28793e738$var$focusFirstInScope(treeNode.scopeRef.current, true);\n                                return;\n                            }\n                            treeNode = treeNode.parent;\n                        }\n                    }\n                });\n            }\n        };\n    }, [\n        scopeRef,\n        restoreFocus\n    ]);\n}\nfunction $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {\n    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;\n    let walker = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(root).createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n        acceptNode (node) {\n            var _opts_from;\n            // Skip nodes inside the starting node.\n            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;\n            if (node.matches(selector) && (0, $645f2e67b85a24c9$export$e989c0fffaa6b27a)(node) && (!scope || $9bf71ea28793e738$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;\n            return NodeFilter.FILTER_SKIP;\n        }\n    });\n    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;\n    return walker;\n}\nfunction $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {\n    return {\n        focusNext (opts = {}) {\n            let root = ref.current;\n            if (!root) return null;\n            let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;\n            let node = from || (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(root).activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = root;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;\n            let node = from || (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(root).activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            else {\n                let next = $9bf71ea28793e738$var$last(walker);\n                if (next) $9bf71ea28793e738$var$focusElement(next, true);\n                return next !== null && next !== void 0 ? next : null;\n            }\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = root;\n                let lastNode = $9bf71ea28793e738$var$last(walker);\n                if (!lastNode) return null;\n                previousNode = lastNode;\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode !== null && previousNode !== void 0 ? previousNode : null;\n        },\n        focusFirst (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { tabbable: tabbable = defaultOptions.tabbable, accept: accept = defaultOptions.accept } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { tabbable: tabbable = defaultOptions.tabbable, accept: accept = defaultOptions.accept } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let next = $9bf71ea28793e738$var$last(walker);\n            if (next) $9bf71ea28793e738$var$focusElement(next, true);\n            return next !== null && next !== void 0 ? next : null;\n        }\n    };\n}\nfunction $9bf71ea28793e738$var$last(walker) {\n    let next = undefined;\n    let last;\n    do {\n        last = walker.lastChild();\n        if (last) next = last;\n    }while (last);\n    return next;\n}\nclass $9bf71ea28793e738$var$Tree {\n    get size() {\n        return this.fastMap.size;\n    }\n    getTreeNode(data) {\n        return this.fastMap.get(data);\n    }\n    addTreeNode(scopeRef, parent, nodeToRestore) {\n        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);\n        if (!parentNode) return;\n        let node = new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: scopeRef\n        });\n        parentNode.addChild(node);\n        node.parent = parentNode;\n        this.fastMap.set(scopeRef, node);\n        if (nodeToRestore) node.nodeToRestore = nodeToRestore;\n    }\n    addNode(node) {\n        this.fastMap.set(node.scopeRef, node);\n    }\n    removeTreeNode(scopeRef) {\n        // never remove the root\n        if (scopeRef === null) return;\n        let node = this.fastMap.get(scopeRef);\n        if (!node) return;\n        let parentNode = node.parent;\n        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n        // if we are, then replace the siblings restore with the restore from the scope we're removing\n        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef && node.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;\n        let children = node.children;\n        if (parentNode) {\n            parentNode.removeChild(node);\n            if (children.size > 0) children.forEach((child)=>parentNode && parentNode.addChild(child));\n        }\n        this.fastMap.delete(node.scopeRef);\n    }\n    // Pre Order Depth First\n    *traverse(node = this.root) {\n        if (node.scopeRef != null) yield node;\n        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);\n    }\n    clone() {\n        var _node_parent;\n        let newTree = new $9bf71ea28793e738$var$Tree();\n        var _node_parent_scopeRef;\n        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, (_node_parent_scopeRef = (_node_parent = node.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.scopeRef) !== null && _node_parent_scopeRef !== void 0 ? _node_parent_scopeRef : null, node.nodeToRestore);\n        return newTree;\n    }\n    constructor(){\n        this.fastMap = new Map();\n        this.root = new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: null\n        });\n        this.fastMap.set(null, this.root);\n    }\n}\nclass $9bf71ea28793e738$var$TreeNode {\n    addChild(node) {\n        this.children.add(node);\n        node.parent = this;\n    }\n    removeChild(node) {\n        this.children.delete(node);\n        node.parent = undefined;\n    }\n    constructor(props){\n        this.children = new Set();\n        this.contain = false;\n        this.scopeRef = props.scopeRef;\n    }\n}\nlet $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {\n    let { autoFocus: autoFocus = false, isTextInput: isTextInput, within: within } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocused: false,\n        isFocusVisible: autoFocus || (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_3__.isFocusVisible)()\n    });\n    let [isFocused, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isFocusVisibleState, setFocusVisible] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>state.current.isFocused && state.current.isFocusVisible);\n    let updateState = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);\n    let onFocusChange = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((isFocused)=>{\n        state.current.isFocused = isFocused;\n        setFocused(isFocused);\n        updateState();\n    }, [\n        updateState\n    ]);\n    (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_3__.useFocusVisibleListener)((isFocusVisible)=>{\n        state.current.isFocusVisible = isFocusVisible;\n        updateState();\n    }, [], {\n        isTextInput: isTextInput\n    });\n    let { focusProps: focusProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_3__.useFocus)({\n        isDisabled: within,\n        onFocusChange: onFocusChange\n    });\n    let { focusWithinProps: focusWithinProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_3__.useFocusWithin)({\n        isDisabled: !within,\n        onFocusWithinChange: onFocusChange\n    });\n    return {\n        isFocused: isFocused,\n        isFocusVisible: isFocusVisibleState,\n        focusProps: within ? focusWithinProps : focusProps\n    };\n}\nfunction $907718708eab68af$export$1a38b4ad7f578e1d(props) {\n    let { children: children, focusClass: focusClass, focusRingClass: focusRingClass } = props;\n    let { isFocused: isFocused, isFocusVisible: isFocusVisible, focusProps: focusProps } = (0, $f7dceffc5ad7768b$export$4e328f61c538687f)(props);\n    let child = (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.only(children);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).cloneElement(child, (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.mergeProps)(child.props, {\n        ...focusProps,\n        className: (0, clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n            [focusClass || \"\"]: isFocused,\n            [focusRingClass || \"\"]: isFocusVisible\n        })\n    }));\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $e6afbd83fe6ebbd2$var$FocusableContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(null);\nfunction $e6afbd83fe6ebbd2$var$useFocusableContext(ref) {\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($e6afbd83fe6ebbd2$var$FocusableContext) || {};\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useSyncRef)(context, ref);\n    // eslint-disable-next-line\n    let { ref: _, ...otherProps } = context;\n    return otherProps;\n}\n/**\n * Provides DOM props to the nearest focusable child.\n */ function $e6afbd83fe6ebbd2$var$FocusableProvider(props, ref) {\n    let { children: children, ...otherProps } = props;\n    let objRef = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useObjectRef)(ref);\n    let context = {\n        ...otherProps,\n        ref: objRef\n    };\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($e6afbd83fe6ebbd2$var$FocusableContext.Provider, {\n        value: context\n    }, children);\n}\nlet $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef($e6afbd83fe6ebbd2$var$FocusableProvider);\nfunction $e6afbd83fe6ebbd2$export$4c014de7c8940b4c(props, domRef) {\n    let { focusProps: focusProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_3__.useFocus)(props);\n    let { keyboardProps: keyboardProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_3__.useKeyboard)(props);\n    let interactions = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.mergeProps)(focusProps, keyboardProps);\n    let domProps = $e6afbd83fe6ebbd2$var$useFocusableContext(domRef);\n    let interactionProps = props.isDisabled ? {} : domProps;\n    let autoFocusRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props.autoFocus);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (autoFocusRef.current && domRef.current) (0, $6a99195332edec8b$export$80f3e147d781571c)(domRef.current);\n        autoFocusRef.current = false;\n    }, [\n        domRef\n    ]);\n    return {\n        focusableProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.mergeProps)({\n            ...interactions,\n            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined\n        }, interactionProps)\n    };\n}\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $83013635b024ae3d$export$eac1895992b9f3d6(ref, options) {\n    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;\n    let [hasTabbableChild, setHasTabbableChild] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {\n            let update = ()=>{\n                if (ref.current) {\n                    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current, {\n                        tabbable: true\n                    });\n                    setHasTabbableChild(!!walker.nextNode());\n                }\n            };\n            update();\n            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.\n            let observer = new MutationObserver(update);\n            observer.observe(ref.current, {\n                subtree: true,\n                childList: true,\n                attributes: true,\n                attributeFilter: [\n                    \"tabIndex\",\n                    \"disabled\"\n                ]\n            });\n            return ()=>{\n                // Disconnect mutation observer when a React update occurs on the top-level component\n                // so we update synchronously after re-rendering. Otherwise React will emit act warnings\n                // in tests since mutation observers fire asynchronously. The mutation observer is necessary\n                // so we also update if a child component re-renders and adds/removes something tabbable.\n                observer.disconnect();\n            };\n        }\n    });\n    return isDisabled ? false : hasTabbableChild;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvZm9jdXMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpWDtBQUMxSjtBQUN1RjtBQUMvUTtBQUUvQjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FFRCxTQUFTMEMsMENBQTBDQyxPQUFPO0lBQ3RELDZFQUE2RTtJQUM3RSw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLCtFQUErRTtJQUMvRSx1QkFBdUI7SUFDdkIsTUFBTUMsZ0JBQWdCLENBQUMsR0FBR3pDLCtEQUFzQixFQUFHd0M7SUFDbkQsSUFBSSxDQUFDLEdBQUdiLDRFQUE0QixRQUFTLFdBQVc7UUFDcEQsSUFBSWUscUJBQXFCRCxjQUFjRSxhQUFhO1FBQ25ELElBQUd6QyxpRUFBd0IsRUFBRztZQUMzQiw0RUFBNEU7WUFDNUUsSUFBSXVDLGNBQWNFLGFBQWEsS0FBS0Qsc0JBQXNCRixRQUFRSSxXQUFXLEVBQUUsQ0FBQyxHQUFHeEMsb0VBQTJCLEVBQUdvQztRQUNySDtJQUNKLE9BQU8sQ0FBQyxHQUFHcEMsb0VBQTJCLEVBQUdvQztBQUM3QztBQUlBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTSyxxQ0FBcUNMLE9BQU87SUFDakQsTUFBTU0sZUFBZSxDQUFDLEdBQUd4Qyw2REFBb0IsRUFBR2tDO0lBQ2hELElBQUksQ0FBRUEsQ0FBQUEsbUJBQW1CTSxhQUFhQyxXQUFXLEtBQUssQ0FBRVAsQ0FBQUEsbUJBQW1CTSxhQUFhRSxVQUFVLEdBQUcsT0FBTztJQUM1RyxJQUFJLEVBQUVDLFNBQVNBLE9BQU8sRUFBRUMsWUFBWUEsVUFBVSxFQUFFLEdBQUdWLFFBQVFXLEtBQUs7SUFDaEUsSUFBSUMsWUFBWUgsWUFBWSxVQUFVQyxlQUFlLFlBQVlBLGVBQWU7SUFDaEYsSUFBSUUsV0FBVztRQUNYLE1BQU0sRUFBRUMsa0JBQWtCQSxnQkFBZ0IsRUFBRSxHQUFHYixRQUFRQyxhQUFhLENBQUNhLFdBQVc7UUFDaEYsSUFBSSxFQUFFTCxTQUFTTSxlQUFlLEVBQUVMLFlBQVlNLGtCQUFrQixFQUFFLEdBQUdILGlCQUFpQmI7UUFDcEZZLFlBQVlHLG9CQUFvQixVQUFVQyx1QkFBdUIsWUFBWUEsdUJBQXVCO0lBQ3hHO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLFNBQVNLLHlDQUF5Q2pCLE9BQU8sRUFBRWtCLFlBQVk7SUFDbkUsT0FBTyxDQUFDbEIsUUFBUW1CLFlBQVksQ0FBQyxhQUFjbkIsQ0FBQUEsUUFBUW9CLFFBQVEsS0FBSyxhQUFhRixnQkFBZ0JBLGFBQWFFLFFBQVEsS0FBSyxZQUFZcEIsUUFBUW1CLFlBQVksQ0FBQyxVQUFVLElBQUc7QUFDeks7QUFDQSxTQUFTRSwwQ0FBMENyQixPQUFPLEVBQUVrQixZQUFZO0lBQ3BFLE9BQU9sQixRQUFRb0IsUUFBUSxLQUFLLGNBQWNmLHFDQUFxQ0wsWUFBWWlCLHlDQUF5Q2pCLFNBQVNrQixpQkFBa0IsRUFBQ2xCLFFBQVFzQixhQUFhLElBQUlELDBDQUEwQ3JCLFFBQVFzQixhQUFhLEVBQUV0QixRQUFPO0FBQ3JRO0FBSUEsTUFBTXVCLHFDQUFtRCxXQUFILEdBQUksSUFBR2xELGtDQUFXLEVBQUdtRCxhQUFhLENBQUM7QUFDekYsSUFBSUMsb0NBQW9DO0FBQ3hDLFNBQVNDLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLFVBQVVBLFFBQVEsRUFBRUMsU0FBU0EsT0FBTyxFQUFFQyxjQUFjQSxZQUFZLEVBQUVDLFdBQVdBLFNBQVMsRUFBRSxHQUFHSjtJQUNqRyxJQUFJSyxXQUFXLENBQUMsR0FBR3pELHlDQUFZLEVBQUc7SUFDbEMsSUFBSTBELFNBQVMsQ0FBQyxHQUFHMUQseUNBQVksRUFBRztJQUNoQyxJQUFJMkQsV0FBVyxDQUFDLEdBQUczRCx5Q0FBWSxFQUFHLEVBQUU7SUFDcEMsSUFBSSxFQUFFNEQsWUFBWUEsVUFBVSxFQUFFLEdBQUcsQ0FBQyxHQUFHMUQsNkNBQWdCLEVBQUc4Qyx1Q0FBdUMsQ0FBQztJQUNoRyw0RkFBNEY7SUFDNUYsSUFBSWEsT0FBTyxDQUFDLEdBQUd6RCwwQ0FBYSxFQUFHLElBQUksSUFBSTBELCtCQUErQjtZQUM5REgsVUFBVUE7UUFDZCxJQUFJO1FBQ0pBO0tBQ0g7SUFDQSxJQUFHNUUsOERBQXFCLEVBQUc7UUFDeEIsK0ZBQStGO1FBQy9GLG1HQUFtRztRQUNuRyxtR0FBbUc7UUFDbkcsZ0VBQWdFO1FBQ2hFLElBQUlnRixTQUFTSCxjQUFjSSwwQ0FBMENDLElBQUk7UUFDekUsSUFBSUQsMENBQTBDRSxXQUFXLENBQUNILE9BQU9KLFFBQVEsS0FBS1QscUNBQXFDLENBQUNpQixzQ0FBc0NqQixtQ0FBbUNhLE9BQU9KLFFBQVEsR0FBRztZQUMzTSxJQUFJUyxhQUFhSiwwQ0FBMENFLFdBQVcsQ0FBQ2hCO1lBQ3ZFLElBQUlrQixZQUFZTCxTQUFTSztRQUM3QjtRQUNBLCtDQUErQztRQUMvQ0wsT0FBT00sUUFBUSxDQUFDUjtRQUNoQkcsMENBQTBDTSxPQUFPLENBQUNUO0lBQ3RELEdBQUc7UUFDQ0E7UUFDQUQ7S0FDSDtJQUNBLElBQUc3RSw4REFBcUIsRUFBRztRQUN4QixJQUFJOEUsT0FBT0csMENBQTBDRSxXQUFXLENBQUNQO1FBQ2pFLElBQUlFLE1BQU1BLEtBQUtQLE9BQU8sR0FBRyxDQUFDLENBQUNBO0lBQy9CLEdBQUc7UUFDQ0E7S0FDSDtJQUNBLElBQUd2RSw4REFBcUIsRUFBRztRQUN4QixJQUFJd0Y7UUFDSiwyRUFBMkU7UUFDM0UsSUFBSVYsT0FBTyxDQUFDVSxvQkFBb0JkLFNBQVNlLE9BQU8sTUFBTSxRQUFRRCxzQkFBc0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsa0JBQWtCRSxXQUFXO1FBQ25JLElBQUlDLFFBQVEsRUFBRTtRQUNkLE1BQU1iLFFBQVFBLFNBQVNILE9BQU9jLE9BQU8sQ0FBQztZQUNsQ0UsTUFBTUMsSUFBSSxDQUFDZDtZQUNYQSxPQUFPQSxLQUFLWSxXQUFXO1FBQzNCO1FBQ0FkLFNBQVNhLE9BQU8sR0FBR0U7SUFDdkIsR0FBRztRQUNDckI7S0FDSDtJQUNEdUIsNENBQTRDakIsVUFBVUosY0FBY0Q7SUFDcEV1QiwwQ0FBMENsQixVQUFVTDtJQUNwRHdCLHNDQUFzQ25CLFVBQVVKLGNBQWNEO0lBQzlEeUIsbUNBQW1DcEIsVUFBVUg7SUFDN0MsbUdBQW1HO0lBQ25HLHVHQUF1RztJQUN0RyxJQUFHbEQsNENBQWUsRUFBRztRQUNsQixNQUFNc0IsZ0JBQWdCLENBQUMsR0FBRzNDLCtEQUFzQixFQUFHMEUsU0FBU2EsT0FBTyxHQUFHYixTQUFTYSxPQUFPLENBQUMsRUFBRSxHQUFHUSxXQUFXcEQsYUFBYTtRQUNwSCxJQUFJcUQsUUFBUTtRQUNaLElBQUlDLHVDQUF1Q3RELGVBQWUrQixTQUFTYSxPQUFPLEdBQUc7WUFDekUsOEVBQThFO1lBQzlFLCtEQUErRDtZQUMvRCxLQUFLLElBQUlYLFFBQVFHLDBDQUEwQ21CLFFBQVEsR0FBRyxJQUFJdEIsS0FBS0YsUUFBUSxJQUFJdUIsdUNBQXVDdEQsZUFBZWlDLEtBQUtGLFFBQVEsQ0FBQ2EsT0FBTyxHQUFHUyxRQUFRcEI7WUFDakwsSUFBSW9CLFVBQVVqQiwwQ0FBMENFLFdBQVcsQ0FBQ1AsV0FBV1Qsb0NBQW9DK0IsTUFBTXRCLFFBQVE7UUFDckk7SUFDSixHQUFHO1FBQ0NBO0tBQ0g7SUFDRCx5R0FBeUc7SUFDekcsbUNBQW1DO0lBQ2xDLElBQUc1RSw4REFBcUIsRUFBRztRQUN4QixPQUFPO1lBQ0gsSUFBSXFHLG9DQUFvQ0M7WUFDeEMsSUFBSUM7WUFDSixtQ0FBbUM7WUFDbkMsSUFBSUMsY0FBYyxDQUFDRCw4Q0FBOEMsQ0FBQ0QsOEJBQThCckIsMENBQTBDRSxXQUFXLENBQUNQLFNBQVEsTUFBTyxRQUFRMEIsZ0NBQWdDLEtBQUssSUFBSSxLQUFLLElBQUksQ0FBQ0QscUNBQXFDQyw0QkFBNEJ0QixNQUFNLE1BQU0sUUFBUXFCLHVDQUF1QyxLQUFLLElBQUksS0FBSyxJQUFJQSxtQ0FBbUN6QixRQUFRLE1BQU0sUUFBUTJCLGdEQUFnRCxLQUFLLElBQUlBLDhDQUE4QztZQUM5Z0IsSUFBSSxDQUFDM0IsYUFBYVQscUNBQXFDaUIsc0NBQXNDUixVQUFVVCxrQ0FBaUMsS0FBTyxFQUFDcUMsZUFBZXZCLDBDQUEwQ0UsV0FBVyxDQUFDcUIsWUFBVyxHQUFJckMsb0NBQW9DcUM7WUFDeFF2QiwwQ0FBMEN3QixjQUFjLENBQUM3QjtRQUM3RDtJQUNKLEdBQUc7UUFDQ0E7S0FDSDtJQUNELElBQUk4QixlQUFlLENBQUMsR0FBR3JGLDBDQUFhLEVBQUcsSUFBSXNGLGlEQUFpRC9CLFdBQVcsRUFBRTtJQUN6RyxJQUFJZ0MsUUFBUSxDQUFDLEdBQUd2RiwwQ0FBYSxFQUFHLElBQUs7WUFDN0JxRixjQUFjQTtZQUNkN0IsWUFBWUM7UUFDaEIsSUFBSTtRQUNKQTtRQUNBNEI7S0FDSDtJQUNELE9BQXFCLFdBQUgsR0FBSSxJQUFHM0Ysa0NBQVcsRUFBRzhGLGFBQWEsQ0FBQzVDLG1DQUFtQzZDLFFBQVEsRUFBRTtRQUM5RkYsT0FBT0E7SUFDWCxHQUFpQixXQUFILEdBQUksSUFBRzdGLGtDQUFXLEVBQUc4RixhQUFhLENBQUMsUUFBUTtRQUNyRCwwQkFBMEI7UUFDMUJFLFFBQVE7UUFDUkMsS0FBS3RDO0lBQ1QsSUFBSUosVUFBd0IsV0FBSCxHQUFJLElBQUd2RCxrQ0FBVyxFQUFHOEYsYUFBYSxDQUFDLFFBQVE7UUFDaEUsd0JBQXdCO1FBQ3hCRSxRQUFRO1FBQ1JDLEtBQUtyQztJQUNUO0FBQ0o7QUFDQSxTQUFTc0M7SUFDTCxJQUFJQztJQUNKLE9BQU8sQ0FBQ0EsY0FBYyxDQUFDLEdBQUcvRiw2Q0FBZ0IsRUFBRzhDLG1DQUFrQyxNQUFPLFFBQVFpRCxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWVIsWUFBWTtBQUM1SjtBQUNBLFNBQVNDLGlEQUFpRC9CLFFBQVE7SUFDOUQsT0FBTztRQUNIdUMsV0FBV0MsT0FBTyxDQUFDLENBQUM7WUFDaEIsSUFBSWxCLFFBQVF0QixTQUFTYSxPQUFPO1lBQzVCLElBQUksRUFBRTRCLE1BQU1BLElBQUksRUFBRUMsVUFBVUEsUUFBUSxFQUFFQyxNQUFNQSxJQUFJLEVBQUVDLFFBQVFBLE1BQU0sRUFBRSxHQUFHSjtZQUNyRSxJQUFJdEMsT0FBT3VDLFFBQVEsQ0FBQyxHQUFHbkgsK0RBQXNCLEVBQUdnRyxLQUFLLENBQUMsRUFBRSxFQUFFckQsYUFBYTtZQUN2RSxJQUFJNEUsV0FBV3ZCLEtBQUssQ0FBQyxFQUFFLENBQUN3QixzQkFBc0I7WUFDOUMsSUFBSUMsWUFBWUMsbUNBQW1DMUI7WUFDbkQsSUFBSTJCLFNBQVNDLDBDQUEwQ0gsV0FBVztnQkFDOURMLFVBQVVBO2dCQUNWRSxRQUFRQTtZQUNaLEdBQUd0QjtZQUNIMkIsT0FBT0UsV0FBVyxHQUFHNUIsdUNBQXVDckIsTUFBTW9CLFNBQVNwQixPQUFPMkM7WUFDbEYsSUFBSU8sV0FBV0gsT0FBT0csUUFBUTtZQUM5QixJQUFJLENBQUNBLFlBQVlULE1BQU07Z0JBQ25CTSxPQUFPRSxXQUFXLEdBQUdOO2dCQUNyQk8sV0FBV0gsT0FBT0csUUFBUTtZQUM5QjtZQUNBLElBQUlBLFVBQVVDLG1DQUFtQ0QsVUFBVTtZQUMzRCxPQUFPQTtRQUNYO1FBQ0FFLGVBQWVkLE9BQU8sQ0FBQyxDQUFDO1lBQ3BCLElBQUlsQixRQUFRdEIsU0FBU2EsT0FBTztZQUM1QixJQUFJLEVBQUU0QixNQUFNQSxJQUFJLEVBQUVDLFVBQVVBLFFBQVEsRUFBRUMsTUFBTUEsSUFBSSxFQUFFQyxRQUFRQSxNQUFNLEVBQUUsR0FBR0o7WUFDckUsSUFBSXRDLE9BQU91QyxRQUFRLENBQUMsR0FBR25ILCtEQUFzQixFQUFHZ0csS0FBSyxDQUFDLEVBQUUsRUFBRXJELGFBQWE7WUFDdkUsSUFBSTRFLFdBQVd2QixLQUFLLENBQUNBLE1BQU1pQyxNQUFNLEdBQUcsRUFBRSxDQUFDQyxrQkFBa0I7WUFDekQsSUFBSVQsWUFBWUMsbUNBQW1DMUI7WUFDbkQsSUFBSTJCLFNBQVNDLDBDQUEwQ0gsV0FBVztnQkFDOURMLFVBQVVBO2dCQUNWRSxRQUFRQTtZQUNaLEdBQUd0QjtZQUNIMkIsT0FBT0UsV0FBVyxHQUFHNUIsdUNBQXVDckIsTUFBTW9CLFNBQVNwQixPQUFPMkM7WUFDbEYsSUFBSVksZUFBZVIsT0FBT1EsWUFBWTtZQUN0QyxJQUFJLENBQUNBLGdCQUFnQmQsTUFBTTtnQkFDdkJNLE9BQU9FLFdBQVcsR0FBR047Z0JBQ3JCWSxlQUFlUixPQUFPUSxZQUFZO1lBQ3RDO1lBQ0EsSUFBSUEsY0FBY0osbUNBQW1DSSxjQUFjO1lBQ25FLE9BQU9BO1FBQ1g7UUFDQUMsWUFBWWxCLE9BQU8sQ0FBQyxDQUFDO1lBQ2pCLElBQUlsQixRQUFRdEIsU0FBU2EsT0FBTztZQUM1QixJQUFJLEVBQUU2QixVQUFVQSxRQUFRLEVBQUVFLFFBQVFBLE1BQU0sRUFBRSxHQUFHSjtZQUM3QyxJQUFJTyxZQUFZQyxtQ0FBbUMxQjtZQUNuRCxJQUFJMkIsU0FBU0MsMENBQTBDSCxXQUFXO2dCQUM5REwsVUFBVUE7Z0JBQ1ZFLFFBQVFBO1lBQ1osR0FBR3RCO1lBQ0gyQixPQUFPRSxXQUFXLEdBQUc3QixLQUFLLENBQUMsRUFBRSxDQUFDd0Isc0JBQXNCO1lBQ3BELElBQUlNLFdBQVdILE9BQU9HLFFBQVE7WUFDOUIsSUFBSUEsVUFBVUMsbUNBQW1DRCxVQUFVO1lBQzNELE9BQU9BO1FBQ1g7UUFDQU8sV0FBV25CLE9BQU8sQ0FBQyxDQUFDO1lBQ2hCLElBQUlsQixRQUFRdEIsU0FBU2EsT0FBTztZQUM1QixJQUFJLEVBQUU2QixVQUFVQSxRQUFRLEVBQUVFLFFBQVFBLE1BQU0sRUFBRSxHQUFHSjtZQUM3QyxJQUFJTyxZQUFZQyxtQ0FBbUMxQjtZQUNuRCxJQUFJMkIsU0FBU0MsMENBQTBDSCxXQUFXO2dCQUM5REwsVUFBVUE7Z0JBQ1ZFLFFBQVFBO1lBQ1osR0FBR3RCO1lBQ0gyQixPQUFPRSxXQUFXLEdBQUc3QixLQUFLLENBQUNBLE1BQU1pQyxNQUFNLEdBQUcsRUFBRSxDQUFDQyxrQkFBa0I7WUFDL0QsSUFBSUMsZUFBZVIsT0FBT1EsWUFBWTtZQUN0QyxJQUFJQSxjQUFjSixtQ0FBbUNJLGNBQWM7WUFDbkUsT0FBT0E7UUFDWDtJQUNKO0FBQ0o7QUFDQSxNQUFNRywwQ0FBMEM7SUFDNUM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELE1BQU1DLG1EQUFtREQsd0NBQXdDRSxJQUFJLENBQUMscUJBQXFCO0FBQzNIRix3Q0FBd0M1QyxJQUFJLENBQUM7QUFDN0MsTUFBTStDLGtEQUFrREgsd0NBQXdDRSxJQUFJLENBQUM7QUFDckcsU0FBU2QsbUNBQW1DMUIsS0FBSztJQUM3QyxPQUFPQSxLQUFLLENBQUMsRUFBRSxDQUFDbEMsYUFBYTtBQUNqQztBQUNBLFNBQVM0RSx5Q0FBeUNoRSxRQUFRO0lBQ3RELElBQUlzQixRQUFRakIsMENBQTBDRSxXQUFXLENBQUNoQjtJQUNsRSxNQUFNK0IsU0FBU0EsTUFBTXRCLFFBQVEsS0FBS0EsU0FBUztRQUN2QyxJQUFJc0IsTUFBTTNCLE9BQU8sRUFBRSxPQUFPO1FBQzFCMkIsUUFBUUEsTUFBTWxCLE1BQU07SUFDeEI7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTYywwQ0FBMENsQixRQUFRLEVBQUVMLE9BQU87SUFDaEUsSUFBSXNFLGNBQWMsQ0FBQyxHQUFHNUgseUNBQVk7SUFDbEMsSUFBSTZILE1BQU0sQ0FBQyxHQUFHN0gseUNBQVk7SUFDekIsSUFBR2pCLDhEQUFxQixFQUFHO1FBQ3hCLElBQUlrRyxRQUFRdEIsU0FBU2EsT0FBTztRQUM1QixJQUFJLENBQUNsQixTQUFTO1lBQ1Ysc0dBQXNHO1lBQ3RHLElBQUl1RSxJQUFJckQsT0FBTyxFQUFFO2dCQUNic0QscUJBQXFCRCxJQUFJckQsT0FBTztnQkFDaENxRCxJQUFJckQsT0FBTyxHQUFHUTtZQUNsQjtZQUNBO1FBQ0o7UUFDQSxNQUFNdEQsZ0JBQWdCLENBQUMsR0FBR3pDLCtEQUFzQixFQUFHZ0csUUFBUUEsS0FBSyxDQUFDLEVBQUUsR0FBR0Q7UUFDdEUsdURBQXVEO1FBQ3ZELElBQUkrQyxZQUFZLENBQUNDO1lBQ2IsSUFBSUEsRUFBRUMsR0FBRyxLQUFLLFNBQVNELEVBQUVFLE1BQU0sSUFBSUYsRUFBRUcsT0FBTyxJQUFJSCxFQUFFSSxPQUFPLElBQUksQ0FBQ1QseUNBQXlDaEUsV0FBVztZQUNsSCxJQUFJMEUsaUJBQWlCM0csY0FBY0UsYUFBYTtZQUNoRCxJQUFJcUQsUUFBUXRCLFNBQVNhLE9BQU87WUFDNUIsSUFBSSxDQUFDUyxTQUFTLENBQUNDLHVDQUF1Q21ELGdCQUFnQnBELFFBQVE7WUFDOUUsSUFBSXlCLFlBQVlDLG1DQUFtQzFCO1lBQ25ELElBQUkyQixTQUFTQywwQ0FBMENILFdBQVc7Z0JBQzlETCxVQUFVO1lBQ2QsR0FBR3BCO1lBQ0gsSUFBSSxDQUFDb0QsZ0JBQWdCO1lBQ3JCekIsT0FBT0UsV0FBVyxHQUFHdUI7WUFDckIsSUFBSUMsY0FBY04sRUFBRU8sUUFBUSxHQUFHM0IsT0FBT1EsWUFBWSxLQUFLUixPQUFPRyxRQUFRO1lBQ3RFLElBQUksQ0FBQ3VCLGFBQWE7Z0JBQ2QxQixPQUFPRSxXQUFXLEdBQUdrQixFQUFFTyxRQUFRLEdBQUd0RCxLQUFLLENBQUNBLE1BQU1pQyxNQUFNLEdBQUcsRUFBRSxDQUFDQyxrQkFBa0IsR0FBR2xDLEtBQUssQ0FBQyxFQUFFLENBQUN3QixzQkFBc0I7Z0JBQzlHNkIsY0FBY04sRUFBRU8sUUFBUSxHQUFHM0IsT0FBT1EsWUFBWSxLQUFLUixPQUFPRyxRQUFRO1lBQ3RFO1lBQ0FpQixFQUFFUSxjQUFjO1lBQ2hCLElBQUlGLGFBQWF0QixtQ0FBbUNzQixhQUFhO1FBQ3JFO1FBQ0EsSUFBSUcsVUFBVSxDQUFDVDtZQUNYLG1HQUFtRztZQUNuRyxnRUFBZ0U7WUFDaEUsSUFBSSxDQUFDLENBQUM5RSxxQ0FBcUNpQixzQ0FBc0NqQixtQ0FBbUNTLFNBQVEsS0FBTXVCLHVDQUF1QzhDLEVBQUVVLE1BQU0sRUFBRS9FLFNBQVNhLE9BQU8sR0FBRztnQkFDbE10QixvQ0FBb0NTO2dCQUNwQ2lFLFlBQVlwRCxPQUFPLEdBQUd3RCxFQUFFVSxNQUFNO1lBQ2xDLE9BQU8sSUFBSWYseUNBQXlDaEUsYUFBYSxDQUFDZ0YsNENBQTRDWCxFQUFFVSxNQUFNLEVBQUUvRSxXQUFXO2dCQUMvSCwrRkFBK0Y7Z0JBQy9GLGtHQUFrRztnQkFDbEcsSUFBSWlFLFlBQVlwRCxPQUFPLEVBQUVvRCxZQUFZcEQsT0FBTyxDQUFDb0UsS0FBSztxQkFDN0MsSUFBSTFGLHFDQUFxQ0Esa0NBQWtDc0IsT0FBTyxFQUFFcUUsd0NBQXdDM0Ysa0NBQWtDc0IsT0FBTztZQUM5SyxPQUFPLElBQUltRCx5Q0FBeUNoRSxXQUFXaUUsWUFBWXBELE9BQU8sR0FBR3dELEVBQUVVLE1BQU07UUFDakc7UUFDQSxJQUFJSSxTQUFTLENBQUNkO1lBQ1YsdUVBQXVFO1lBQ3ZFLElBQUlILElBQUlyRCxPQUFPLEVBQUVzRCxxQkFBcUJELElBQUlyRCxPQUFPO1lBQ2pEcUQsSUFBSXJELE9BQU8sR0FBR3VFLHNCQUFzQjtnQkFDaEMsbUdBQW1HO2dCQUNuRyxJQUFJckgsY0FBY0UsYUFBYSxJQUFJK0YseUNBQXlDaEUsYUFBYSxDQUFDZ0YsNENBQTRDakgsY0FBY0UsYUFBYSxFQUFFK0IsV0FBVztvQkFDMUtULG9DQUFvQ1M7b0JBQ3BDLElBQUlqQyxjQUFjc0gsSUFBSSxDQUFDQyxRQUFRLENBQUNqQixFQUFFVSxNQUFNLEdBQUc7d0JBQ3ZDLElBQUlRO3dCQUNKdEIsWUFBWXBELE9BQU8sR0FBR3dELEVBQUVVLE1BQU07d0JBQzdCUSxDQUFBQSx1QkFBdUJ0QixZQUFZcEQsT0FBTyxNQUFNLFFBQVEwRSx5QkFBeUIsS0FBSyxJQUFJLEtBQUssSUFBSUEscUJBQXFCTixLQUFLO29CQUNsSSxPQUFPLElBQUkxRixrQ0FBa0NzQixPQUFPLEVBQUVxRSx3Q0FBd0MzRixrQ0FBa0NzQixPQUFPO2dCQUMzSTtZQUNKO1FBQ0o7UUFDQTlDLGNBQWN5SCxnQkFBZ0IsQ0FBQyxXQUFXcEIsV0FBVztRQUNyRHJHLGNBQWN5SCxnQkFBZ0IsQ0FBQyxXQUFXVixTQUFTO1FBQ25EeEQsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1tRSxPQUFPLENBQUMsQ0FBQzNILFVBQVVBLFFBQVEwSCxnQkFBZ0IsQ0FBQyxXQUFXVixTQUFTO1FBQ3BIeEQsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1tRSxPQUFPLENBQUMsQ0FBQzNILFVBQVVBLFFBQVEwSCxnQkFBZ0IsQ0FBQyxZQUFZTCxRQUFRO1FBQ3BILE9BQU87WUFDSHBILGNBQWMySCxtQkFBbUIsQ0FBQyxXQUFXdEIsV0FBVztZQUN4RHJHLGNBQWMySCxtQkFBbUIsQ0FBQyxXQUFXWixTQUFTO1lBQ3REeEQsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1tRSxPQUFPLENBQUMsQ0FBQzNILFVBQVVBLFFBQVE0SCxtQkFBbUIsQ0FBQyxXQUFXWixTQUFTO1lBQ3ZIeEQsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1tRSxPQUFPLENBQUMsQ0FBQzNILFVBQVVBLFFBQVE0SCxtQkFBbUIsQ0FBQyxZQUFZUCxRQUFRO1FBQzNIO0lBQ0osR0FBRztRQUNDbkY7UUFDQUw7S0FDSDtJQUNELHVGQUF1RjtJQUN2Riw0Q0FBNEM7SUFDM0MsSUFBR3ZFLDhEQUFxQixFQUFHO1FBQ3hCLE9BQU87WUFDSCxJQUFJOEksSUFBSXJELE9BQU8sRUFBRXNELHFCQUFxQkQsSUFBSXJELE9BQU87UUFDckQ7SUFDSixHQUFHO1FBQ0NxRDtLQUNIO0FBQ0w7QUFDQSxTQUFTeUIsMENBQTBDN0gsT0FBTztJQUN0RCxPQUFPa0gsNENBQTRDbEg7QUFDdkQ7QUFDQSxTQUFTeUQsdUNBQXVDekQsT0FBTyxFQUFFd0QsS0FBSztJQUMxRCxJQUFJLENBQUN4RCxTQUFTLE9BQU87SUFDckIsSUFBSSxDQUFDd0QsT0FBTyxPQUFPO0lBQ25CLE9BQU9BLE1BQU1zRSxJQUFJLENBQUMsQ0FBQzFGLE9BQU9BLEtBQUtvRixRQUFRLENBQUN4SDtBQUM1QztBQUNBLFNBQVNrSCw0Q0FBNENsSCxPQUFPLEVBQUV3RCxRQUFRLElBQUk7SUFDdEUsK0ZBQStGO0lBQy9GLElBQUl4RCxtQkFBbUIrSCxXQUFXL0gsUUFBUWdJLE9BQU8sQ0FBQyxnQ0FBZ0MsT0FBTztJQUN6RixvRkFBb0Y7SUFDcEYsOENBQThDO0lBQzlDLEtBQUssSUFBSSxFQUFFOUYsVUFBVStGLENBQUMsRUFBRSxJQUFJMUYsMENBQTBDbUIsUUFBUSxDQUFDbkIsMENBQTBDRSxXQUFXLENBQUNlLFFBQVE7UUFDekksSUFBSXlFLEtBQUt4RSx1Q0FBdUN6RCxTQUFTaUksRUFBRWxGLE9BQU8sR0FBRyxPQUFPO0lBQ2hGO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBU21GLDBDQUEwQ2xJLE9BQU87SUFDdEQsT0FBT2tILDRDQUE0Q2xILFNBQVN5QjtBQUNoRTtBQUNBLFNBQVNpQixzQ0FBc0N5RixRQUFRLEVBQUUzRSxLQUFLO0lBQzFELElBQUlJO0lBQ0osSUFBSXRCLFNBQVMsQ0FBQ3NCLDhCQUE4QnJCLDBDQUEwQ0UsV0FBVyxDQUFDZSxNQUFLLE1BQU8sUUFBUUksZ0NBQWdDLEtBQUssSUFBSSxLQUFLLElBQUlBLDRCQUE0QnRCLE1BQU07SUFDMU0sTUFBTUEsT0FBTztRQUNULElBQUlBLE9BQU9KLFFBQVEsS0FBS2lHLFVBQVUsT0FBTztRQUN6QzdGLFNBQVNBLE9BQU9BLE1BQU07SUFDMUI7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTaUQsbUNBQW1DdkYsT0FBTyxFQUFFb0ksU0FBUyxLQUFLO0lBQy9ELElBQUlwSSxXQUFXLFFBQVEsQ0FBQ29JLFFBQVEsSUFBSTtRQUMvQixJQUFHckkseUNBQXdDLEVBQUdDO0lBQ25ELEVBQUUsT0FBT3FJLEtBQUs7SUFDZCxTQUFTO0lBQ1Q7U0FDSyxJQUFJckksV0FBVyxNQUFNLElBQUk7UUFDMUJBLFFBQVFtSCxLQUFLO0lBQ2pCLEVBQUUsT0FBT2tCLEtBQUs7SUFDZCxTQUFTO0lBQ1Q7QUFDSjtBQUNBLFNBQVNqQix3Q0FBd0M1RCxLQUFLLEVBQUVvQixXQUFXLElBQUk7SUFDbkUsSUFBSUcsV0FBV3ZCLEtBQUssQ0FBQyxFQUFFLENBQUN3QixzQkFBc0I7SUFDOUMsSUFBSUMsWUFBWUMsbUNBQW1DMUI7SUFDbkQsSUFBSTJCLFNBQVNDLDBDQUEwQ0gsV0FBVztRQUM5REwsVUFBVUE7SUFDZCxHQUFHcEI7SUFDSDJCLE9BQU9FLFdBQVcsR0FBR047SUFDckIsSUFBSU8sV0FBV0gsT0FBT0csUUFBUTtJQUM5QixxRkFBcUY7SUFDckYsSUFBSVYsWUFBWSxDQUFDVSxVQUFVO1FBQ3ZCTCxZQUFZQyxtQ0FBbUMxQjtRQUMvQzJCLFNBQVNDLDBDQUEwQ0gsV0FBVztZQUMxREwsVUFBVTtRQUNkLEdBQUdwQjtRQUNIMkIsT0FBT0UsV0FBVyxHQUFHTjtRQUNyQk8sV0FBV0gsT0FBT0csUUFBUTtJQUM5QjtJQUNBQyxtQ0FBbUNEO0FBQ3ZDO0FBQ0EsU0FBU2hDLG1DQUFtQ3BCLFFBQVEsRUFBRUgsU0FBUztJQUMzRCxNQUFNdUcsZUFBZSxDQUFDLEdBQUdqSyxrQ0FBVyxFQUFHQyxNQUFNLENBQUN5RDtJQUM3QyxJQUFHbEQsNENBQWUsRUFBRztRQUNsQixJQUFJeUosYUFBYXZGLE9BQU8sRUFBRTtZQUN0QnRCLG9DQUFvQ1M7WUFDcEMsTUFBTWpDLGdCQUFnQixDQUFDLEdBQUd6QywrREFBc0IsRUFBRzBFLFNBQVNhLE9BQU8sR0FBR2IsU0FBU2EsT0FBTyxDQUFDLEVBQUUsR0FBR1E7WUFDNUYsSUFBSSxDQUFDRSx1Q0FBdUN4RCxjQUFjRSxhQUFhLEVBQUVzQixrQ0FBa0NzQixPQUFPLEtBQUtiLFNBQVNhLE9BQU8sRUFBRXFFLHdDQUF3Q2xGLFNBQVNhLE9BQU87UUFDck07UUFDQXVGLGFBQWF2RixPQUFPLEdBQUc7SUFDM0IsR0FBRztRQUNDYjtLQUNIO0FBQ0w7QUFDQSxTQUFTaUIsNENBQTRDakIsUUFBUSxFQUFFcUcsT0FBTyxFQUFFMUcsT0FBTztJQUMzRSx1RUFBdUU7SUFDdkUsaUZBQWlGO0lBQ2hGLElBQUd2RSw4REFBcUIsRUFBRztRQUN4QixJQUFJaUwsV0FBVzFHLFNBQVM7UUFDeEIsSUFBSTJCLFFBQVF0QixTQUFTYSxPQUFPO1FBQzVCLE1BQU05QyxnQkFBZ0IsQ0FBQyxHQUFHekMsK0RBQXNCLEVBQUdnRyxRQUFRQSxLQUFLLENBQUMsRUFBRSxHQUFHRDtRQUN0RSxJQUFJeUQsVUFBVSxDQUFDVDtZQUNYLElBQUlVLFNBQVNWLEVBQUVVLE1BQU07WUFDckIsSUFBSXhELHVDQUF1Q3dELFFBQVEvRSxTQUFTYSxPQUFPLEdBQUd0QixvQ0FBb0NTO2lCQUNyRyxJQUFJLENBQUMyRiwwQ0FBMENaLFNBQVN4RixvQ0FBb0M7UUFDckc7UUFDQXhCLGNBQWN5SCxnQkFBZ0IsQ0FBQyxXQUFXVixTQUFTO1FBQ25EeEQsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1tRSxPQUFPLENBQUMsQ0FBQzNILFVBQVVBLFFBQVEwSCxnQkFBZ0IsQ0FBQyxXQUFXVixTQUFTO1FBQ3BILE9BQU87WUFDSC9HLGNBQWMySCxtQkFBbUIsQ0FBQyxXQUFXWixTQUFTO1lBQ3REeEQsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1tRSxPQUFPLENBQUMsQ0FBQzNILFVBQVVBLFFBQVE0SCxtQkFBbUIsQ0FBQyxXQUFXWixTQUFTO1FBQzNIO0lBQ0osR0FBRztRQUNDOUU7UUFDQXFHO1FBQ0ExRztLQUNIO0FBQ0w7QUFDQSxTQUFTMkcseUNBQXlDdEcsUUFBUTtJQUN0RCxJQUFJc0IsUUFBUWpCLDBDQUEwQ0UsV0FBVyxDQUFDaEI7SUFDbEUsTUFBTStCLFNBQVNBLE1BQU10QixRQUFRLEtBQUtBLFNBQVM7UUFDdkMsSUFBSXNCLE1BQU1pRixhQUFhLEVBQUUsT0FBTztRQUNoQ2pGLFFBQVFBLE1BQU1sQixNQUFNO0lBQ3hCO0lBQ0EsT0FBTyxDQUFDa0IsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU10QixRQUFRLE1BQU1BO0FBQzlFO0FBQ0EsU0FBU21CLHNDQUFzQ25CLFFBQVEsRUFBRUosWUFBWSxFQUFFRCxPQUFPO0lBQzFFLGtJQUFrSTtJQUNsSSxpREFBaUQ7SUFDakQsTUFBTTZHLG1CQUFtQixDQUFDLEdBQUduSyx5Q0FBWSxFQUFHLE9BQU9vSyxhQUFhLGNBQWMsQ0FBQyxHQUFHbkwsK0RBQXNCLEVBQUcwRSxTQUFTYSxPQUFPLEdBQUdiLFNBQVNhLE9BQU8sQ0FBQyxFQUFFLEdBQUdRLFdBQVdwRCxhQUFhLEdBQUc7SUFDL0ssNElBQTRJO0lBQzVJLHlHQUF5RztJQUN4RyxJQUFHN0MsOERBQXFCLEVBQUc7UUFDeEIsSUFBSWtHLFFBQVF0QixTQUFTYSxPQUFPO1FBQzVCLE1BQU05QyxnQkFBZ0IsQ0FBQyxHQUFHekMsK0RBQXNCLEVBQUdnRyxRQUFRQSxLQUFLLENBQUMsRUFBRSxHQUFHRDtRQUN0RSxJQUFJLENBQUN6QixnQkFBZ0JELFNBQVM7UUFDOUIsSUFBSW1GLFVBQVU7WUFDVixtR0FBbUc7WUFDbkcsZ0VBQWdFO1lBQ2hFLElBQUksQ0FBQyxDQUFDdkYscUNBQXFDaUIsc0NBQXNDakIsbUNBQW1DUyxTQUFRLEtBQU11Qix1Q0FBdUN4RCxjQUFjRSxhQUFhLEVBQUUrQixTQUFTYSxPQUFPLEdBQUd0QixvQ0FBb0NTO1FBQ2pRO1FBQ0FqQyxjQUFjeUgsZ0JBQWdCLENBQUMsV0FBV1YsU0FBUztRQUNuRHhELFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNbUUsT0FBTyxDQUFDLENBQUMzSCxVQUFVQSxRQUFRMEgsZ0JBQWdCLENBQUMsV0FBV1YsU0FBUztRQUNwSCxPQUFPO1lBQ0gvRyxjQUFjMkgsbUJBQW1CLENBQUMsV0FBV1osU0FBUztZQUN0RHhELFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNbUUsT0FBTyxDQUFDLENBQUMzSCxVQUFVQSxRQUFRNEgsbUJBQW1CLENBQUMsV0FBV1osU0FBUztRQUMzSDtJQUNKLHVEQUF1RDtJQUN2RCxHQUFHO1FBQ0M5RTtRQUNBTDtLQUNIO0lBQ0EsSUFBR3ZFLDhEQUFxQixFQUFHO1FBQ3hCLE1BQU0yQyxnQkFBZ0IsQ0FBQyxHQUFHekMsK0RBQXNCLEVBQUcwRSxTQUFTYSxPQUFPLEdBQUdiLFNBQVNhLE9BQU8sQ0FBQyxFQUFFLEdBQUdRO1FBQzVGLElBQUksQ0FBQ3pCLGNBQWM7UUFDbkIsK0VBQStFO1FBQy9FLCtFQUErRTtRQUMvRSw4RUFBOEU7UUFDOUUsOEJBQThCO1FBQzlCLElBQUl3RSxZQUFZLENBQUNDO1lBQ2IsSUFBSUEsRUFBRUMsR0FBRyxLQUFLLFNBQVNELEVBQUVFLE1BQU0sSUFBSUYsRUFBRUcsT0FBTyxJQUFJSCxFQUFFSSxPQUFPLElBQUksQ0FBQ1QseUNBQXlDaEUsV0FBVztZQUNsSCxJQUFJMEUsaUJBQWlCM0csY0FBY0UsYUFBYTtZQUNoRCxJQUFJLENBQUNzRCx1Q0FBdUNtRCxnQkFBZ0IxRSxTQUFTYSxPQUFPLEdBQUc7WUFDL0UsSUFBSTZGLFdBQVdyRywwQ0FBMENFLFdBQVcsQ0FBQ1A7WUFDckUsSUFBSSxDQUFDMEcsVUFBVTtZQUNmLElBQUlILGdCQUFnQkcsU0FBU0gsYUFBYTtZQUMxQyw4REFBOEQ7WUFDOUQsSUFBSXRELFNBQVNDLDBDQUEwQ25GLGNBQWNzSCxJQUFJLEVBQUU7Z0JBQ3ZFM0MsVUFBVTtZQUNkO1lBQ0EscUVBQXFFO1lBQ3JFTyxPQUFPRSxXQUFXLEdBQUd1QjtZQUNyQixJQUFJQyxjQUFjTixFQUFFTyxRQUFRLEdBQUczQixPQUFPUSxZQUFZLEtBQUtSLE9BQU9HLFFBQVE7WUFDdEUsSUFBSSxDQUFDbUQsaUJBQWlCLENBQUN4SSxjQUFjc0gsSUFBSSxDQUFDQyxRQUFRLENBQUNpQixrQkFBa0JBLGtCQUFrQnhJLGNBQWNzSCxJQUFJLEVBQUU7Z0JBQ3ZHa0IsZ0JBQWdCbEY7Z0JBQ2hCcUYsU0FBU0gsYUFBYSxHQUFHbEY7WUFDN0I7WUFDQSxxRkFBcUY7WUFDckYscURBQXFEO1lBQ3JELElBQUksQ0FBQyxDQUFDc0QsZUFBZSxDQUFDcEQsdUNBQXVDb0QsYUFBYTNFLFNBQVNhLE9BQU8sTUFBTTBGLGVBQWU7Z0JBQzNHdEQsT0FBT0UsV0FBVyxHQUFHb0Q7Z0JBQ3JCLGtHQUFrRztnQkFDbEcsR0FBRzVCLGNBQWNOLEVBQUVPLFFBQVEsR0FBRzNCLE9BQU9RLFlBQVksS0FBS1IsT0FBT0csUUFBUTt1QkFDOUQ3Qix1Q0FBdUNvRCxhQUFhM0UsU0FBU2EsT0FBTyxHQUFHO2dCQUM5RXdELEVBQUVRLGNBQWM7Z0JBQ2hCUixFQUFFc0MsZUFBZTtnQkFDakIsSUFBSWhDLGFBQWF0QixtQ0FBbUNzQixhQUFhO3FCQUVqRSwrQkFBK0I7Z0JBQy9CLDBJQUEwSTtnQkFDMUksSUFBSSxDQUFDZ0IsMENBQTBDWSxnQkFBZ0I3QixlQUFla0MsSUFBSTtxQkFDN0V2RCxtQ0FBbUNrRCxlQUFlO1lBQzNEO1FBQ0o7UUFDQSxJQUFJLENBQUM1RyxTQUFTNUIsY0FBY3lILGdCQUFnQixDQUFDLFdBQVdwQixXQUFXO1FBQ25FLE9BQU87WUFDSCxJQUFJLENBQUN6RSxTQUFTNUIsY0FBYzJILG1CQUFtQixDQUFDLFdBQVd0QixXQUFXO1FBQzFFO0lBQ0osR0FBRztRQUNDcEU7UUFDQUo7UUFDQUQ7S0FDSDtJQUNELCtHQUErRztJQUM5RyxJQUFHdkUsOERBQXFCLEVBQUc7UUFDeEIsTUFBTTJDLGdCQUFnQixDQUFDLEdBQUd6QywrREFBc0IsRUFBRzBFLFNBQVNhLE9BQU8sR0FBR2IsU0FBU2EsT0FBTyxDQUFDLEVBQUUsR0FBR1E7UUFDNUYsSUFBSSxDQUFDekIsY0FBYztRQUNuQixJQUFJOEcsV0FBV3JHLDBDQUEwQ0UsV0FBVyxDQUFDUDtRQUNyRSxJQUFJLENBQUMwRyxVQUFVO1FBQ2YsSUFBSUc7UUFDSkgsU0FBU0gsYUFBYSxHQUFHLENBQUNNLDRCQUE0QkwsaUJBQWlCM0YsT0FBTyxNQUFNLFFBQVFnRyw4QkFBOEIsS0FBSyxJQUFJQSw0QkFBNEJ4RjtRQUMvSixPQUFPO1lBQ0gsSUFBSXFGLFdBQVdyRywwQ0FBMENFLFdBQVcsQ0FBQ1A7WUFDckUsSUFBSSxDQUFDMEcsVUFBVTtZQUNmLElBQUlILGdCQUFnQkcsU0FBU0gsYUFBYTtZQUMxQyx3R0FBd0c7WUFDeEcsSUFBSTNHLGdCQUFnQjJHLGlCQUFpQix1REFBdUQ7WUFDM0ZoRixDQUFBQSx1Q0FBdUN4RCxjQUFjRSxhQUFhLEVBQUUrQixTQUFTYSxPQUFPLEtBQUs5QyxjQUFjRSxhQUFhLEtBQUtGLGNBQWNzSCxJQUFJLElBQUlpQix5Q0FBeUN0RyxTQUFRLEdBQUk7Z0JBQ2pNLDZHQUE2RztnQkFDN0csSUFBSThHLGFBQWF6RywwQ0FBMEMwRyxLQUFLO2dCQUNoRTNCLHNCQUFzQjtvQkFDbEIsMEhBQTBIO29CQUMxSCxJQUFJckgsY0FBY0UsYUFBYSxLQUFLRixjQUFjc0gsSUFBSSxFQUFFO3dCQUNwRCxvRkFBb0Y7d0JBQ3BGLElBQUlxQixXQUFXSSxXQUFXdkcsV0FBVyxDQUFDUDt3QkFDdEMsTUFBTTBHLFNBQVM7NEJBQ1gsSUFBSUEsU0FBU0gsYUFBYSxJQUFJRyxTQUFTSCxhQUFhLENBQUNySSxXQUFXLEVBQUU7Z0NBQzlEbUYsbUNBQW1DcUQsU0FBU0gsYUFBYTtnQ0FDekQ7NEJBQ0o7NEJBQ0FHLFdBQVdBLFNBQVN0RyxNQUFNO3dCQUM5Qjt3QkFDQSx3RUFBd0U7d0JBQ3hFLDRDQUE0Qzt3QkFDNUNzRyxXQUFXSSxXQUFXdkcsV0FBVyxDQUFDUDt3QkFDbEMsTUFBTTBHLFNBQVM7NEJBQ1gsSUFBSUEsU0FBUzFHLFFBQVEsSUFBSTBHLFNBQVMxRyxRQUFRLENBQUNhLE9BQU8sSUFBSVIsMENBQTBDRSxXQUFXLENBQUNtRyxTQUFTMUcsUUFBUSxHQUFHO2dDQUM1SGtGLHdDQUF3Q3dCLFNBQVMxRyxRQUFRLENBQUNhLE9BQU8sRUFBRTtnQ0FDbkU7NEJBQ0o7NEJBQ0E2RixXQUFXQSxTQUFTdEcsTUFBTTt3QkFDOUI7b0JBQ0o7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0osR0FBRztRQUNDSjtRQUNBSjtLQUNIO0FBQ0w7QUFDQSxTQUFTc0QsMENBQTBDNUMsSUFBSSxFQUFFa0MsSUFBSSxFQUFFbEIsS0FBSztJQUNoRSxJQUFJMEYsV0FBVyxDQUFDeEUsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtFLFFBQVEsSUFBSXFCLGtEQUFrREY7SUFDL0gsSUFBSVosU0FBUyxDQUFDLEdBQUczSCwrREFBc0IsRUFBR2dGLE1BQU0yRyxnQkFBZ0IsQ0FBQzNHLE1BQU00RyxXQUFXQyxZQUFZLEVBQUU7UUFDNUZDLFlBQVlsSCxJQUFJO1lBQ1osSUFBSW1IO1lBQ0osdUNBQXVDO1lBQ3ZDLElBQUk3RSxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFDNkUsYUFBYTdFLEtBQUtDLElBQUksTUFBTSxRQUFRNEUsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXL0IsUUFBUSxDQUFDcEYsT0FBTyxPQUFPZ0gsV0FBV0ksYUFBYTtZQUNoTCxJQUFJcEgsS0FBS3FILE9BQU8sQ0FBQ1AsYUFBYSxDQUFDLEdBQUc3SCx5Q0FBd0MsRUFBR2UsU0FBVSxFQUFDb0IsU0FBU0MsdUNBQXVDckIsTUFBTW9CLE1BQUssS0FBTyxFQUFFa0IsQ0FBQUEsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtJLE1BQU0sS0FBS0osS0FBS0ksTUFBTSxDQUFDMUMsS0FBSSxHQUFJLE9BQU9nSCxXQUFXTSxhQUFhO1lBQzNRLE9BQU9OLFdBQVdPLFdBQVc7UUFDakM7SUFDSjtJQUNBLElBQUlqRixTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS0MsSUFBSSxFQUFFUSxPQUFPRSxXQUFXLEdBQUdYLEtBQUtDLElBQUk7SUFDekYsT0FBT1E7QUFDWDtBQUNBLFNBQVN5RSx5Q0FBeUN0RixHQUFHLEVBQUV1RixpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RFLE9BQU87UUFDSHBGLFdBQVdDLE9BQU8sQ0FBQyxDQUFDO1lBQ2hCLElBQUlsQyxPQUFPOEIsSUFBSXZCLE9BQU87WUFDdEIsSUFBSSxDQUFDUCxNQUFNLE9BQU87WUFDbEIsSUFBSSxFQUFFbUMsTUFBTUEsSUFBSSxFQUFFQyxVQUFVQSxXQUFXaUYsZUFBZWpGLFFBQVEsRUFBRUMsTUFBTUEsT0FBT2dGLGVBQWVoRixJQUFJLEVBQUVDLFFBQVFBLFNBQVMrRSxlQUFlL0UsTUFBTSxFQUFFLEdBQUdKO1lBQzdJLElBQUl0QyxPQUFPdUMsUUFBUSxDQUFDLEdBQUduSCwrREFBc0IsRUFBR2dGLE1BQU1yQyxhQUFhO1lBQ25FLElBQUlnRixTQUFTQywwQ0FBMEM1QyxNQUFNO2dCQUN6RG9DLFVBQVVBO2dCQUNWRSxRQUFRQTtZQUNaO1lBQ0EsSUFBSXRDLEtBQUtnRixRQUFRLENBQUNwRixPQUFPK0MsT0FBT0UsV0FBVyxHQUFHakQ7WUFDOUMsSUFBSWtELFdBQVdILE9BQU9HLFFBQVE7WUFDOUIsSUFBSSxDQUFDQSxZQUFZVCxNQUFNO2dCQUNuQk0sT0FBT0UsV0FBVyxHQUFHN0M7Z0JBQ3JCOEMsV0FBV0gsT0FBT0csUUFBUTtZQUM5QjtZQUNBLElBQUlBLFVBQVVDLG1DQUFtQ0QsVUFBVTtZQUMzRCxPQUFPQTtRQUNYO1FBQ0FFLGVBQWVkLE9BQU9tRixjQUFjO1lBQ2hDLElBQUlySCxPQUFPOEIsSUFBSXZCLE9BQU87WUFDdEIsSUFBSSxDQUFDUCxNQUFNLE9BQU87WUFDbEIsSUFBSSxFQUFFbUMsTUFBTUEsSUFBSSxFQUFFQyxVQUFVQSxXQUFXaUYsZUFBZWpGLFFBQVEsRUFBRUMsTUFBTUEsT0FBT2dGLGVBQWVoRixJQUFJLEVBQUVDLFFBQVFBLFNBQVMrRSxlQUFlL0UsTUFBTSxFQUFFLEdBQUdKO1lBQzdJLElBQUl0QyxPQUFPdUMsUUFBUSxDQUFDLEdBQUduSCwrREFBc0IsRUFBR2dGLE1BQU1yQyxhQUFhO1lBQ25FLElBQUlnRixTQUFTQywwQ0FBMEM1QyxNQUFNO2dCQUN6RG9DLFVBQVVBO2dCQUNWRSxRQUFRQTtZQUNaO1lBQ0EsSUFBSXRDLEtBQUtnRixRQUFRLENBQUNwRixPQUFPK0MsT0FBT0UsV0FBVyxHQUFHakQ7aUJBQ3pDO2dCQUNELElBQUkwSCxPQUFPQywyQkFBMkI1RTtnQkFDdEMsSUFBSTJFLE1BQU12RSxtQ0FBbUN1RSxNQUFNO2dCQUNuRCxPQUFPQSxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJQSxPQUFPO1lBQ3JEO1lBQ0EsSUFBSW5FLGVBQWVSLE9BQU9RLFlBQVk7WUFDdEMsSUFBSSxDQUFDQSxnQkFBZ0JkLE1BQU07Z0JBQ3ZCTSxPQUFPRSxXQUFXLEdBQUc3QztnQkFDckIsSUFBSXdILFdBQVdELDJCQUEyQjVFO2dCQUMxQyxJQUFJLENBQUM2RSxVQUNMLE9BQU87Z0JBQ1ByRSxlQUFlcUU7WUFDbkI7WUFDQSxJQUFJckUsY0FBY0osbUNBQW1DSSxjQUFjO1lBQ25FLE9BQU9BLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJQSxlQUFlO1FBQzdFO1FBQ0FDLFlBQVlsQixPQUFPbUYsY0FBYztZQUM3QixJQUFJckgsT0FBTzhCLElBQUl2QixPQUFPO1lBQ3RCLElBQUksQ0FBQ1AsTUFBTSxPQUFPO1lBQ2xCLElBQUksRUFBRW9DLFVBQVVBLFdBQVdpRixlQUFlakYsUUFBUSxFQUFFRSxRQUFRQSxTQUFTK0UsZUFBZS9FLE1BQU0sRUFBRSxHQUFHSjtZQUMvRixJQUFJUyxTQUFTQywwQ0FBMEM1QyxNQUFNO2dCQUN6RG9DLFVBQVVBO2dCQUNWRSxRQUFRQTtZQUNaO1lBQ0EsSUFBSVEsV0FBV0gsT0FBT0csUUFBUTtZQUM5QixJQUFJQSxVQUFVQyxtQ0FBbUNELFVBQVU7WUFDM0QsT0FBT0E7UUFDWDtRQUNBTyxXQUFXbkIsT0FBT21GLGNBQWM7WUFDNUIsSUFBSXJILE9BQU84QixJQUFJdkIsT0FBTztZQUN0QixJQUFJLENBQUNQLE1BQU0sT0FBTztZQUNsQixJQUFJLEVBQUVvQyxVQUFVQSxXQUFXaUYsZUFBZWpGLFFBQVEsRUFBRUUsUUFBUUEsU0FBUytFLGVBQWUvRSxNQUFNLEVBQUUsR0FBR0o7WUFDL0YsSUFBSVMsU0FBU0MsMENBQTBDNUMsTUFBTTtnQkFDekRvQyxVQUFVQTtnQkFDVkUsUUFBUUE7WUFDWjtZQUNBLElBQUlnRixPQUFPQywyQkFBMkI1RTtZQUN0QyxJQUFJMkUsTUFBTXZFLG1DQUFtQ3VFLE1BQU07WUFDbkQsT0FBT0EsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSUEsT0FBTztRQUNyRDtJQUNKO0FBQ0o7QUFDQSxTQUFTQywyQkFBMkI1RSxNQUFNO0lBQ3RDLElBQUkyRSxPQUFPdkc7SUFDWCxJQUFJMEc7SUFDSixHQUFHO1FBQ0NBLE9BQU85RSxPQUFPK0UsU0FBUztRQUN2QixJQUFJRCxNQUFNSCxPQUFPRztJQUNyQixRQUFRQSxNQUFNO0lBQ2QsT0FBT0g7QUFDWDtBQUNBLE1BQU1LO0lBQ0YsSUFBSUMsT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDQyxPQUFPLENBQUNELElBQUk7SUFDNUI7SUFDQTNILFlBQVk2SCxJQUFJLEVBQUU7UUFDZCxPQUFPLElBQUksQ0FBQ0QsT0FBTyxDQUFDRSxHQUFHLENBQUNEO0lBQzVCO0lBQ0FFLFlBQVl0SSxRQUFRLEVBQUVJLE1BQU0sRUFBRW1HLGFBQWEsRUFBRTtRQUN6QyxJQUFJdEcsYUFBYSxJQUFJLENBQUNrSSxPQUFPLENBQUNFLEdBQUcsQ0FBQ2pJLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUlBLFNBQVM7UUFDbEYsSUFBSSxDQUFDSCxZQUFZO1FBQ2pCLElBQUlDLE9BQU8sSUFBSUMsK0JBQStCO1lBQzFDSCxVQUFVQTtRQUNkO1FBQ0FDLFdBQVdTLFFBQVEsQ0FBQ1I7UUFDcEJBLEtBQUtFLE1BQU0sR0FBR0g7UUFDZCxJQUFJLENBQUNrSSxPQUFPLENBQUNJLEdBQUcsQ0FBQ3ZJLFVBQVVFO1FBQzNCLElBQUlxRyxlQUFlckcsS0FBS3FHLGFBQWEsR0FBR0E7SUFDNUM7SUFDQTVGLFFBQVFULElBQUksRUFBRTtRQUNWLElBQUksQ0FBQ2lJLE9BQU8sQ0FBQ0ksR0FBRyxDQUFDckksS0FBS0YsUUFBUSxFQUFFRTtJQUNwQztJQUNBMkIsZUFBZTdCLFFBQVEsRUFBRTtRQUNyQix3QkFBd0I7UUFDeEIsSUFBSUEsYUFBYSxNQUFNO1FBQ3ZCLElBQUlFLE9BQU8sSUFBSSxDQUFDaUksT0FBTyxDQUFDRSxHQUFHLENBQUNySTtRQUM1QixJQUFJLENBQUNFLE1BQU07UUFDWCxJQUFJRCxhQUFhQyxLQUFLRSxNQUFNO1FBQzVCLCtIQUErSDtRQUMvSCw4RkFBOEY7UUFDOUYsS0FBSyxJQUFJUyxXQUFXLElBQUksQ0FBQ1csUUFBUSxHQUFHLElBQUlYLFlBQVlYLFFBQVFBLEtBQUtxRyxhQUFhLElBQUkxRixRQUFRMEYsYUFBYSxJQUFJckcsS0FBS0YsUUFBUSxJQUFJRSxLQUFLRixRQUFRLENBQUNhLE9BQU8sSUFBSVUsdUNBQXVDVixRQUFRMEYsYUFBYSxFQUFFckcsS0FBS0YsUUFBUSxDQUFDYSxPQUFPLEdBQUdBLFFBQVEwRixhQUFhLEdBQUdyRyxLQUFLcUcsYUFBYTtRQUNyUixJQUFJN0csV0FBV1EsS0FBS1IsUUFBUTtRQUM1QixJQUFJTyxZQUFZO1lBQ1pBLFdBQVd1SSxXQUFXLENBQUN0STtZQUN2QixJQUFJUixTQUFTd0ksSUFBSSxHQUFHLEdBQUd4SSxTQUFTK0YsT0FBTyxDQUFDLENBQUNnRCxRQUFReEksY0FBY0EsV0FBV1MsUUFBUSxDQUFDK0g7UUFDdkY7UUFDQSxJQUFJLENBQUNOLE9BQU8sQ0FBQ08sTUFBTSxDQUFDeEksS0FBS0YsUUFBUTtJQUNyQztJQUNBLHdCQUF3QjtJQUN4QixDQUFDd0IsU0FBU3RCLE9BQU8sSUFBSSxDQUFDSSxJQUFJLEVBQUU7UUFDeEIsSUFBSUosS0FBS0YsUUFBUSxJQUFJLE1BQU0sTUFBTUU7UUFDakMsSUFBSUEsS0FBS1IsUUFBUSxDQUFDd0ksSUFBSSxHQUFHLEdBQUcsS0FBSyxJQUFJTyxTQUFTdkksS0FBS1IsUUFBUSxDQUFDLE9BQU8sSUFBSSxDQUFDOEIsUUFBUSxDQUFDaUg7SUFDckY7SUFDQTFCLFFBQVE7UUFDSixJQUFJNEI7UUFDSixJQUFJQyxVQUFVLElBQUlYO1FBQ2xCLElBQUlZO1FBQ0osS0FBSyxJQUFJM0ksUUFBUSxJQUFJLENBQUNzQixRQUFRLEdBQUdvSCxRQUFRTixXQUFXLENBQUNwSSxLQUFLRixRQUFRLEVBQUUsQ0FBQzZJLHdCQUF3QixDQUFDRixlQUFlekksS0FBS0UsTUFBTSxNQUFNLFFBQVF1SSxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYTNJLFFBQVEsTUFBTSxRQUFRNkksMEJBQTBCLEtBQUssSUFBSUEsd0JBQXdCLE1BQU0zSSxLQUFLcUcsYUFBYTtRQUMvUixPQUFPcUM7SUFDWDtJQUNBRSxhQUFhO1FBQ1QsSUFBSSxDQUFDWCxPQUFPLEdBQUcsSUFBSVk7UUFDbkIsSUFBSSxDQUFDekksSUFBSSxHQUFHLElBQUlILCtCQUErQjtZQUMzQ0gsVUFBVTtRQUNkO1FBQ0EsSUFBSSxDQUFDbUksT0FBTyxDQUFDSSxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUNqSSxJQUFJO0lBQ3BDO0FBQ0o7QUFDQSxNQUFNSDtJQUNGTyxTQUFTUixJQUFJLEVBQUU7UUFDWCxJQUFJLENBQUNSLFFBQVEsQ0FBQ3NKLEdBQUcsQ0FBQzlJO1FBQ2xCQSxLQUFLRSxNQUFNLEdBQUcsSUFBSTtJQUN0QjtJQUNBb0ksWUFBWXRJLElBQUksRUFBRTtRQUNkLElBQUksQ0FBQ1IsUUFBUSxDQUFDZ0osTUFBTSxDQUFDeEk7UUFDckJBLEtBQUtFLE1BQU0sR0FBR2lCO0lBQ2xCO0lBQ0F5SCxZQUFZckosS0FBSyxDQUFDO1FBQ2QsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSXVKO1FBQ3BCLElBQUksQ0FBQ3RKLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0ssUUFBUSxHQUFHUCxNQUFNTyxRQUFRO0lBQ2xDO0FBQ0o7QUFDQSxJQUFJSyw0Q0FBNEMsSUFBSTRIO0FBR3BEOzs7Ozs7Ozs7O0NBVUMsR0FLRCxTQUFTaUIsMENBQTBDekosUUFBUSxDQUFDLENBQUM7SUFDekQsSUFBSSxFQUFFSSxXQUFXQSxZQUFZLEtBQUssRUFBRXNKLGFBQWFBLFdBQVcsRUFBRUMsUUFBUUEsTUFBTSxFQUFFLEdBQUczSjtJQUNqRixJQUFJNEosUUFBUSxDQUFDLEdBQUdoTix5Q0FBWSxFQUFHO1FBQzNCaU4sV0FBVztRQUNYcE0sZ0JBQWdCMkMsYUFBYSxDQUFDLEdBQUcxQyxvRUFBb0I7SUFDekQ7SUFDQSxJQUFJLENBQUNtTSxXQUFXQyxXQUFXLEdBQUcsQ0FBQyxHQUFHMU0sMkNBQWMsRUFBRztJQUNuRCxJQUFJLENBQUMyTSxxQkFBcUJDLGdCQUFnQixHQUFHLENBQUMsR0FBRzVNLDJDQUFjLEVBQUcsSUFBSXdNLE1BQU14SSxPQUFPLENBQUN5SSxTQUFTLElBQUlELE1BQU14SSxPQUFPLENBQUMzRCxjQUFjO0lBQzdILElBQUl3TSxjQUFjLENBQUMsR0FBRzNNLDhDQUFpQixFQUFHLElBQUkwTSxnQkFBZ0JKLE1BQU14SSxPQUFPLENBQUN5SSxTQUFTLElBQUlELE1BQU14SSxPQUFPLENBQUMzRCxjQUFjLEdBQUcsRUFBRTtJQUMxSCxJQUFJeU0sZ0JBQWdCLENBQUMsR0FBRzVNLDhDQUFpQixFQUFHLENBQUN1TTtRQUN6Q0QsTUFBTXhJLE9BQU8sQ0FBQ3lJLFNBQVMsR0FBR0E7UUFDMUJDLFdBQVdEO1FBQ1hJO0lBQ0osR0FBRztRQUNDQTtLQUNIO0lBQ0EsSUFBR3JNLDZFQUE2QixFQUFHLENBQUNIO1FBQ2pDbU0sTUFBTXhJLE9BQU8sQ0FBQzNELGNBQWMsR0FBR0E7UUFDL0J3TTtJQUNKLEdBQUcsRUFBRSxFQUFFO1FBQ0hQLGFBQWFBO0lBQ2pCO0lBQ0EsSUFBSSxFQUFFUyxZQUFZQSxVQUFVLEVBQUUsR0FBRyxDQUFDLEdBQUdyTSw4REFBYyxFQUFHO1FBQ2xEc00sWUFBWVQ7UUFDWk8sZUFBZUE7SUFDbkI7SUFDQSxJQUFJLEVBQUVHLGtCQUFrQkEsZ0JBQWdCLEVBQUUsR0FBRyxDQUFDLEdBQUdyTSxvRUFBb0IsRUFBRztRQUNwRW9NLFlBQVksQ0FBQ1Q7UUFDYlcscUJBQXFCSjtJQUN6QjtJQUNBLE9BQU87UUFDSEwsV0FBV0E7UUFDWHBNLGdCQUFnQnNNO1FBQ2hCSSxZQUFZUixTQUFTVSxtQkFBbUJGO0lBQzVDO0FBQ0o7QUFHQSxTQUFTSSwwQ0FBMEN2SyxLQUFLO0lBQ3BELElBQUksRUFBRUMsVUFBVUEsUUFBUSxFQUFFdUssWUFBWUEsVUFBVSxFQUFFQyxnQkFBZ0JBLGNBQWMsRUFBRSxHQUFHeks7SUFDckYsSUFBSSxFQUFFNkosV0FBV0EsU0FBUyxFQUFFcE0sZ0JBQWdCQSxjQUFjLEVBQUUwTSxZQUFZQSxVQUFVLEVBQUUsR0FBRyxDQUFDLEdBQUdWLHlDQUF3QyxFQUFHeko7SUFDdEksSUFBSWdKLFFBQVEsQ0FBQyxHQUFHdE0sa0NBQVcsRUFBR2dPLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDMUs7SUFDNUMsT0FBcUIsV0FBSCxHQUFJLElBQUd2RCxrQ0FBVyxFQUFHa08sWUFBWSxDQUFDNUIsT0FBTyxDQUFDLEdBQUczTSx5REFBZ0IsRUFBRzJNLE1BQU1oSixLQUFLLEVBQUU7UUFDM0YsR0FBR21LLFVBQVU7UUFDYlUsV0FBVyxDQUFDLEdBQUcxTSw0Q0FBVSxFQUFHO1lBQ3hCLENBQUNxTSxjQUFjLEdBQUcsRUFBRVg7WUFDcEIsQ0FBQ1ksa0JBQWtCLEdBQUcsRUFBRWhOO1FBQzVCO0lBQ0o7QUFDSjtBQUdBOzs7Ozs7Ozs7O0NBVUMsR0FJRCxJQUFJcU4seUNBQXVELFdBQUgsR0FBSSxJQUFHcE8sa0NBQVcsRUFBR21ELGFBQWEsQ0FBQztBQUMzRixTQUFTa0wsMENBQTBDcEksR0FBRztJQUNsRCxJQUFJcUksVUFBVSxDQUFDLEdBQUdsTyw2Q0FBZ0IsRUFBR2dPLDJDQUEyQyxDQUFDO0lBQ2hGLElBQUd2Tyx5REFBZ0IsRUFBR3lPLFNBQVNySTtJQUNoQywyQkFBMkI7SUFDM0IsSUFBSSxFQUFFQSxLQUFLc0ksQ0FBQyxFQUFFLEdBQUdDLFlBQVksR0FBR0Y7SUFDaEMsT0FBT0U7QUFDWDtBQUNBOztDQUVDLEdBQUcsU0FBU0Msd0NBQXdDbkwsS0FBSyxFQUFFMkMsR0FBRztJQUMzRCxJQUFJLEVBQUUxQyxVQUFVQSxRQUFRLEVBQUUsR0FBR2lMLFlBQVksR0FBR2xMO0lBQzVDLElBQUlvTCxTQUFTLENBQUMsR0FBRzNPLDJEQUFrQixFQUFHa0c7SUFDdEMsSUFBSXFJLFVBQVU7UUFDVixHQUFHRSxVQUFVO1FBQ2J2SSxLQUFLeUk7SUFDVDtJQUNBLE9BQXFCLFdBQUgsR0FBSSxJQUFHMU8sa0NBQVcsRUFBRzhGLGFBQWEsQ0FBQ3NJLHVDQUF1Q3JJLFFBQVEsRUFBRTtRQUNsR0YsT0FBT3lJO0lBQ1gsR0FBRy9LO0FBQ1A7QUFDQSxJQUFJb0wsMkNBQXlELFdBQUgsR0FBSSxJQUFHM08sa0NBQVcsRUFBRzRPLFVBQVUsQ0FBQ0g7QUFDMUYsU0FBU0ksMENBQTBDdkwsS0FBSyxFQUFFd0wsTUFBTTtJQUM1RCxJQUFJLEVBQUVyQixZQUFZQSxVQUFVLEVBQUUsR0FBRyxDQUFDLEdBQUdyTSw4REFBYyxFQUFHa0M7SUFDdEQsSUFBSSxFQUFFeUwsZUFBZUEsYUFBYSxFQUFFLEdBQUcsQ0FBQyxHQUFHdk4saUVBQWlCLEVBQUc4QjtJQUMvRCxJQUFJMEwsZUFBZSxDQUFDLEdBQUdyUCx5REFBZ0IsRUFBRzhOLFlBQVlzQjtJQUN0RCxJQUFJRSxXQUFXWiwwQ0FBMENTO0lBQ3pELElBQUlJLG1CQUFtQjVMLE1BQU1vSyxVQUFVLEdBQUcsQ0FBQyxJQUFJdUI7SUFDL0MsSUFBSWhGLGVBQWUsQ0FBQyxHQUFHL0oseUNBQVksRUFBR29ELE1BQU1JLFNBQVM7SUFDcEQsSUFBR2xELDRDQUFlLEVBQUc7UUFDbEIsSUFBSXlKLGFBQWF2RixPQUFPLElBQUlvSyxPQUFPcEssT0FBTyxFQUFFLENBQUMsR0FBR2hELHlDQUF3QyxFQUFHb04sT0FBT3BLLE9BQU87UUFDekd1RixhQUFhdkYsT0FBTyxHQUFHO0lBQzNCLEdBQUc7UUFDQ29LO0tBQ0g7SUFDRCxPQUFPO1FBQ0hLLGdCQUFnQixDQUFDLEdBQUd4UCx5REFBZ0IsRUFBRztZQUNuQyxHQUFHcVAsWUFBWTtZQUNmSSxVQUFVOUwsTUFBTStMLG1CQUFtQixJQUFJLENBQUMvTCxNQUFNb0ssVUFBVSxHQUFHLENBQUMsSUFBSXhJO1FBQ3BFLEdBQUdnSztJQUNQO0FBQ0o7QUFLQTs7Ozs7Ozs7OztDQVVDLEdBR0QsU0FBU0ksMENBQTBDckosR0FBRyxFQUFFc0osT0FBTztJQUMzRCxJQUFJN0IsYUFBYTZCLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRN0IsVUFBVTtJQUNyRixJQUFJLENBQUM4QixrQkFBa0JDLG9CQUFvQixHQUFHLENBQUMsR0FBRy9PLDJDQUFjLEVBQUc7SUFDbEUsSUFBR3pCLDhEQUFxQixFQUFHO1FBQ3hCLElBQUksQ0FBQ2dILFFBQVEsUUFBUUEsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJdkIsT0FBTyxLQUFLLENBQUNnSixZQUFZO1lBQ3hFLElBQUlnQyxTQUFTO2dCQUNULElBQUl6SixJQUFJdkIsT0FBTyxFQUFFO29CQUNiLElBQUlvQyxTQUFTLENBQUMsR0FBR0MseUNBQXdDLEVBQUdkLElBQUl2QixPQUFPLEVBQUU7d0JBQ3JFNkIsVUFBVTtvQkFDZDtvQkFDQWtKLG9CQUFvQixDQUFDLENBQUMzSSxPQUFPRyxRQUFRO2dCQUN6QztZQUNKO1lBQ0F5STtZQUNBLHFGQUFxRjtZQUNyRixJQUFJQyxXQUFXLElBQUlDLGlCQUFpQkY7WUFDcENDLFNBQVNFLE9BQU8sQ0FBQzVKLElBQUl2QixPQUFPLEVBQUU7Z0JBQzFCb0wsU0FBUztnQkFDVEMsV0FBVztnQkFDWEMsWUFBWTtnQkFDWkMsaUJBQWlCO29CQUNiO29CQUNBO2lCQUNIO1lBQ0w7WUFDQSxPQUFPO2dCQUNILHFGQUFxRjtnQkFDckYsd0ZBQXdGO2dCQUN4Riw0RkFBNEY7Z0JBQzVGLHlGQUF5RjtnQkFDekZOLFNBQVNPLFVBQVU7WUFDdkI7UUFDSjtJQUNKO0lBQ0EsT0FBT3hDLGFBQWEsUUFBUThCO0FBQ2hDO0FBS3lyQixDQUN6ckIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2Fyem9uZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS9mb2N1cy9kaXN0L2ltcG9ydC5tanM/OGQ4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUxheW91dEVmZmVjdCBhcyAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0LCBnZXRPd25lckRvY3VtZW50IGFzICQ2bmZGQyRnZXRPd25lckRvY3VtZW50LCBydW5BZnRlclRyYW5zaXRpb24gYXMgJDZuZkZDJHJ1bkFmdGVyVHJhbnNpdGlvbiwgZm9jdXNXaXRob3V0U2Nyb2xsaW5nIGFzICQ2bmZGQyRmb2N1c1dpdGhvdXRTY3JvbGxpbmcsIGdldE93bmVyV2luZG93IGFzICQ2bmZGQyRnZXRPd25lcldpbmRvdywgbWVyZ2VQcm9wcyBhcyAkNm5mRkMkbWVyZ2VQcm9wcywgdXNlU3luY1JlZiBhcyAkNm5mRkMkdXNlU3luY1JlZiwgdXNlT2JqZWN0UmVmIGFzICQ2bmZGQyR1c2VPYmplY3RSZWZ9IGZyb20gXCJAcmVhY3QtYXJpYS91dGlsc1wiO1xuaW1wb3J0ICQ2bmZGQyRyZWFjdCwge3VzZVJlZiBhcyAkNm5mRkMkdXNlUmVmLCB1c2VDb250ZXh0IGFzICQ2bmZGQyR1c2VDb250ZXh0LCB1c2VNZW1vIGFzICQ2bmZGQyR1c2VNZW1vLCB1c2VFZmZlY3QgYXMgJDZuZkZDJHVzZUVmZmVjdCwgdXNlU3RhdGUgYXMgJDZuZkZDJHVzZVN0YXRlLCB1c2VDYWxsYmFjayBhcyAkNm5mRkMkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtnZXRJbnRlcmFjdGlvbk1vZGFsaXR5IGFzICQ2bmZGQyRnZXRJbnRlcmFjdGlvbk1vZGFsaXR5LCBpc0ZvY3VzVmlzaWJsZSBhcyAkNm5mRkMkaXNGb2N1c1Zpc2libGUsIHVzZUZvY3VzVmlzaWJsZUxpc3RlbmVyIGFzICQ2bmZGQyR1c2VGb2N1c1Zpc2libGVMaXN0ZW5lciwgdXNlRm9jdXMgYXMgJDZuZkZDJHVzZUZvY3VzLCB1c2VGb2N1c1dpdGhpbiBhcyAkNm5mRkMkdXNlRm9jdXNXaXRoaW4sIHVzZUtleWJvYXJkIGFzICQ2bmZGQyR1c2VLZXlib2FyZH0gZnJvbSBcIkByZWFjdC1hcmlhL2ludGVyYWN0aW9uc1wiO1xuaW1wb3J0ICQ2bmZGQyRjbHN4IGZyb20gXCJjbHN4XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ2YTk5MTk1MzMyZWRlYzhiJGV4cG9ydCQ4MGYzZTE0N2Q3ODE1NzFjKGVsZW1lbnQpIHtcbiAgICAvLyBJZiB0aGUgdXNlciBpcyBpbnRlcmFjdGluZyB3aXRoIGEgdmlydHVhbCBjdXJzb3IsIGUuZy4gc2NyZWVuIHJlYWRlciwgdGhlblxuICAgIC8vIHdhaXQgdW50aWwgYWZ0ZXIgYW55IGFuaW1hdGVkIHRyYW5zaXRpb25zIHRoYXQgYXJlIGN1cnJlbnRseSBvY2N1cnJpbmcgb25cbiAgICAvLyB0aGUgcGFnZSBiZWZvcmUgc2hpZnRpbmcgZm9jdXMuIFRoaXMgYXZvaWRzIGlzc3VlcyB3aXRoIFZvaWNlT3ZlciBvbiBpT1NcbiAgICAvLyBjYXVzaW5nIHRoZSBwYWdlIHRvIHNjcm9sbCB3aGVuIG1vdmluZyBmb2N1cyBpZiB0aGUgZWxlbWVudCBpcyB0cmFuc2l0aW9uaW5nXG4gICAgLy8gZnJvbSBvZmYgdGhlIHNjcmVlbi5cbiAgICBjb25zdCBvd25lckRvY3VtZW50ID0gKDAsICQ2bmZGQyRnZXRPd25lckRvY3VtZW50KShlbGVtZW50KTtcbiAgICBpZiAoKDAsICQ2bmZGQyRnZXRJbnRlcmFjdGlvbk1vZGFsaXR5KSgpID09PSBcInZpcnR1YWxcIikge1xuICAgICAgICBsZXQgbGFzdEZvY3VzZWRFbGVtZW50ID0gb3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAoMCwgJDZuZkZDJHJ1bkFmdGVyVHJhbnNpdGlvbikoKCk9PntcbiAgICAgICAgICAgIC8vIElmIGZvY3VzIGRpZCBub3QgbW92ZSBhbmQgdGhlIGVsZW1lbnQgaXMgc3RpbGwgaW4gdGhlIGRvY3VtZW50LCBmb2N1cyBpdC5cbiAgICAgICAgICAgIGlmIChvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGxhc3RGb2N1c2VkRWxlbWVudCAmJiBlbGVtZW50LmlzQ29ubmVjdGVkKSAoMCwgJDZuZkZDJGZvY3VzV2l0aG91dFNjcm9sbGluZykoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSAoMCwgJDZuZkZDJGZvY3VzV2l0aG91dFNjcm9sbGluZykoZWxlbWVudCk7XG59XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNjQ1ZjJlNjdiODVhMjRjOSR2YXIkaXNTdHlsZVZpc2libGUoZWxlbWVudCkge1xuICAgIGNvbnN0IHdpbmRvd09iamVjdCA9ICgwLCAkNm5mRkMkZ2V0T3duZXJXaW5kb3cpKGVsZW1lbnQpO1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiB3aW5kb3dPYmplY3QuSFRNTEVsZW1lbnQpICYmICEoZWxlbWVudCBpbnN0YW5jZW9mIHdpbmRvd09iamVjdC5TVkdFbGVtZW50KSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGRpc3BsYXk6IGRpc3BsYXksIHZpc2liaWxpdHk6IHZpc2liaWxpdHkgfSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgbGV0IGlzVmlzaWJsZSA9IGRpc3BsYXkgIT09IFwibm9uZVwiICYmIHZpc2liaWxpdHkgIT09IFwiaGlkZGVuXCIgJiYgdmlzaWJpbGl0eSAhPT0gXCJjb2xsYXBzZVwiO1xuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgY29uc3QgeyBnZXRDb21wdXRlZFN0eWxlOiBnZXRDb21wdXRlZFN0eWxlIH0gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgIGxldCB7IGRpc3BsYXk6IGNvbXB1dGVkRGlzcGxheSwgdmlzaWJpbGl0eTogY29tcHV0ZWRWaXNpYmlsaXR5IH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICBpc1Zpc2libGUgPSBjb21wdXRlZERpc3BsYXkgIT09IFwibm9uZVwiICYmIGNvbXB1dGVkVmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIiAmJiBjb21wdXRlZFZpc2liaWxpdHkgIT09IFwiY29sbGFwc2VcIjtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmlzaWJsZTtcbn1cbmZ1bmN0aW9uICQ2NDVmMmU2N2I4NWEyNGM5JHZhciRpc0F0dHJpYnV0ZVZpc2libGUoZWxlbWVudCwgY2hpbGRFbGVtZW50KSB7XG4gICAgcmV0dXJuICFlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImhpZGRlblwiKSAmJiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJERVRBSUxTXCIgJiYgY2hpbGRFbGVtZW50ICYmIGNoaWxkRWxlbWVudC5ub2RlTmFtZSAhPT0gXCJTVU1NQVJZXCIgPyBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcIm9wZW5cIikgOiB0cnVlKTtcbn1cbmZ1bmN0aW9uICQ2NDVmMmU2N2I4NWEyNGM5JGV4cG9ydCRlOTg5YzBmZmZhYTZiMjdhKGVsZW1lbnQsIGNoaWxkRWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lICE9PSBcIiNjb21tZW50XCIgJiYgJDY0NWYyZTY3Yjg1YTI0YzkkdmFyJGlzU3R5bGVWaXNpYmxlKGVsZW1lbnQpICYmICQ2NDVmMmU2N2I4NWEyNGM5JHZhciRpc0F0dHJpYnV0ZVZpc2libGUoZWxlbWVudCwgY2hpbGRFbGVtZW50KSAmJiAoIWVsZW1lbnQucGFyZW50RWxlbWVudCB8fCAkNjQ1ZjJlNjdiODVhMjRjOSRleHBvcnQkZTk4OWMwZmZmYWE2YjI3YShlbGVtZW50LnBhcmVudEVsZW1lbnQsIGVsZW1lbnQpKTtcbn1cblxuXG5cbmNvbnN0ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRGb2N1c0NvbnRleHQgPSAvKiNfX1BVUkVfXyovICgwLCAkNm5mRkMkcmVhY3QpLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5sZXQgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gbnVsbDtcbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyMGU0MDI4OTY0MWZiYmI2KHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBjb250YWluOiBjb250YWluLCByZXN0b3JlRm9jdXM6IHJlc3RvcmVGb2N1cywgYXV0b0ZvY3VzOiBhdXRvRm9jdXMgfSA9IHByb3BzO1xuICAgIGxldCBzdGFydFJlZiA9ICgwLCAkNm5mRkMkdXNlUmVmKShudWxsKTtcbiAgICBsZXQgZW5kUmVmID0gKDAsICQ2bmZGQyR1c2VSZWYpKG51bGwpO1xuICAgIGxldCBzY29wZVJlZiA9ICgwLCAkNm5mRkMkdXNlUmVmKShbXSk7XG4gICAgbGV0IHsgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSB9ID0gKDAsICQ2bmZGQyR1c2VDb250ZXh0KSgkOWJmNzFlYTI4NzkzZTczOCR2YXIkRm9jdXNDb250ZXh0KSB8fCB7fTtcbiAgICAvLyBDcmVhdGUgYSB0cmVlIG5vZGUgaGVyZSBzbyB3ZSBjYW4gYWRkIGNoaWxkcmVuIHRvIGl0IGV2ZW4gYmVmb3JlIGl0IGlzIGFkZGVkIHRvIHRoZSB0cmVlLlxuICAgIGxldCBub2RlID0gKDAsICQ2bmZGQyR1c2VNZW1vKSgoKT0+bmV3ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRUcmVlTm9kZSh7XG4gICAgICAgICAgICBzY29wZVJlZjogc2NvcGVSZWZcbiAgICAgICAgfSksIFtcbiAgICAgICAgc2NvcGVSZWZcbiAgICBdKTtcbiAgICAoMCwgJDZuZkZDJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgLy8gSWYgYSBuZXcgc2NvcGUgbW91bnRzIG91dHNpZGUgdGhlIGFjdGl2ZSBzY29wZSwgKGUuZy4gRGlhbG9nQ29udGFpbmVyIGxhdW5jaGVkIGZyb20gYSBtZW51KSxcbiAgICAgICAgLy8gdXNlIHRoZSBhY3RpdmUgc2NvcGUgYXMgdGhlIHBhcmVudCBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgZnJvbSBjb250ZXh0LiBMYXlvdXQgZWZmZWN0cyBydW4gYm90dG9tXG4gICAgICAgIC8vIHVwLCBzbyBpZiB0aGUgcGFyZW50IGlzIG5vdCB5ZXQgYWRkZWQgdG8gdGhlIHRyZWUsIGRvbid0IGRvIHRoaXMuIE9ubHkgdGhlIG91dGVyLW1vc3QgRm9jdXNTY29wZVxuICAgICAgICAvLyB0aGF0IGlzIGJlaW5nIGFkZGVkIHNob3VsZCBnZXQgdGhlIGFjdGl2ZVNjb3BlIGFzIGl0cyBwYXJlbnQuXG4gICAgICAgIGxldCBwYXJlbnQgPSBwYXJlbnROb2RlIHx8ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLnJvb3Q7XG4gICAgICAgIGlmICgkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZShwYXJlbnQuc2NvcGVSZWYpICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSAmJiAhJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzQW5jZXN0b3JTY29wZSgkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUsIHBhcmVudC5zY29wZVJlZikpIHtcbiAgICAgICAgICAgIGxldCBhY3RpdmVOb2RlID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlKTtcbiAgICAgICAgICAgIGlmIChhY3RpdmVOb2RlKSBwYXJlbnQgPSBhY3RpdmVOb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgbm9kZSB0byB0aGUgcGFyZW50LCBhbmQgdG8gdGhlIHRyZWUuXG4gICAgICAgIHBhcmVudC5hZGRDaGlsZChub2RlKTtcbiAgICAgICAgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuYWRkTm9kZShub2RlKTtcbiAgICB9LCBbXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHBhcmVudE5vZGVcbiAgICBdKTtcbiAgICAoMCwgJDZuZkZDJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IG5vZGUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZShzY29wZVJlZik7XG4gICAgICAgIGlmIChub2RlKSBub2RlLmNvbnRhaW4gPSAhIWNvbnRhaW47XG4gICAgfSwgW1xuICAgICAgICBjb250YWluXG4gICAgXSk7XG4gICAgKDAsICQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIHZhciBfc3RhcnRSZWZfY3VycmVudDtcbiAgICAgICAgLy8gRmluZCBhbGwgcmVuZGVyZWQgbm9kZXMgYmV0d2VlbiB0aGUgc2VudGluZWxzIGFuZCBhZGQgdGhlbSB0byB0aGUgc2NvcGUuXG4gICAgICAgIGxldCBub2RlID0gKF9zdGFydFJlZl9jdXJyZW50ID0gc3RhcnRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3N0YXJ0UmVmX2N1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGFydFJlZl9jdXJyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgd2hpbGUobm9kZSAmJiBub2RlICE9PSBlbmRSZWYuY3VycmVudCl7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGVSZWYuY3VycmVudCA9IG5vZGVzO1xuICAgIH0sIFtcbiAgICAgICAgY2hpbGRyZW5cbiAgICBdKTtcbiAgICAkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlQWN0aXZlU2NvcGVUcmFja2VyKHNjb3BlUmVmLCByZXN0b3JlRm9jdXMsIGNvbnRhaW4pO1xuICAgICQ5YmY3MWVhMjg3OTNlNzM4JHZhciR1c2VGb2N1c0NvbnRhaW5tZW50KHNjb3BlUmVmLCBjb250YWluKTtcbiAgICAkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlUmVzdG9yZUZvY3VzKHNjb3BlUmVmLCByZXN0b3JlRm9jdXMsIGNvbnRhaW4pO1xuICAgICQ5YmY3MWVhMjg3OTNlNzM4JHZhciR1c2VBdXRvRm9jdXMoc2NvcGVSZWYsIGF1dG9Gb2N1cyk7XG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBhbiBlZmZlY3Qgc28gdGhhdCBhY3RpdmVTY29wZSBpcyB1cGRhdGVkIGFmdGVyIHRoZSBGb2N1c1Njb3BlIHRyZWUgaXMgY29tcGxldGUuXG4gICAgLy8gSXQgY2Fubm90IGJlIGEgdXNlTGF5b3V0RWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCBvZiB0aGlzIG5vZGUgaGFzbid0IGJlZW4gYXR0YWNoZWQgaW4gdGhlIHRyZWUgeWV0LlxuICAgICgwLCAkNm5mRkMkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gKDAsICQ2bmZGQyRnZXRPd25lckRvY3VtZW50KShzY29wZVJlZi5jdXJyZW50ID8gc2NvcGVSZWYuY3VycmVudFswXSA6IHVuZGVmaW5lZCkuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IHNjb3BlID0gbnVsbDtcbiAgICAgICAgaWYgKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGFjdGl2ZUVsZW1lbnQsIHNjb3BlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYXZlcnNlIHRoZSBmb2N1c1Njb3BlIHRyZWUgYW5kIGZpbmQgdGhlIGJvdHRvbSBtb3N0IHNjb3BlIHRoYXRcbiAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSBhY3RpdmUgZWxlbWVudCBhbmQgc2V0IHRoYXQgYXMgdGhlIGFjdGl2ZVNjb3BlLlxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS50cmF2ZXJzZSgpKWlmIChub2RlLnNjb3BlUmVmICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGFjdGl2ZUVsZW1lbnQsIG5vZGUuc2NvcGVSZWYuY3VycmVudCkpIHNjb3BlID0gbm9kZTtcbiAgICAgICAgICAgIGlmIChzY29wZSA9PT0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoc2NvcGVSZWYpKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgPSBzY29wZS5zY29wZVJlZjtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgc2NvcGVSZWZcbiAgICBdKTtcbiAgICAvLyBUaGlzIGxheW91dCBlZmZlY3QgY2xlYW51cCBpcyBzbyB0aGF0IHRoZSB0cmVlIG5vZGUgaXMgcmVtb3ZlZCBzeW5jaHJvbm91c2x5IHdpdGggcmVhY3QgYmVmb3JlIHRoZSBSQUZcbiAgICAvLyBpbiB1c2VSZXN0b3JlRm9jdXMgY2xlYW51cCBydW5zLlxuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHZhciBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50LCBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGU7XG4gICAgICAgICAgICB2YXIgX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlX3BhcmVudF9zY29wZVJlZjtcbiAgICAgICAgICAgIC8vIFNjb3BlIG1heSBoYXZlIGJlZW4gcmUtcGFyZW50ZWQuXG4gICAgICAgICAgICBsZXQgcGFyZW50U2NvcGUgPSAoX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlX3BhcmVudF9zY29wZVJlZiA9IChfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZShzY29wZVJlZikpID09PSBudWxsIHx8IF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZV9wYXJlbnQgPSBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGUucGFyZW50KSA9PT0gbnVsbCB8fCBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50LnNjb3BlUmVmKSAhPT0gbnVsbCAmJiBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50X3Njb3BlUmVmICE9PSB2b2lkIDAgPyBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50X3Njb3BlUmVmIDogbnVsbDtcbiAgICAgICAgICAgIGlmICgoc2NvcGVSZWYgPT09ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSB8fCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNBbmNlc3RvclNjb3BlKHNjb3BlUmVmLCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUpKSAmJiAoIXBhcmVudFNjb3BlIHx8ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHBhcmVudFNjb3BlKSkpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSA9IHBhcmVudFNjb3BlO1xuICAgICAgICAgICAgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUucmVtb3ZlVHJlZU5vZGUoc2NvcGVSZWYpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgc2NvcGVSZWZcbiAgICBdKTtcbiAgICBsZXQgZm9jdXNNYW5hZ2VyID0gKDAsICQ2bmZGQyR1c2VNZW1vKSgoKT0+JDliZjcxZWEyODc5M2U3MzgkdmFyJGNyZWF0ZUZvY3VzTWFuYWdlckZvclNjb3BlKHNjb3BlUmVmKSwgW10pO1xuICAgIGxldCB2YWx1ZSA9ICgwLCAkNm5mRkMkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBmb2N1c01hbmFnZXI6IGZvY3VzTWFuYWdlcixcbiAgICAgICAgICAgIHBhcmVudE5vZGU6IG5vZGVcbiAgICAgICAgfSksIFtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZm9jdXNNYW5hZ2VyXG4gICAgXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ2bmZGQyRyZWFjdCkuY3JlYXRlRWxlbWVudCgkOWJmNzFlYTI4NzkzZTczOCR2YXIkRm9jdXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gKDAsICQ2bmZGQyRyZWFjdCkuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBcImRhdGEtZm9jdXMtc2NvcGUtc3RhcnRcIjogdHJ1ZSxcbiAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICByZWY6IHN0YXJ0UmVmXG4gICAgfSksIGNoaWxkcmVuLCAvKiNfX1BVUkVfXyovICgwLCAkNm5mRkMkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgXCJkYXRhLWZvY3VzLXNjb3BlLWVuZFwiOiB0cnVlLFxuICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgIHJlZjogZW5kUmVmXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDEwYzUxNjk3NTVjZTdiZDcoKSB7XG4gICAgdmFyIF91c2VDb250ZXh0O1xuICAgIHJldHVybiAoX3VzZUNvbnRleHQgPSAoMCwgJDZuZkZDJHVzZUNvbnRleHQpKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRGb2N1c0NvbnRleHQpKSA9PT0gbnVsbCB8fCBfdXNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3VzZUNvbnRleHQuZm9jdXNNYW5hZ2VyO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGNyZWF0ZUZvY3VzTWFuYWdlckZvclNjb3BlKHNjb3BlUmVmKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNOZXh0IChvcHRzID0ge30pIHtcbiAgICAgICAgICAgIGxldCBzY29wZSA9IHNjb3BlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBsZXQgeyBmcm9tOiBmcm9tLCB0YWJiYWJsZTogdGFiYmFibGUsIHdyYXA6IHdyYXAsIGFjY2VwdDogYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBmcm9tIHx8ICgwLCAkNm5mRkMkZ2V0T3duZXJEb2N1bWVudCkoc2NvcGVbMF0pLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgc2VudGluZWwgPSBzY29wZVswXS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgbGV0IHNjb3BlUm9vdCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUobm9kZSwgc2NvcGUpID8gbm9kZSA6IHNlbnRpbmVsO1xuICAgICAgICAgICAgbGV0IG5leHROb2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZiAoIW5leHROb2RlICYmIHdyYXApIHtcbiAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzZW50aW5lbDtcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHROb2RlKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KG5leHROb2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNQcmV2aW91cyAob3B0cyA9IHt9KSB7XG4gICAgICAgICAgICBsZXQgc2NvcGUgPSBzY29wZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgbGV0IHsgZnJvbTogZnJvbSwgdGFiYmFibGU6IHRhYmJhYmxlLCB3cmFwOiB3cmFwLCBhY2NlcHQ6IGFjY2VwdCB9ID0gb3B0cztcbiAgICAgICAgICAgIGxldCBub2RlID0gZnJvbSB8fCAoMCwgJDZuZkZDJGdldE93bmVyRG9jdW1lbnQpKHNjb3BlWzBdKS5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgbGV0IHNlbnRpbmVsID0gc2NvcGVbc2NvcGUubGVuZ3RoIC0gMV0ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgbGV0IHNjb3BlUm9vdCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUobm9kZSwgc2NvcGUpID8gbm9kZSA6IHNlbnRpbmVsO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzTm9kZSA9IHdhbGtlci5wcmV2aW91c05vZGUoKTtcbiAgICAgICAgICAgIGlmICghcHJldmlvdXNOb2RlICYmIHdyYXApIHtcbiAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzZW50aW5lbDtcbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSB3YWxrZXIucHJldmlvdXNOb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldmlvdXNOb2RlKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KHByZXZpb3VzTm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNOb2RlO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1c0ZpcnN0IChvcHRzID0ge30pIHtcbiAgICAgICAgICAgIGxldCBzY29wZSA9IHNjb3BlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBsZXQgeyB0YWJiYWJsZTogdGFiYmFibGUsIGFjY2VwdDogYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IHNjb3BlUm9vdCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gc2NvcGVbMF0ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgICAgICAgIGxldCBuZXh0Tm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKG5leHROb2RlKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KG5leHROb2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNMYXN0IChvcHRzID0ge30pIHtcbiAgICAgICAgICAgIGxldCBzY29wZSA9IHNjb3BlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBsZXQgeyB0YWJiYWJsZTogdGFiYmFibGUsIGFjY2VwdDogYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IHNjb3BlUm9vdCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gc2NvcGVbc2NvcGUubGVuZ3RoIC0gMV0ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzTm9kZSA9IHdhbGtlci5wcmV2aW91c05vZGUoKTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c05vZGUpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQocHJldmlvdXNOb2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c05vZGU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzYWJsZUVsZW1lbnRzID0gW1xuICAgIFwiaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbdHlwZT1oaWRkZW5dKVwiLFxuICAgIFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiLFxuICAgIFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCIsXG4gICAgXCJidXR0b246bm90KFtkaXNhYmxlZF0pXCIsXG4gICAgXCJhW2hyZWZdXCIsXG4gICAgXCJhcmVhW2hyZWZdXCIsXG4gICAgXCJzdW1tYXJ5XCIsXG4gICAgXCJpZnJhbWVcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwiZW1iZWRcIixcbiAgICBcImF1ZGlvW2NvbnRyb2xzXVwiLFxuICAgIFwidmlkZW9bY29udHJvbHNdXCIsXG4gICAgXCJbY29udGVudGVkaXRhYmxlXVwiXG5dO1xuY29uc3QgJDliZjcxZWEyODc5M2U3MzgkdmFyJEZPQ1VTQUJMRV9FTEVNRU5UX1NFTEVDVE9SID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzYWJsZUVsZW1lbnRzLmpvaW4oXCI6bm90KFtoaWRkZW5dKSxcIikgKyBcIixbdGFiaW5kZXhdOm5vdChbZGlzYWJsZWRdKTpub3QoW2hpZGRlbl0pXCI7XG4kOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNhYmxlRWxlbWVudHMucHVzaCgnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pOm5vdChbZGlzYWJsZWRdKScpO1xuY29uc3QgJDliZjcxZWEyODc5M2U3MzgkdmFyJFRBQkJBQkxFX0VMRU1FTlRfU0VMRUNUT1IgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNhYmxlRWxlbWVudHMuam9pbignOm5vdChbaGlkZGVuXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKSwnKTtcbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGVbMF0ucGFyZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRzaG91bGRDb250YWluRm9jdXMoc2NvcGVSZWYpIHtcbiAgICBsZXQgc2NvcGUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZSgkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUpO1xuICAgIHdoaWxlKHNjb3BlICYmIHNjb3BlLnNjb3BlUmVmICE9PSBzY29wZVJlZil7XG4gICAgICAgIGlmIChzY29wZS5jb250YWluKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHNjb3BlID0gc2NvcGUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciR1c2VGb2N1c0NvbnRhaW5tZW50KHNjb3BlUmVmLCBjb250YWluKSB7XG4gICAgbGV0IGZvY3VzZWROb2RlID0gKDAsICQ2bmZGQyR1c2VSZWYpKCk7XG4gICAgbGV0IHJhZiA9ICgwLCAkNm5mRkMkdXNlUmVmKSgpO1xuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgc2NvcGUgPSBzY29wZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNvbnRhaW4pIHtcbiAgICAgICAgICAgIC8vIGlmIGNvbnRhaW4gd2FzIGNoYW5nZWQsIHRoZW4gd2Ugc2hvdWxkIGNhbmNlbCBhbnkgb25nb2luZyB3YWl0cyB0byBwdWxsIGZvY3VzIGJhY2sgaW50byBjb250YWlubWVudFxuICAgICAgICAgICAgaWYgKHJhZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHJhZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSAoMCwgJDZuZkZDJGdldE93bmVyRG9jdW1lbnQpKHNjb3BlID8gc2NvcGVbMF0gOiB1bmRlZmluZWQpO1xuICAgICAgICAvLyBIYW5kbGUgdGhlIFRhYiBrZXkgdG8gY29udGFpbiBmb2N1cyB3aXRoaW4gdGhlIHNjb3BlXG4gICAgICAgIGxldCBvbktleURvd24gPSAoZSk9PntcbiAgICAgICAgICAgIGlmIChlLmtleSAhPT0gXCJUYWJcIiB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8ICEkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkQ29udGFpbkZvY3VzKHNjb3BlUmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGZvY3VzZWRFbGVtZW50ID0gb3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgbGV0IHNjb3BlID0gc2NvcGVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghc2NvcGUgfHwgISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGZvY3VzZWRFbGVtZW50LCBzY29wZSkpIHJldHVybjtcbiAgICAgICAgICAgIGxldCBzY29wZVJvb3QgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZ2V0U2NvcGVSb290KHNjb3BlKTtcbiAgICAgICAgICAgIGxldCB3YWxrZXIgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYShzY29wZVJvb3QsIHtcbiAgICAgICAgICAgICAgICB0YWJiYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICAgICAgaWYgKCFmb2N1c2VkRWxlbWVudCkgcmV0dXJuO1xuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gZm9jdXNlZEVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgbmV4dEVsZW1lbnQgPSBlLnNoaWZ0S2V5ID8gd2Fsa2VyLnByZXZpb3VzTm9kZSgpIDogd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZiAoIW5leHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gZS5zaGlmdEtleSA/IHNjb3BlW3Njb3BlLmxlbmd0aCAtIDFdLm5leHRFbGVtZW50U2libGluZyA6IHNjb3BlWzBdLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgbmV4dEVsZW1lbnQgPSBlLnNoaWZ0S2V5ID8gd2Fsa2VyLnByZXZpb3VzTm9kZSgpIDogd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAobmV4dEVsZW1lbnQpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQobmV4dEVsZW1lbnQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgb25Gb2N1cyA9IChlKT0+e1xuICAgICAgICAgICAgLy8gSWYgZm9jdXNpbmcgYW4gZWxlbWVudCBpbiBhIGNoaWxkIHNjb3BlIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNjb3BlLCB0aGUgY2hpbGQgYmVjb21lcyBhY3RpdmUuXG4gICAgICAgICAgICAvLyBNb3Zpbmcgb3V0IG9mIHRoZSBhY3RpdmUgc2NvcGUgdG8gYW4gYW5jZXN0b3IgaXMgbm90IGFsbG93ZWQuXG4gICAgICAgICAgICBpZiAoKCEkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgfHwgJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzQW5jZXN0b3JTY29wZSgkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUsIHNjb3BlUmVmKSkgJiYgJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUoZS50YXJnZXQsIHNjb3BlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gc2NvcGVSZWY7XG4gICAgICAgICAgICAgICAgZm9jdXNlZE5vZGUuY3VycmVudCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkQ29udGFpbkZvY3VzKHNjb3BlUmVmKSAmJiAhJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluQ2hpbGRTY29wZShlLnRhcmdldCwgc2NvcGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBmb2N1cyBldmVudCBvY2N1cnMgb3V0c2lkZSB0aGUgYWN0aXZlIHNjb3BlIChlLmcuIHVzZXIgdGFicyBmcm9tIGJyb3dzZXIgbG9jYXRpb24gYmFyKSxcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGZvY3VzIHRvIHRoZSBwcmV2aW91c2x5IGZvY3VzZWQgbm9kZSBvciB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudCBpbiB0aGUgYWN0aXZlIHNjb3BlLlxuICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkTm9kZS5jdXJyZW50KSBmb2N1c2VkTm9kZS5jdXJyZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZS5jdXJyZW50KSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNGaXJzdEluU2NvcGUoJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlLmN1cnJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkQ29udGFpbkZvY3VzKHNjb3BlUmVmKSkgZm9jdXNlZE5vZGUuY3VycmVudCA9IGUudGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICBsZXQgb25CbHVyID0gKGUpPT57XG4gICAgICAgICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc2hpZnQgZm9jdXMgYmFjayB0byB0aGUgRGlhbG9nIHByb3Blcmx5IHdpdGhvdXQgdGhpc1xuICAgICAgICAgICAgaWYgKHJhZi5jdXJyZW50KSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYuY3VycmVudCk7XG4gICAgICAgICAgICByYWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgIC8vIFVzZSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluc3RlYWQgb2YgZS5yZWxhdGVkVGFyZ2V0IHNvIHdlIGNhbiB0ZWxsIGlmIHVzZXIgY2xpY2tlZCBpbnRvIGlmcmFtZVxuICAgICAgICAgICAgICAgIGlmIChvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgJDliZjcxZWEyODc5M2U3MzgkdmFyJHNob3VsZENvbnRhaW5Gb2N1cyhzY29wZVJlZikgJiYgISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJbkNoaWxkU2NvcGUob3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50LCBzY29wZVJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gc2NvcGVSZWY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvd25lckRvY3VtZW50LmJvZHkuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ZvY3VzZWROb2RlX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2VkTm9kZS5jdXJyZW50ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2ZvY3VzZWROb2RlX2N1cnJlbnQgPSBmb2N1c2VkTm9kZS5jdXJyZW50KSA9PT0gbnVsbCB8fCBfZm9jdXNlZE5vZGVfY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZvY3VzZWROb2RlX2N1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUuY3VycmVudCkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRmlyc3RJblNjb3BlKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24sIGZhbHNlKTtcbiAgICAgICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvbkZvY3VzLCBmYWxzZSk7XG4gICAgICAgIHNjb3BlID09PSBudWxsIHx8IHNjb3BlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY29wZS5mb3JFYWNoKChlbGVtZW50KT0+ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvbkZvY3VzLCBmYWxzZSkpO1xuICAgICAgICBzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIG9uQmx1ciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93biwgZmFsc2UpO1xuICAgICAgICAgICAgb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvbkZvY3VzLCBmYWxzZSk7XG4gICAgICAgICAgICBzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpKTtcbiAgICAgICAgICAgIHNjb3BlID09PSBudWxsIHx8IHNjb3BlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY29wZS5mb3JFYWNoKChlbGVtZW50KT0+ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgb25CbHVyLCBmYWxzZSkpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgc2NvcGVSZWYsXG4gICAgICAgIGNvbnRhaW5cbiAgICBdKTtcbiAgICAvLyBUaGlzIGlzIGEgdXNlTGF5b3V0RWZmZWN0IHNvIGl0IGlzIGd1YXJhbnRlZWQgdG8gcnVuIGJlZm9yZSBvdXIgYXN5bmMgc3ludGhldGljIGJsdXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmIChyYWYuY3VycmVudCkgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmLmN1cnJlbnQpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcmFmXG4gICAgXSk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5BbnlTY29wZShlbGVtZW50KSB7XG4gICAgcmV0dXJuICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJbkNoaWxkU2NvcGUoZWxlbWVudCk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShlbGVtZW50LCBzY29wZSkge1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghc2NvcGUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc2NvcGUuc29tZSgobm9kZSk9Pm5vZGUuY29udGFpbnMoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluQ2hpbGRTY29wZShlbGVtZW50LCBzY29wZSA9IG51bGwpIHtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyB3aXRoaW4gYSB0b3AgbGF5ZXIgZWxlbWVudCAoZS5nLiB0b2FzdHMpLCBhbHdheXMgYWxsb3cgbW92aW5nIGZvY3VzIHRoZXJlLlxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCAmJiBlbGVtZW50LmNsb3Nlc3QoXCJbZGF0YS1yZWFjdC1hcmlhLXRvcC1sYXllcl1cIikpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vZGUuY29udGFpbnMgaW4gaXNFbGVtZW50SW5TY29wZSBjb3ZlcnMgY2hpbGQgc2NvcGVzIHRoYXQgYXJlIGFsc28gRE9NIGNoaWxkcmVuLFxuICAgIC8vIGJ1dCBkb2VzIG5vdCBjb3ZlciBjaGlsZCBzY29wZXMgaW4gcG9ydGFscy5cbiAgICBmb3IgKGxldCB7IHNjb3BlUmVmOiBzIH0gb2YgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUudHJhdmVyc2UoJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoc2NvcGUpKSl7XG4gICAgICAgIGlmIChzICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGVsZW1lbnQsIHMuY3VycmVudCkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMTI1ODM5NWY5OWJmOWNiZihlbGVtZW50KSB7XG4gICAgcmV0dXJuICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJbkNoaWxkU2NvcGUoZWxlbWVudCwgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlKTtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0FuY2VzdG9yU2NvcGUoYW5jZXN0b3IsIHNjb3BlKSB7XG4gICAgdmFyIF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZTtcbiAgICBsZXQgcGFyZW50ID0gKF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHNjb3BlKSkgPT09IG51bGwgfHwgX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGUucGFyZW50O1xuICAgIHdoaWxlKHBhcmVudCl7XG4gICAgICAgIGlmIChwYXJlbnQuc2NvcGVSZWYgPT09IGFuY2VzdG9yKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChlbGVtZW50LCBzY3JvbGwgPSBmYWxzZSkge1xuICAgIGlmIChlbGVtZW50ICE9IG51bGwgJiYgIXNjcm9sbCkgdHJ5IHtcbiAgICAgICAgKDAsICQ2YTk5MTk1MzMyZWRlYzhiJGV4cG9ydCQ4MGYzZTE0N2Q3ODE1NzFjKShlbGVtZW50KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgZWxzZSBpZiAoZWxlbWVudCAhPSBudWxsKSB0cnkge1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gaWdub3JlXG4gICAgfVxufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRmlyc3RJblNjb3BlKHNjb3BlLCB0YWJiYWJsZSA9IHRydWUpIHtcbiAgICBsZXQgc2VudGluZWwgPSBzY29wZVswXS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGxldCBzY29wZVJvb3QgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZ2V0U2NvcGVSb290KHNjb3BlKTtcbiAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEoc2NvcGVSb290LCB7XG4gICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZVxuICAgIH0sIHNjb3BlKTtcbiAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzZW50aW5lbDtcbiAgICBsZXQgbmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAvLyBJZiB0aGUgc2NvcGUgZG9lcyBub3QgY29udGFpbiBhIHRhYmJhYmxlIGVsZW1lbnQsIHVzZSB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQuXG4gICAgaWYgKHRhYmJhYmxlICYmICFuZXh0Tm9kZSkge1xuICAgICAgICBzY29wZVJvb3QgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZ2V0U2NvcGVSb290KHNjb3BlKTtcbiAgICAgICAgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEoc2NvcGVSb290LCB7XG4gICAgICAgICAgICB0YWJiYWJsZTogZmFsc2VcbiAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzZW50aW5lbDtcbiAgICAgICAgbmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICB9XG4gICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChuZXh0Tm9kZSk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlQXV0b0ZvY3VzKHNjb3BlUmVmLCBhdXRvRm9jdXMpIHtcbiAgICBjb25zdCBhdXRvRm9jdXNSZWYgPSAoMCwgJDZuZkZDJHJlYWN0KS51c2VSZWYoYXV0b0ZvY3VzKTtcbiAgICAoMCwgJDZuZkZDJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGF1dG9Gb2N1c1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgPSBzY29wZVJlZjtcbiAgICAgICAgICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSAoMCwgJDZuZkZDJGdldE93bmVyRG9jdW1lbnQpKHNjb3BlUmVmLmN1cnJlbnQgPyBzY29wZVJlZi5jdXJyZW50WzBdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmICghJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUob3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50LCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUuY3VycmVudCkgJiYgc2NvcGVSZWYuY3VycmVudCkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRmlyc3RJblNjb3BlKHNjb3BlUmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGF1dG9Gb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSwgW1xuICAgICAgICBzY29wZVJlZlxuICAgIF0pO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZUFjdGl2ZVNjb3BlVHJhY2tlcihzY29wZVJlZiwgcmVzdG9yZSwgY29udGFpbikge1xuICAgIC8vIHRyYWNrcyB0aGUgYWN0aXZlIHNjb3BlLCBpbiBjYXNlIHJlc3RvcmUgYW5kIGNvbnRhaW4gYXJlIGJvdGggZmFsc2UuXG4gICAgLy8gaWYgZWl0aGVyIGFyZSB0cnVlLCB0aGlzIGlzIHRyYWNrZWQgaW4gdXNlUmVzdG9yZUZvY3VzIG9yIHVzZUZvY3VzQ29udGFpbm1lbnQuXG4gICAgKDAsICQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChyZXN0b3JlIHx8IGNvbnRhaW4pIHJldHVybjtcbiAgICAgICAgbGV0IHNjb3BlID0gc2NvcGVSZWYuY3VycmVudDtcbiAgICAgICAgY29uc3Qgb3duZXJEb2N1bWVudCA9ICgwLCAkNm5mRkMkZ2V0T3duZXJEb2N1bWVudCkoc2NvcGUgPyBzY29wZVswXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGxldCBvbkZvY3VzID0gKGUpPT57XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUodGFyZ2V0LCBzY29wZVJlZi5jdXJyZW50KSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gc2NvcGVSZWY7XG4gICAgICAgICAgICBlbHNlIGlmICghJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluQW55U2NvcGUodGFyZ2V0KSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvbkZvY3VzLCBmYWxzZSk7XG4gICAgICAgIHNjb3BlID09PSBudWxsIHx8IHNjb3BlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY29wZS5mb3JFYWNoKChlbGVtZW50KT0+ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvbkZvY3VzLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIG93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpO1xuICAgICAgICAgICAgc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLmZvckVhY2goKGVsZW1lbnQpPT5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKSk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBzY29wZVJlZixcbiAgICAgICAgcmVzdG9yZSxcbiAgICAgICAgY29udGFpblxuICAgIF0pO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJHNob3VsZFJlc3RvcmVGb2N1cyhzY29wZVJlZikge1xuICAgIGxldCBzY29wZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSk7XG4gICAgd2hpbGUoc2NvcGUgJiYgc2NvcGUuc2NvcGVSZWYgIT09IHNjb3BlUmVmKXtcbiAgICAgICAgaWYgKHNjb3BlLm5vZGVUb1Jlc3RvcmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiAoc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLnNjb3BlUmVmKSA9PT0gc2NvcGVSZWY7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlUmVzdG9yZUZvY3VzKHNjb3BlUmVmLCByZXN0b3JlRm9jdXMsIGNvbnRhaW4pIHtcbiAgICAvLyBjcmVhdGUgYSByZWYgZHVyaW5nIHJlbmRlciBpbnN0ZWFkIG9mIHVzZUxheW91dEVmZmVjdCBzbyB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgc2F2ZWQgYmVmb3JlIGEgY2hpbGQgd2l0aCBhdXRvRm9jdXM9dHJ1ZSBtb3VudHMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGNvbnN0IG5vZGVUb1Jlc3RvcmVSZWYgPSAoMCwgJDZuZkZDJHVzZVJlZikodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gKDAsICQ2bmZGQyRnZXRPd25lckRvY3VtZW50KShzY29wZVJlZi5jdXJyZW50ID8gc2NvcGVSZWYuY3VycmVudFswXSA6IHVuZGVmaW5lZCkuYWN0aXZlRWxlbWVudCA6IG51bGwpO1xuICAgIC8vIHJlc3RvcmluZyBzY29wZXMgc2hvdWxkIGFsbCB0cmFjayBpZiB0aGV5IGFyZSBhY3RpdmUgcmVnYXJkbGVzcyBvZiBjb250YWluLCBidXQgY29udGFpbiBhbHJlYWR5IHRyYWNrcyBpdCBwbHVzIGxvZ2ljIHRvIGNvbnRhaW4gdGhlIGZvY3VzXG4gICAgLy8gcmVzdG9yaW5nLW5vbi1jb250YWluaW5nIHNjb3BlcyBzaG91bGQgb25seSBjYXJlIGlmIHRoZXkgYmVjb21lIGFjdGl2ZSBzbyB0aGV5IGNhbiBwZXJmb3JtIHRoZSByZXN0b3JlXG4gICAgKDAsICQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBzY29wZSA9IHNjb3BlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSAoMCwgJDZuZkZDJGdldE93bmVyRG9jdW1lbnQpKHNjb3BlID8gc2NvcGVbMF0gOiB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoIXJlc3RvcmVGb2N1cyB8fCBjb250YWluKSByZXR1cm47XG4gICAgICAgIGxldCBvbkZvY3VzID0gKCk9PntcbiAgICAgICAgICAgIC8vIElmIGZvY3VzaW5nIGFuIGVsZW1lbnQgaW4gYSBjaGlsZCBzY29wZSBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBzY29wZSwgdGhlIGNoaWxkIGJlY29tZXMgYWN0aXZlLlxuICAgICAgICAgICAgLy8gTW92aW5nIG91dCBvZiB0aGUgYWN0aXZlIHNjb3BlIHRvIGFuIGFuY2VzdG9yIGlzIG5vdCBhbGxvd2VkLlxuICAgICAgICAgICAgaWYgKCghJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlIHx8ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0FuY2VzdG9yU2NvcGUoJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlLCBzY29wZVJlZikpICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKG93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgc2NvcGVSZWYuY3VycmVudCkpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSA9IHNjb3BlUmVmO1xuICAgICAgICB9O1xuICAgICAgICBvd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKTtcbiAgICAgICAgc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLmZvckVhY2goKGVsZW1lbnQpPT5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvbkZvY3VzLCBmYWxzZSk7XG4gICAgICAgICAgICBzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpKTtcbiAgICAgICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBzY29wZVJlZixcbiAgICAgICAgY29udGFpblxuICAgIF0pO1xuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBjb25zdCBvd25lckRvY3VtZW50ID0gKDAsICQ2bmZGQyRnZXRPd25lckRvY3VtZW50KShzY29wZVJlZi5jdXJyZW50ID8gc2NvcGVSZWYuY3VycmVudFswXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICghcmVzdG9yZUZvY3VzKSByZXR1cm47XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgVGFiIGtleSBzbyB0aGF0IHRhYmJpbmcgb3V0IG9mIHRoZSBzY29wZSBnb2VzIHRvIHRoZSBuZXh0IGVsZW1lbnRcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIG5vZGUgdGhhdCBoYWQgZm9jdXMgd2hlbiB0aGUgc2NvcGUgbW91bnRlZC4gVGhpcyBpcyBpbXBvcnRhbnQgd2hlblxuICAgICAgICAvLyB1c2luZyBwb3J0YWxzIGZvciBvdmVybGF5cywgc28gdGhhdCBmb2N1cyBnb2VzIHRvIHRoZSBleHBlY3RlZCBlbGVtZW50IHdoZW5cbiAgICAgICAgLy8gdGFiYmluZyBvdXQgb2YgdGhlIG92ZXJsYXkuXG4gICAgICAgIGxldCBvbktleURvd24gPSAoZSk9PntcbiAgICAgICAgICAgIGlmIChlLmtleSAhPT0gXCJUYWJcIiB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8ICEkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkQ29udGFpbkZvY3VzKHNjb3BlUmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGZvY3VzZWRFbGVtZW50ID0gb3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCEkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShmb2N1c2VkRWxlbWVudCwgc2NvcGVSZWYuY3VycmVudCkpIHJldHVybjtcbiAgICAgICAgICAgIGxldCB0cmVlTm9kZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHNjb3BlUmVmKTtcbiAgICAgICAgICAgIGlmICghdHJlZU5vZGUpIHJldHVybjtcbiAgICAgICAgICAgIGxldCBub2RlVG9SZXN0b3JlID0gdHJlZU5vZGUubm9kZVRvUmVzdG9yZTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIERPTSB0cmVlIHdhbGtlciB0aGF0IG1hdGNoZXMgYWxsIHRhYmJhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEob3duZXJEb2N1bWVudC5ib2R5LCB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgbmV4dCB0YWJiYWJsZSBlbGVtZW50IGFmdGVyIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBmb2N1c2VkRWxlbWVudDtcbiAgICAgICAgICAgIGxldCBuZXh0RWxlbWVudCA9IGUuc2hpZnRLZXkgPyB3YWxrZXIucHJldmlvdXNOb2RlKCkgOiB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIGlmICghbm9kZVRvUmVzdG9yZSB8fCAhb3duZXJEb2N1bWVudC5ib2R5LmNvbnRhaW5zKG5vZGVUb1Jlc3RvcmUpIHx8IG5vZGVUb1Jlc3RvcmUgPT09IG93bmVyRG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIG5vZGVUb1Jlc3RvcmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdHJlZU5vZGUubm9kZVRvUmVzdG9yZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG5leHQgZWxlbWVudCwgb3IgaXQgaXMgb3V0c2lkZSB0aGUgY3VycmVudCBzY29wZSwgbW92ZSBmb2N1cyB0byB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgZWxlbWVudCBhZnRlciB0aGUgbm9kZSB0byByZXN0b3JlIHRvIGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoKCFuZXh0RWxlbWVudCB8fCAhJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUobmV4dEVsZW1lbnQsIHNjb3BlUmVmLmN1cnJlbnQpKSAmJiBub2RlVG9SZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZVRvUmVzdG9yZTtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIG92ZXIgZWxlbWVudHMgd2l0aGluIHRoZSBzY29wZSwgaW4gY2FzZSB0aGUgc2NvcGUgaW1tZWRpYXRlbHkgZm9sbG93cyB0aGUgbm9kZSB0byByZXN0b3JlLlxuICAgICAgICAgICAgICAgIGRvIG5leHRFbGVtZW50ID0gZS5zaGlmdEtleSA/IHdhbGtlci5wcmV2aW91c05vZGUoKSA6IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICgkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShuZXh0RWxlbWVudCwgc2NvcGVSZWYuY3VycmVudCkpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0RWxlbWVudCkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChuZXh0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSAvLyBJZiB0aGVyZSBpcyBubyBuZXh0IGVsZW1lbnQgYW5kIHRoZSBub2RlVG9SZXN0b3JlIGlzbid0IHdpdGhpbiBhIEZvY3VzU2NvcGUgKGkuZS4gd2UgYXJlIGxlYXZpbmcgdGhlIHRvcCBsZXZlbCBmb2N1cyBzY29wZSlcbiAgICAgICAgICAgICAgICAvLyB0aGVuIG1vdmUgZm9jdXMgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc3RvcmUgZm9jdXMgdG8gdGhlIG5vZGVUb1Jlc3RvcmUgKGUuZyBtZW51IHdpdGhpbiBhIHBvcG92ZXIgLT4gdGFiYmluZyB0byBjbG9zZSB0aGUgbWVudSBzaG91bGQgbW92ZSBmb2N1cyB0byBtZW51IHRyaWdnZXIpXG4gICAgICAgICAgICAgICAgaWYgKCEkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5BbnlTY29wZShub2RlVG9SZXN0b3JlKSkgZm9jdXNlZEVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgIGVsc2UgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChub2RlVG9SZXN0b3JlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFjb250YWluKSBvd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKCFjb250YWluKSBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBzY29wZVJlZixcbiAgICAgICAgcmVzdG9yZUZvY3VzLFxuICAgICAgICBjb250YWluXG4gICAgXSk7XG4gICAgLy8gdXNlTGF5b3V0RWZmZWN0IGluc3RlYWQgb2YgdXNlRWZmZWN0IHNvIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBzYXZlZCBzeW5jaHJvbm91c2x5IGluc3RlYWQgb2YgYXN5bmNocm9ub3VzbHkuXG4gICAgKDAsICQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSAoMCwgJDZuZkZDJGdldE93bmVyRG9jdW1lbnQpKHNjb3BlUmVmLmN1cnJlbnQgPyBzY29wZVJlZi5jdXJyZW50WzBdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKCFyZXN0b3JlRm9jdXMpIHJldHVybjtcbiAgICAgICAgbGV0IHRyZWVOb2RlID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoc2NvcGVSZWYpO1xuICAgICAgICBpZiAoIXRyZWVOb2RlKSByZXR1cm47XG4gICAgICAgIHZhciBfbm9kZVRvUmVzdG9yZVJlZl9jdXJyZW50O1xuICAgICAgICB0cmVlTm9kZS5ub2RlVG9SZXN0b3JlID0gKF9ub2RlVG9SZXN0b3JlUmVmX2N1cnJlbnQgPSBub2RlVG9SZXN0b3JlUmVmLmN1cnJlbnQpICE9PSBudWxsICYmIF9ub2RlVG9SZXN0b3JlUmVmX2N1cnJlbnQgIT09IHZvaWQgMCA/IF9ub2RlVG9SZXN0b3JlUmVmX2N1cnJlbnQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgbGV0IHRyZWVOb2RlID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoc2NvcGVSZWYpO1xuICAgICAgICAgICAgaWYgKCF0cmVlTm9kZSkgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IG5vZGVUb1Jlc3RvcmUgPSB0cmVlTm9kZS5ub2RlVG9SZXN0b3JlO1xuICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBsb3N0IGZvY3VzIHRvIHRoZSBib2R5IGFuZCB0aGlzIHdhcyB0aGUgYWN0aXZlIHNjb3BlLCB0aGVuIHdlIHNob3VsZCBhdHRlbXB0IHRvIHJlc3RvcmVcbiAgICAgICAgICAgIGlmIChyZXN0b3JlRm9jdXMgJiYgbm9kZVRvUmVzdG9yZSAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgICAgICAoJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUob3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50LCBzY29wZVJlZi5jdXJyZW50KSB8fCBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IG93bmVyRG9jdW1lbnQuYm9keSAmJiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkUmVzdG9yZUZvY3VzKHNjb3BlUmVmKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBmcmVlemUgdGhlIGZvY3VzU2NvcGVUcmVlIHNvIGl0IHBlcnNpc3RzIGFmdGVyIHRoZSByYWYsIG90aGVyd2lzZSBkdXJpbmcgdW5tb3VudCBub2RlcyBhcmUgcmVtb3ZlZCBmcm9tIGl0XG4gICAgICAgICAgICAgICAgbGV0IGNsb25lZFRyZWUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc3RvcmUgZm9jdXMgaWYgd2UndmUgbG9zdCBmb2N1cyB0byB0aGUgYm9keSwgdGhlIGFsdGVybmF0aXZlIGlzIHRoYXQgZm9jdXMgaGFzIGJlZW4gcHVycG9zZWZ1bGx5IG1vdmVkIGVsc2V3aGVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAob3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBvd25lckRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgdXAgdGhlIHRyZWUgc3RhcnRpbmcgd2l0aCBvdXIgc2NvcGUgdG8gZmluZCBhIG5vZGVUb1Jlc3RvcmUgc3RpbGwgaW4gdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyZWVOb2RlID0gY2xvbmVkVHJlZS5nZXRUcmVlTm9kZShzY29wZVJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSh0cmVlTm9kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLm5vZGVUb1Jlc3RvcmUgJiYgdHJlZU5vZGUubm9kZVRvUmVzdG9yZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KHRyZWVOb2RlLm5vZGVUb1Jlc3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlID0gdHJlZU5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gbm9kZVRvUmVzdG9yZSB3YXMgZm91bmQsIGZvY3VzIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBuZWFyZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmNlc3RvciBzY29wZSB0aGF0IGlzIHN0aWxsIGluIHRoZSB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUgPSBjbG9uZWRUcmVlLmdldFRyZWVOb2RlKHNjb3BlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHRyZWVOb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZU5vZGUuc2NvcGVSZWYgJiYgdHJlZU5vZGUuc2NvcGVSZWYuY3VycmVudCAmJiAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZSh0cmVlTm9kZS5zY29wZVJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRmlyc3RJblNjb3BlKHRyZWVOb2RlLnNjb3BlUmVmLmN1cnJlbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlID0gdHJlZU5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBzY29wZVJlZixcbiAgICAgICAgcmVzdG9yZUZvY3VzXG4gICAgXSk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYShyb290LCBvcHRzLCBzY29wZSkge1xuICAgIGxldCBzZWxlY3RvciA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMudGFiYmFibGUpID8gJDliZjcxZWEyODc5M2U3MzgkdmFyJFRBQkJBQkxFX0VMRU1FTlRfU0VMRUNUT1IgOiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkRk9DVVNBQkxFX0VMRU1FTlRfU0VMRUNUT1I7XG4gICAgbGV0IHdhbGtlciA9ICgwLCAkNm5mRkMkZ2V0T3duZXJEb2N1bWVudCkocm9vdCkuY3JlYXRlVHJlZVdhbGtlcihyb290LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwge1xuICAgICAgICBhY2NlcHROb2RlIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgX29wdHNfZnJvbTtcbiAgICAgICAgICAgIC8vIFNraXAgbm9kZXMgaW5zaWRlIHRoZSBzdGFydGluZyBub2RlLlxuICAgICAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9vcHRzX2Zyb20gPSBvcHRzLmZyb20pID09PSBudWxsIHx8IF9vcHRzX2Zyb20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzX2Zyb20uY29udGFpbnMobm9kZSkpIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICAgICAgICBpZiAobm9kZS5tYXRjaGVzKHNlbGVjdG9yKSAmJiAoMCwgJDY0NWYyZTY3Yjg1YTI0YzkkZXhwb3J0JGU5ODljMGZmZmFhNmIyN2EpKG5vZGUpICYmICghc2NvcGUgfHwgJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUobm9kZSwgc2NvcGUpKSAmJiAoIShvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuYWNjZXB0KSB8fCBvcHRzLmFjY2VwdChub2RlKSkpIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZnJvbSkgd2Fsa2VyLmN1cnJlbnROb2RlID0gb3B0cy5mcm9tO1xuICAgIHJldHVybiB3YWxrZXI7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkYzUyNTFiOWUxMjRiZjI5KHJlZiwgZGVmYXVsdE9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvY3VzTmV4dCAob3B0cyA9IHt9KSB7XG4gICAgICAgICAgICBsZXQgcm9vdCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFyb290KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCB7IGZyb206IGZyb20sIHRhYmJhYmxlOiB0YWJiYWJsZSA9IGRlZmF1bHRPcHRpb25zLnRhYmJhYmxlLCB3cmFwOiB3cmFwID0gZGVmYXVsdE9wdGlvbnMud3JhcCwgYWNjZXB0OiBhY2NlcHQgPSBkZWZhdWx0T3B0aW9ucy5hY2NlcHQgfSA9IG9wdHM7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGZyb20gfHwgKDAsICQ2bmZGQyRnZXRPd25lckRvY3VtZW50KShyb290KS5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHJvb3QsIHtcbiAgICAgICAgICAgICAgICB0YWJiYWJsZTogdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgYWNjZXB0OiBhY2NlcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJvb3QuY29udGFpbnMobm9kZSkpIHdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICBsZXQgbmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIGlmICghbmV4dE5vZGUgJiYgd3JhcCkge1xuICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChuZXh0Tm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzUHJldmlvdXMgKG9wdHMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHJvb3QgPSByZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghcm9vdCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgeyBmcm9tOiBmcm9tLCB0YWJiYWJsZTogdGFiYmFibGUgPSBkZWZhdWx0T3B0aW9ucy50YWJiYWJsZSwgd3JhcDogd3JhcCA9IGRlZmF1bHRPcHRpb25zLndyYXAsIGFjY2VwdDogYWNjZXB0ID0gZGVmYXVsdE9wdGlvbnMuYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBmcm9tIHx8ICgwLCAkNm5mRkMkZ2V0T3duZXJEb2N1bWVudCkocm9vdCkuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGxldCB3YWxrZXIgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYShyb290LCB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGU6IHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogYWNjZXB0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyb290LmNvbnRhaW5zKG5vZGUpKSB3YWxrZXIuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkbGFzdCh3YWxrZXIpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KG5leHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0ICE9PSBudWxsICYmIG5leHQgIT09IHZvaWQgMCA/IG5leHQgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByZXZpb3VzTm9kZSA9IHdhbGtlci5wcmV2aW91c05vZGUoKTtcbiAgICAgICAgICAgIGlmICghcHJldmlvdXNOb2RlICYmIHdyYXApIHtcbiAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSByb290O1xuICAgICAgICAgICAgICAgIGxldCBsYXN0Tm9kZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRsYXN0KHdhbGtlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0Tm9kZSkgLy8gY291bGRuJ3Qgd3JhcFxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IGxhc3ROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZpb3VzTm9kZSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChwcmV2aW91c05vZGUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzTm9kZSAhPT0gbnVsbCAmJiBwcmV2aW91c05vZGUgIT09IHZvaWQgMCA/IHByZXZpb3VzTm9kZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzRmlyc3QgKG9wdHMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHJvb3QgPSByZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghcm9vdCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgeyB0YWJiYWJsZTogdGFiYmFibGUgPSBkZWZhdWx0T3B0aW9ucy50YWJiYWJsZSwgYWNjZXB0OiBhY2NlcHQgPSBkZWZhdWx0T3B0aW9ucy5hY2NlcHQgfSA9IG9wdHM7XG4gICAgICAgICAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEocm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChuZXh0Tm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzTGFzdCAob3B0cyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgICBsZXQgcm9vdCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFyb290KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCB7IHRhYmJhYmxlOiB0YWJiYWJsZSA9IGRlZmF1bHRPcHRpb25zLnRhYmJhYmxlLCBhY2NlcHQ6IGFjY2VwdCA9IGRlZmF1bHRPcHRpb25zLmFjY2VwdCB9ID0gb3B0cztcbiAgICAgICAgICAgIGxldCB3YWxrZXIgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYShyb290LCB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGU6IHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogYWNjZXB0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGxhc3Qod2Fsa2VyKTtcbiAgICAgICAgICAgIGlmIChuZXh0KSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KG5leHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQgIT09IG51bGwgJiYgbmV4dCAhPT0gdm9pZCAwID8gbmV4dCA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGxhc3Qod2Fsa2VyKSB7XG4gICAgbGV0IG5leHQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGxhc3Q7XG4gICAgZG8ge1xuICAgICAgICBsYXN0ID0gd2Fsa2VyLmxhc3RDaGlsZCgpO1xuICAgICAgICBpZiAobGFzdCkgbmV4dCA9IGxhc3Q7XG4gICAgfXdoaWxlIChsYXN0KTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbmNsYXNzICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRUcmVlIHtcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFzdE1hcC5zaXplO1xuICAgIH1cbiAgICBnZXRUcmVlTm9kZShkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhc3RNYXAuZ2V0KGRhdGEpO1xuICAgIH1cbiAgICBhZGRUcmVlTm9kZShzY29wZVJlZiwgcGFyZW50LCBub2RlVG9SZXN0b3JlKSB7XG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy5mYXN0TWFwLmdldChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50ICE9PSB2b2lkIDAgPyBwYXJlbnQgOiBudWxsKTtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSByZXR1cm47XG4gICAgICAgIGxldCBub2RlID0gbmV3ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRUcmVlTm9kZSh7XG4gICAgICAgICAgICBzY29wZVJlZjogc2NvcGVSZWZcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudE5vZGUuYWRkQ2hpbGQobm9kZSk7XG4gICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICAgICAgdGhpcy5mYXN0TWFwLnNldChzY29wZVJlZiwgbm9kZSk7XG4gICAgICAgIGlmIChub2RlVG9SZXN0b3JlKSBub2RlLm5vZGVUb1Jlc3RvcmUgPSBub2RlVG9SZXN0b3JlO1xuICAgIH1cbiAgICBhZGROb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5mYXN0TWFwLnNldChub2RlLnNjb3BlUmVmLCBub2RlKTtcbiAgICB9XG4gICAgcmVtb3ZlVHJlZU5vZGUoc2NvcGVSZWYpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVtb3ZlIHRoZSByb290XG4gICAgICAgIGlmIChzY29wZVJlZiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZmFzdE1hcC5nZXQoc2NvcGVSZWYpO1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgLy8gd2hlbiB3ZSByZW1vdmUgYSBzY29wZSwgY2hlY2sgaWYgYW55IHNpYmxpbmcgc2NvcGVzIGFyZSB0cnlpbmcgdG8gcmVzdG9yZSBmb2N1cyB0byBzb21ldGhpbmcgaW5zaWRlIHRoZSBzY29wZSB3ZSdyZSByZW1vdmluZ1xuICAgICAgICAvLyBpZiB3ZSBhcmUsIHRoZW4gcmVwbGFjZSB0aGUgc2libGluZ3MgcmVzdG9yZSB3aXRoIHRoZSByZXN0b3JlIGZyb20gdGhlIHNjb3BlIHdlJ3JlIHJlbW92aW5nXG4gICAgICAgIGZvciAobGV0IGN1cnJlbnQgb2YgdGhpcy50cmF2ZXJzZSgpKWlmIChjdXJyZW50ICE9PSBub2RlICYmIG5vZGUubm9kZVRvUmVzdG9yZSAmJiBjdXJyZW50Lm5vZGVUb1Jlc3RvcmUgJiYgbm9kZS5zY29wZVJlZiAmJiBub2RlLnNjb3BlUmVmLmN1cnJlbnQgJiYgJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUoY3VycmVudC5ub2RlVG9SZXN0b3JlLCBub2RlLnNjb3BlUmVmLmN1cnJlbnQpKSBjdXJyZW50Lm5vZGVUb1Jlc3RvcmUgPSBub2RlLm5vZGVUb1Jlc3RvcmU7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLnNpemUgPiAwKSBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCk9PnBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5hZGRDaGlsZChjaGlsZCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmFzdE1hcC5kZWxldGUobm9kZS5zY29wZVJlZik7XG4gICAgfVxuICAgIC8vIFByZSBPcmRlciBEZXB0aCBGaXJzdFxuICAgICp0cmF2ZXJzZShub2RlID0gdGhpcy5yb290KSB7XG4gICAgICAgIGlmIChub2RlLnNjb3BlUmVmICE9IG51bGwpIHlpZWxkIG5vZGU7XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLnNpemUgPiAwKSBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKXlpZWxkKiB0aGlzLnRyYXZlcnNlKGNoaWxkKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBfbm9kZV9wYXJlbnQ7XG4gICAgICAgIGxldCBuZXdUcmVlID0gbmV3ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRUcmVlKCk7XG4gICAgICAgIHZhciBfbm9kZV9wYXJlbnRfc2NvcGVSZWY7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy50cmF2ZXJzZSgpKW5ld1RyZWUuYWRkVHJlZU5vZGUobm9kZS5zY29wZVJlZiwgKF9ub2RlX3BhcmVudF9zY29wZVJlZiA9IChfbm9kZV9wYXJlbnQgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX25vZGVfcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZV9wYXJlbnQuc2NvcGVSZWYpICE9PSBudWxsICYmIF9ub2RlX3BhcmVudF9zY29wZVJlZiAhPT0gdm9pZCAwID8gX25vZGVfcGFyZW50X3Njb3BlUmVmIDogbnVsbCwgbm9kZS5ub2RlVG9SZXN0b3JlKTtcbiAgICAgICAgcmV0dXJuIG5ld1RyZWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuZmFzdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yb290ID0gbmV3ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRUcmVlTm9kZSh7XG4gICAgICAgICAgICBzY29wZVJlZjogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mYXN0TWFwLnNldChudWxsLCB0aGlzLnJvb3QpO1xuICAgIH1cbn1cbmNsYXNzICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRUcmVlTm9kZSB7XG4gICAgYWRkQ2hpbGQobm9kZSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmFkZChub2RlKTtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZGVsZXRlKG5vZGUpO1xuICAgICAgICBub2RlLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY29wZVJlZiA9IHByb3BzLnNjb3BlUmVmO1xuICAgIH1cbn1cbmxldCAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZSA9IG5ldyAkOWJmNzFlYTI4NzkzZTczOCR2YXIkVHJlZSgpO1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cblxuZnVuY3Rpb24gJGY3ZGNlZmZjNWFkNzc2OGIkZXhwb3J0JDRlMzI4ZjYxYzUzODY4N2YocHJvcHMgPSB7fSkge1xuICAgIGxldCB7IGF1dG9Gb2N1czogYXV0b0ZvY3VzID0gZmFsc2UsIGlzVGV4dElucHV0OiBpc1RleHRJbnB1dCwgd2l0aGluOiB3aXRoaW4gfSA9IHByb3BzO1xuICAgIGxldCBzdGF0ZSA9ICgwLCAkNm5mRkMkdXNlUmVmKSh7XG4gICAgICAgIGlzRm9jdXNlZDogZmFsc2UsXG4gICAgICAgIGlzRm9jdXNWaXNpYmxlOiBhdXRvRm9jdXMgfHwgKDAsICQ2bmZGQyRpc0ZvY3VzVmlzaWJsZSkoKVxuICAgIH0pO1xuICAgIGxldCBbaXNGb2N1c2VkLCBzZXRGb2N1c2VkXSA9ICgwLCAkNm5mRkMkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgW2lzRm9jdXNWaXNpYmxlU3RhdGUsIHNldEZvY3VzVmlzaWJsZV0gPSAoMCwgJDZuZkZDJHVzZVN0YXRlKSgoKT0+c3RhdGUuY3VycmVudC5pc0ZvY3VzZWQgJiYgc3RhdGUuY3VycmVudC5pc0ZvY3VzVmlzaWJsZSk7XG4gICAgbGV0IHVwZGF0ZVN0YXRlID0gKDAsICQ2bmZGQyR1c2VDYWxsYmFjaykoKCk9PnNldEZvY3VzVmlzaWJsZShzdGF0ZS5jdXJyZW50LmlzRm9jdXNlZCAmJiBzdGF0ZS5jdXJyZW50LmlzRm9jdXNWaXNpYmxlKSwgW10pO1xuICAgIGxldCBvbkZvY3VzQ2hhbmdlID0gKDAsICQ2bmZGQyR1c2VDYWxsYmFjaykoKGlzRm9jdXNlZCk9PntcbiAgICAgICAgc3RhdGUuY3VycmVudC5pc0ZvY3VzZWQgPSBpc0ZvY3VzZWQ7XG4gICAgICAgIHNldEZvY3VzZWQoaXNGb2N1c2VkKTtcbiAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICB9LCBbXG4gICAgICAgIHVwZGF0ZVN0YXRlXG4gICAgXSk7XG4gICAgKDAsICQ2bmZGQyR1c2VGb2N1c1Zpc2libGVMaXN0ZW5lcikoKGlzRm9jdXNWaXNpYmxlKT0+e1xuICAgICAgICBzdGF0ZS5jdXJyZW50LmlzRm9jdXNWaXNpYmxlID0gaXNGb2N1c1Zpc2libGU7XG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgfSwgW10sIHtcbiAgICAgICAgaXNUZXh0SW5wdXQ6IGlzVGV4dElucHV0XG4gICAgfSk7XG4gICAgbGV0IHsgZm9jdXNQcm9wczogZm9jdXNQcm9wcyB9ID0gKDAsICQ2bmZGQyR1c2VGb2N1cykoe1xuICAgICAgICBpc0Rpc2FibGVkOiB3aXRoaW4sXG4gICAgICAgIG9uRm9jdXNDaGFuZ2U6IG9uRm9jdXNDaGFuZ2VcbiAgICB9KTtcbiAgICBsZXQgeyBmb2N1c1dpdGhpblByb3BzOiBmb2N1c1dpdGhpblByb3BzIH0gPSAoMCwgJDZuZkZDJHVzZUZvY3VzV2l0aGluKSh7XG4gICAgICAgIGlzRGlzYWJsZWQ6ICF3aXRoaW4sXG4gICAgICAgIG9uRm9jdXNXaXRoaW5DaGFuZ2U6IG9uRm9jdXNDaGFuZ2VcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0ZvY3VzZWQ6IGlzRm9jdXNlZCxcbiAgICAgICAgaXNGb2N1c1Zpc2libGU6IGlzRm9jdXNWaXNpYmxlU3RhdGUsXG4gICAgICAgIGZvY3VzUHJvcHM6IHdpdGhpbiA/IGZvY3VzV2l0aGluUHJvcHMgOiBmb2N1c1Byb3BzXG4gICAgfTtcbn1cblxuXG5mdW5jdGlvbiAkOTA3NzE4NzA4ZWFiNjhhZiRleHBvcnQkMWEzOGI0YWQ3ZjU3OGUxZChwcm9wcykge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgZm9jdXNDbGFzczogZm9jdXNDbGFzcywgZm9jdXNSaW5nQ2xhc3M6IGZvY3VzUmluZ0NsYXNzIH0gPSBwcm9wcztcbiAgICBsZXQgeyBpc0ZvY3VzZWQ6IGlzRm9jdXNlZCwgaXNGb2N1c1Zpc2libGU6IGlzRm9jdXNWaXNpYmxlLCBmb2N1c1Byb3BzOiBmb2N1c1Byb3BzIH0gPSAoMCwgJGY3ZGNlZmZjNWFkNzc2OGIkZXhwb3J0JDRlMzI4ZjYxYzUzODY4N2YpKHByb3BzKTtcbiAgICBsZXQgY2hpbGQgPSAoMCwgJDZuZkZDJHJlYWN0KS5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDZuZkZDJHJlYWN0KS5jbG9uZUVsZW1lbnQoY2hpbGQsICgwLCAkNm5mRkMkbWVyZ2VQcm9wcykoY2hpbGQucHJvcHMsIHtcbiAgICAgICAgLi4uZm9jdXNQcm9wcyxcbiAgICAgICAgY2xhc3NOYW1lOiAoMCwgJDZuZkZDJGNsc3gpKHtcbiAgICAgICAgICAgIFtmb2N1c0NsYXNzIHx8IFwiXCJdOiBpc0ZvY3VzZWQsXG4gICAgICAgICAgICBbZm9jdXNSaW5nQ2xhc3MgfHwgXCJcIl06IGlzRm9jdXNWaXNpYmxlXG4gICAgICAgIH0pXG4gICAgfSkpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cbmxldCAkZTZhZmJkODNmZTZlYmJkMiR2YXIkRm9jdXNhYmxlQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQ2bmZGQyRyZWFjdCkuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uICRlNmFmYmQ4M2ZlNmViYmQyJHZhciR1c2VGb2N1c2FibGVDb250ZXh0KHJlZikge1xuICAgIGxldCBjb250ZXh0ID0gKDAsICQ2bmZGQyR1c2VDb250ZXh0KSgkZTZhZmJkODNmZTZlYmJkMiR2YXIkRm9jdXNhYmxlQ29udGV4dCkgfHwge307XG4gICAgKDAsICQ2bmZGQyR1c2VTeW5jUmVmKShjb250ZXh0LCByZWYpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGxldCB7IHJlZjogXywgLi4ub3RoZXJQcm9wcyB9ID0gY29udGV4dDtcbiAgICByZXR1cm4gb3RoZXJQcm9wcztcbn1cbi8qKlxuICogUHJvdmlkZXMgRE9NIHByb3BzIHRvIHRoZSBuZWFyZXN0IGZvY3VzYWJsZSBjaGlsZC5cbiAqLyBmdW5jdGlvbiAkZTZhZmJkODNmZTZlYmJkMiR2YXIkRm9jdXNhYmxlUHJvdmlkZXIocHJvcHMsIHJlZikge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgLi4ub3RoZXJQcm9wcyB9ID0gcHJvcHM7XG4gICAgbGV0IG9ialJlZiA9ICgwLCAkNm5mRkMkdXNlT2JqZWN0UmVmKShyZWYpO1xuICAgIGxldCBjb250ZXh0ID0ge1xuICAgICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgICByZWY6IG9ialJlZlxuICAgIH07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ2bmZGQyRyZWFjdCkuY3JlYXRlRWxlbWVudCgkZTZhZmJkODNmZTZlYmJkMiR2YXIkRm9jdXNhYmxlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dFxuICAgIH0sIGNoaWxkcmVuKTtcbn1cbmxldCAkZTZhZmJkODNmZTZlYmJkMiRleHBvcnQkMTNmMzIwMmEzZTVkZGQ1ID0gLyojX19QVVJFX18qLyAoMCwgJDZuZkZDJHJlYWN0KS5mb3J3YXJkUmVmKCRlNmFmYmQ4M2ZlNmViYmQyJHZhciRGb2N1c2FibGVQcm92aWRlcik7XG5mdW5jdGlvbiAkZTZhZmJkODNmZTZlYmJkMiRleHBvcnQkNGMwMTRkZTdjODk0MGI0Yyhwcm9wcywgZG9tUmVmKSB7XG4gICAgbGV0IHsgZm9jdXNQcm9wczogZm9jdXNQcm9wcyB9ID0gKDAsICQ2bmZGQyR1c2VGb2N1cykocHJvcHMpO1xuICAgIGxldCB7IGtleWJvYXJkUHJvcHM6IGtleWJvYXJkUHJvcHMgfSA9ICgwLCAkNm5mRkMkdXNlS2V5Ym9hcmQpKHByb3BzKTtcbiAgICBsZXQgaW50ZXJhY3Rpb25zID0gKDAsICQ2bmZGQyRtZXJnZVByb3BzKShmb2N1c1Byb3BzLCBrZXlib2FyZFByb3BzKTtcbiAgICBsZXQgZG9tUHJvcHMgPSAkZTZhZmJkODNmZTZlYmJkMiR2YXIkdXNlRm9jdXNhYmxlQ29udGV4dChkb21SZWYpO1xuICAgIGxldCBpbnRlcmFjdGlvblByb3BzID0gcHJvcHMuaXNEaXNhYmxlZCA/IHt9IDogZG9tUHJvcHM7XG4gICAgbGV0IGF1dG9Gb2N1c1JlZiA9ICgwLCAkNm5mRkMkdXNlUmVmKShwcm9wcy5hdXRvRm9jdXMpO1xuICAgICgwLCAkNm5mRkMkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoYXV0b0ZvY3VzUmVmLmN1cnJlbnQgJiYgZG9tUmVmLmN1cnJlbnQpICgwLCAkNmE5OTE5NTMzMmVkZWM4YiRleHBvcnQkODBmM2UxNDdkNzgxNTcxYykoZG9tUmVmLmN1cnJlbnQpO1xuICAgICAgICBhdXRvRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH0sIFtcbiAgICAgICAgZG9tUmVmXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNhYmxlUHJvcHM6ICgwLCAkNm5mRkMkbWVyZ2VQcm9wcykoe1xuICAgICAgICAgICAgLi4uaW50ZXJhY3Rpb25zLFxuICAgICAgICAgICAgdGFiSW5kZXg6IHByb3BzLmV4Y2x1ZGVGcm9tVGFiT3JkZXIgJiYgIXByb3BzLmlzRGlzYWJsZWQgPyAtMSA6IHVuZGVmaW5lZFxuICAgICAgICB9LCBpbnRlcmFjdGlvblByb3BzKVxuICAgIH07XG59XG5cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkODMwMTM2MzViMDI0YWUzZCRleHBvcnQkZWFjMTg5NTk5MmI5ZjNkNihyZWYsIG9wdGlvbnMpIHtcbiAgICBsZXQgaXNEaXNhYmxlZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pc0Rpc2FibGVkO1xuICAgIGxldCBbaGFzVGFiYmFibGVDaGlsZCwgc2V0SGFzVGFiYmFibGVDaGlsZF0gPSAoMCwgJDZuZkZDJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgKDAsICQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmICgocmVmID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmN1cnJlbnQpICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gKCk9PntcbiAgICAgICAgICAgICAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdhbGtlciA9ICgwLCAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYSkocmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRIYXNUYWJiYWJsZUNoaWxkKCEhd2Fsa2VyLm5leHROb2RlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB3aGVuIG5ldyBlbGVtZW50cyBhcmUgaW5zZXJ0ZWQsIG9yIHRoZSB0YWJJbmRleC9kaXNhYmxlZCBhdHRyaWJ1dGUgdXBkYXRlcy5cbiAgICAgICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHVwZGF0ZSk7XG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJ0YWJJbmRleFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgbXV0YXRpb24gb2JzZXJ2ZXIgd2hlbiBhIFJlYWN0IHVwZGF0ZSBvY2N1cnMgb24gdGhlIHRvcC1sZXZlbCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSB1cGRhdGUgc3luY2hyb25vdXNseSBhZnRlciByZS1yZW5kZXJpbmcuIE90aGVyd2lzZSBSZWFjdCB3aWxsIGVtaXQgYWN0IHdhcm5pbmdzXG4gICAgICAgICAgICAgICAgLy8gaW4gdGVzdHMgc2luY2UgbXV0YXRpb24gb2JzZXJ2ZXJzIGZpcmUgYXN5bmNocm9ub3VzbHkuIFRoZSBtdXRhdGlvbiBvYnNlcnZlciBpcyBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBhbHNvIHVwZGF0ZSBpZiBhIGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXJzIGFuZCBhZGRzL3JlbW92ZXMgc29tZXRoaW5nIHRhYmJhYmxlLlxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXNEaXNhYmxlZCA/IGZhbHNlIDogaGFzVGFiYmFibGVDaGlsZDtcbn1cblxuXG5cblxuZXhwb3J0IHskOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMjBlNDAyODk2NDFmYmJiNiBhcyBGb2N1c1Njb3BlLCAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMTBjNTE2OTc1NWNlN2JkNyBhcyB1c2VGb2N1c01hbmFnZXIsICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhIGFzIGdldEZvY3VzYWJsZVRyZWVXYWxrZXIsICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRjNTI1MWI5ZTEyNGJmMjkgYXMgY3JlYXRlRm9jdXNNYW5hZ2VyLCAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMTI1ODM5NWY5OWJmOWNiZiBhcyBpc0VsZW1lbnRJbkNoaWxkT2ZBY3RpdmVTY29wZSwgJDkwNzcxODcwOGVhYjY4YWYkZXhwb3J0JDFhMzhiNGFkN2Y1NzhlMWQgYXMgRm9jdXNSaW5nLCAkZTZhZmJkODNmZTZlYmJkMiRleHBvcnQkMTNmMzIwMmEzZTVkZGQ1IGFzIEZvY3VzYWJsZVByb3ZpZGVyLCAkZTZhZmJkODNmZTZlYmJkMiRleHBvcnQkNGMwMTRkZTdjODk0MGI0YyBhcyB1c2VGb2N1c2FibGUsICRmN2RjZWZmYzVhZDc3NjhiJGV4cG9ydCQ0ZTMyOGY2MWM1Mzg2ODdmIGFzIHVzZUZvY3VzUmluZywgJDZhOTkxOTUzMzJlZGVjOGIkZXhwb3J0JDgwZjNlMTQ3ZDc4MTU3MWMgYXMgZm9jdXNTYWZlbHksICQ4MzAxMzYzNWIwMjRhZTNkJGV4cG9ydCRlYWMxODk1OTkyYjlmM2Q2IGFzIHVzZUhhc1RhYmJhYmxlQ2hpbGR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUxheW91dEVmZmVjdCIsIiQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QiLCJnZXRPd25lckRvY3VtZW50IiwiJDZuZkZDJGdldE93bmVyRG9jdW1lbnQiLCJydW5BZnRlclRyYW5zaXRpb24iLCIkNm5mRkMkcnVuQWZ0ZXJUcmFuc2l0aW9uIiwiZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwiJDZuZkZDJGZvY3VzV2l0aG91dFNjcm9sbGluZyIsImdldE93bmVyV2luZG93IiwiJDZuZkZDJGdldE93bmVyV2luZG93IiwibWVyZ2VQcm9wcyIsIiQ2bmZGQyRtZXJnZVByb3BzIiwidXNlU3luY1JlZiIsIiQ2bmZGQyR1c2VTeW5jUmVmIiwidXNlT2JqZWN0UmVmIiwiJDZuZkZDJHVzZU9iamVjdFJlZiIsIiQ2bmZGQyRyZWFjdCIsInVzZVJlZiIsIiQ2bmZGQyR1c2VSZWYiLCJ1c2VDb250ZXh0IiwiJDZuZkZDJHVzZUNvbnRleHQiLCJ1c2VNZW1vIiwiJDZuZkZDJHVzZU1lbW8iLCJ1c2VFZmZlY3QiLCIkNm5mRkMkdXNlRWZmZWN0IiwidXNlU3RhdGUiLCIkNm5mRkMkdXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsIiQ2bmZGQyR1c2VDYWxsYmFjayIsImdldEludGVyYWN0aW9uTW9kYWxpdHkiLCIkNm5mRkMkZ2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSIsImlzRm9jdXNWaXNpYmxlIiwiJDZuZkZDJGlzRm9jdXNWaXNpYmxlIiwidXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIiLCIkNm5mRkMkdXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIiLCJ1c2VGb2N1cyIsIiQ2bmZGQyR1c2VGb2N1cyIsInVzZUZvY3VzV2l0aGluIiwiJDZuZkZDJHVzZUZvY3VzV2l0aGluIiwidXNlS2V5Ym9hcmQiLCIkNm5mRkMkdXNlS2V5Ym9hcmQiLCIkNm5mRkMkY2xzeCIsIiQ2YTk5MTk1MzMyZWRlYzhiJGV4cG9ydCQ4MGYzZTE0N2Q3ODE1NzFjIiwiZWxlbWVudCIsIm93bmVyRG9jdW1lbnQiLCJsYXN0Rm9jdXNlZEVsZW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCIkNjQ1ZjJlNjdiODVhMjRjOSR2YXIkaXNTdHlsZVZpc2libGUiLCJ3aW5kb3dPYmplY3QiLCJIVE1MRWxlbWVudCIsIlNWR0VsZW1lbnQiLCJkaXNwbGF5IiwidmlzaWJpbGl0eSIsInN0eWxlIiwiaXNWaXNpYmxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImRlZmF1bHRWaWV3IiwiY29tcHV0ZWREaXNwbGF5IiwiY29tcHV0ZWRWaXNpYmlsaXR5IiwiJDY0NWYyZTY3Yjg1YTI0YzkkdmFyJGlzQXR0cmlidXRlVmlzaWJsZSIsImNoaWxkRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsIm5vZGVOYW1lIiwiJDY0NWYyZTY3Yjg1YTI0YzkkZXhwb3J0JGU5ODljMGZmZmFhNmIyN2EiLCJwYXJlbnRFbGVtZW50IiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJEZvY3VzQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUiLCIkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMjBlNDAyODk2NDFmYmJiNiIsInByb3BzIiwiY2hpbGRyZW4iLCJjb250YWluIiwicmVzdG9yZUZvY3VzIiwiYXV0b0ZvY3VzIiwic3RhcnRSZWYiLCJlbmRSZWYiLCJzY29wZVJlZiIsInBhcmVudE5vZGUiLCJub2RlIiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJFRyZWVOb2RlIiwicGFyZW50IiwiJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUiLCJyb290IiwiZ2V0VHJlZU5vZGUiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNBbmNlc3RvclNjb3BlIiwiYWN0aXZlTm9kZSIsImFkZENoaWxkIiwiYWRkTm9kZSIsIl9zdGFydFJlZl9jdXJyZW50IiwiY3VycmVudCIsIm5leHRTaWJsaW5nIiwibm9kZXMiLCJwdXNoIiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZUFjdGl2ZVNjb3BlVHJhY2tlciIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciR1c2VGb2N1c0NvbnRhaW5tZW50IiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZVJlc3RvcmVGb2N1cyIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciR1c2VBdXRvRm9jdXMiLCJ1bmRlZmluZWQiLCJzY29wZSIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlIiwidHJhdmVyc2UiLCJfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50IiwiX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlIiwiX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlX3BhcmVudF9zY29wZVJlZiIsInBhcmVudFNjb3BlIiwicmVtb3ZlVHJlZU5vZGUiLCJmb2N1c01hbmFnZXIiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkY3JlYXRlRm9jdXNNYW5hZ2VyRm9yU2NvcGUiLCJ2YWx1ZSIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsImhpZGRlbiIsInJlZiIsIiQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQxMGM1MTY5NzU1Y2U3YmQ3IiwiX3VzZUNvbnRleHQiLCJmb2N1c05leHQiLCJvcHRzIiwiZnJvbSIsInRhYmJhYmxlIiwid3JhcCIsImFjY2VwdCIsInNlbnRpbmVsIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInNjb3BlUm9vdCIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3QiLCJ3YWxrZXIiLCIkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYSIsImN1cnJlbnROb2RlIiwibmV4dE5vZGUiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50IiwiZm9jdXNQcmV2aW91cyIsImxlbmd0aCIsIm5leHRFbGVtZW50U2libGluZyIsInByZXZpb3VzTm9kZSIsImZvY3VzRmlyc3QiLCJmb2N1c0xhc3QiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNhYmxlRWxlbWVudHMiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkRk9DVVNBQkxFX0VMRU1FTlRfU0VMRUNUT1IiLCJqb2luIiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJFRBQkJBQkxFX0VMRU1FTlRfU0VMRUNUT1IiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkQ29udGFpbkZvY3VzIiwiZm9jdXNlZE5vZGUiLCJyYWYiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm9uS2V5RG93biIsImUiLCJrZXkiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsImZvY3VzZWRFbGVtZW50IiwibmV4dEVsZW1lbnQiLCJzaGlmdEtleSIsInByZXZlbnREZWZhdWx0Iiwib25Gb2N1cyIsInRhcmdldCIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJbkNoaWxkU2NvcGUiLCJmb2N1cyIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0ZpcnN0SW5TY29wZSIsIm9uQmx1ciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJvZHkiLCJjb250YWlucyIsIl9mb2N1c2VkTm9kZV9jdXJyZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImZvckVhY2giLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluQW55U2NvcGUiLCJzb21lIiwiRWxlbWVudCIsImNsb3Nlc3QiLCJzIiwiJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDEyNTgzOTVmOTliZjljYmYiLCJhbmNlc3RvciIsInNjcm9sbCIsImVyciIsImF1dG9Gb2N1c1JlZiIsInJlc3RvcmUiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkUmVzdG9yZUZvY3VzIiwibm9kZVRvUmVzdG9yZSIsIm5vZGVUb1Jlc3RvcmVSZWYiLCJkb2N1bWVudCIsInRyZWVOb2RlIiwic3RvcFByb3BhZ2F0aW9uIiwiYmx1ciIsIl9ub2RlVG9SZXN0b3JlUmVmX2N1cnJlbnQiLCJjbG9uZWRUcmVlIiwiY2xvbmUiLCJzZWxlY3RvciIsImNyZWF0ZVRyZWVXYWxrZXIiLCJOb2RlRmlsdGVyIiwiU0hPV19FTEVNRU5UIiwiYWNjZXB0Tm9kZSIsIl9vcHRzX2Zyb20iLCJGSUxURVJfUkVKRUNUIiwibWF0Y2hlcyIsIkZJTFRFUl9BQ0NFUFQiLCJGSUxURVJfU0tJUCIsIiQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRjNTI1MWI5ZTEyNGJmMjkiLCJkZWZhdWx0T3B0aW9ucyIsIm5leHQiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkbGFzdCIsImxhc3ROb2RlIiwibGFzdCIsImxhc3RDaGlsZCIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRUcmVlIiwic2l6ZSIsImZhc3RNYXAiLCJkYXRhIiwiZ2V0IiwiYWRkVHJlZU5vZGUiLCJzZXQiLCJyZW1vdmVDaGlsZCIsImNoaWxkIiwiZGVsZXRlIiwiX25vZGVfcGFyZW50IiwibmV3VHJlZSIsIl9ub2RlX3BhcmVudF9zY29wZVJlZiIsImNvbnN0cnVjdG9yIiwiTWFwIiwiYWRkIiwiU2V0IiwiJGY3ZGNlZmZjNWFkNzc2OGIkZXhwb3J0JDRlMzI4ZjYxYzUzODY4N2YiLCJpc1RleHRJbnB1dCIsIndpdGhpbiIsInN0YXRlIiwiaXNGb2N1c2VkIiwic2V0Rm9jdXNlZCIsImlzRm9jdXNWaXNpYmxlU3RhdGUiLCJzZXRGb2N1c1Zpc2libGUiLCJ1cGRhdGVTdGF0ZSIsIm9uRm9jdXNDaGFuZ2UiLCJmb2N1c1Byb3BzIiwiaXNEaXNhYmxlZCIsImZvY3VzV2l0aGluUHJvcHMiLCJvbkZvY3VzV2l0aGluQ2hhbmdlIiwiJDkwNzcxODcwOGVhYjY4YWYkZXhwb3J0JDFhMzhiNGFkN2Y1NzhlMWQiLCJmb2N1c0NsYXNzIiwiZm9jdXNSaW5nQ2xhc3MiLCJDaGlsZHJlbiIsIm9ubHkiLCJjbG9uZUVsZW1lbnQiLCJjbGFzc05hbWUiLCIkZTZhZmJkODNmZTZlYmJkMiR2YXIkRm9jdXNhYmxlQ29udGV4dCIsIiRlNmFmYmQ4M2ZlNmViYmQyJHZhciR1c2VGb2N1c2FibGVDb250ZXh0IiwiY29udGV4dCIsIl8iLCJvdGhlclByb3BzIiwiJGU2YWZiZDgzZmU2ZWJiZDIkdmFyJEZvY3VzYWJsZVByb3ZpZGVyIiwib2JqUmVmIiwiJGU2YWZiZDgzZmU2ZWJiZDIkZXhwb3J0JDEzZjMyMDJhM2U1ZGRkNSIsImZvcndhcmRSZWYiLCIkZTZhZmJkODNmZTZlYmJkMiRleHBvcnQkNGMwMTRkZTdjODk0MGI0YyIsImRvbVJlZiIsImtleWJvYXJkUHJvcHMiLCJpbnRlcmFjdGlvbnMiLCJkb21Qcm9wcyIsImludGVyYWN0aW9uUHJvcHMiLCJmb2N1c2FibGVQcm9wcyIsInRhYkluZGV4IiwiZXhjbHVkZUZyb21UYWJPcmRlciIsIiQ4MzAxMzYzNWIwMjRhZTNkJGV4cG9ydCRlYWMxODk1OTkyYjlmM2Q2Iiwib3B0aW9ucyIsImhhc1RhYmJhYmxlQ2hpbGQiLCJzZXRIYXNUYWJiYWJsZUNoaWxkIiwidXBkYXRlIiwib2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsInN1YnRyZWUiLCJjaGlsZExpc3QiLCJhdHRyaWJ1dGVzIiwiYXR0cmlidXRlRmlsdGVyIiwiZGlzY29ubmVjdCIsIkZvY3VzU2NvcGUiLCJ1c2VGb2N1c01hbmFnZXIiLCJnZXRGb2N1c2FibGVUcmVlV2Fsa2VyIiwiY3JlYXRlRm9jdXNNYW5hZ2VyIiwiaXNFbGVtZW50SW5DaGlsZE9mQWN0aXZlU2NvcGUiLCJGb2N1c1JpbmciLCJGb2N1c2FibGVQcm92aWRlciIsInVzZUZvY3VzYWJsZSIsInVzZUZvY3VzUmluZyIsImZvY3VzU2FmZWx5IiwidXNlSGFzVGFiYmFibGVDaGlsZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/focus/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/import.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/import.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClearPressResponder: () => (/* binding */ $f1ab8c75478c6f73$export$cf75428e0b9ed1ea),\n/* harmony export */   PressResponder: () => (/* binding */ $f1ab8c75478c6f73$export$3351871ee4b288b8),\n/* harmony export */   Pressable: () => (/* binding */ $3b117e43dc0ca95d$export$27c701ed9e449e99),\n/* harmony export */   getInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$630ff653c5ada6a9),\n/* harmony export */   isFocusVisible: () => (/* binding */ $507fabe10e71c6fb$export$b9b3dfddab17db27),\n/* harmony export */   setInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$8397ddfc504fdb9a),\n/* harmony export */   useFocus: () => (/* binding */ $a1ea59d68270f0dd$export$f8168d8dd8fd66e6),\n/* harmony export */   useFocusVisible: () => (/* binding */ $507fabe10e71c6fb$export$ffd9e5021c1fb2d6),\n/* harmony export */   useFocusVisibleListener: () => (/* binding */ $507fabe10e71c6fb$export$ec71b4b83ac08ec3),\n/* harmony export */   useFocusWithin: () => (/* binding */ $9ab94262bd0047c7$export$420e68273165f4ec),\n/* harmony export */   useHover: () => (/* binding */ $6179b936705e76d3$export$ae780daf29e6d456),\n/* harmony export */   useInteractOutside: () => (/* binding */ $e0b6e0b68ec7f50f$export$872b660ac5a1ff98),\n/* harmony export */   useInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$98e20ec92f614cfe),\n/* harmony export */   useKeyboard: () => (/* binding */ $46d819fcbaf35654$export$8f71654801c2f7cd),\n/* harmony export */   useLongPress: () => (/* binding */ $8a26561d2877236e$export$c24ed0104d07eab9),\n/* harmony export */   useMove: () => (/* binding */ $e8a7022cf87cba2a$export$36da96379f79f245),\n/* harmony export */   usePress: () => (/* binding */ $f6c31cce2adf654f$export$45712eceda6fad21),\n/* harmony export */   useScrollWheel: () => (/* binding */ $7d0a636d7a4dcefd$export$2123ff2b87c81ca)\n/* harmony export */ });\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(ssr)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(ssr)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(ssr)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/./node_modules/@react-aria/focus/node_modules/@react-aria/ssr/dist/import.mjs\");\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element\n// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually\nlet $14c0b72509d70225$var$state = \"default\";\nlet $14c0b72509d70225$var$savedUserSelect = \"\";\nlet $14c0b72509d70225$var$modifiedElementMap = new WeakMap();\nfunction $14c0b72509d70225$export$16a4697467175487(target) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isIOS)()) {\n        if ($14c0b72509d70225$var$state === \"default\") {\n            // eslint-disable-next-line no-restricted-globals\n            const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(target);\n            $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;\n            documentObject.documentElement.style.webkitUserSelect = \"none\";\n        }\n        $14c0b72509d70225$var$state = \"disabled\";\n    } else if (target instanceof HTMLElement || target instanceof SVGElement) {\n        // If not iOS, store the target's original user-select and change to user-select: none\n        // Ignore state since it doesn't apply for non iOS\n        $14c0b72509d70225$var$modifiedElementMap.set(target, target.style.userSelect);\n        target.style.userSelect = \"none\";\n    }\n}\nfunction $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isIOS)()) {\n        // If the state is already default, there's nothing to do.\n        // If it is restoring, then there's no need to queue a second restore.\n        if ($14c0b72509d70225$var$state !== \"disabled\") return;\n        $14c0b72509d70225$var$state = \"restoring\";\n        // There appears to be a delay on iOS where selection still might occur\n        // after pointer up, so wait a bit before removing user-select.\n        setTimeout(()=>{\n            // Wait for any CSS transitions to complete so we don't recompute style\n            // for the whole page in the middle of the animation and cause jank.\n            (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.runAfterTransition)(()=>{\n                // Avoid race conditions\n                if ($14c0b72509d70225$var$state === \"restoring\") {\n                    // eslint-disable-next-line no-restricted-globals\n                    const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(target);\n                    if (documentObject.documentElement.style.webkitUserSelect === \"none\") documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || \"\";\n                    $14c0b72509d70225$var$savedUserSelect = \"\";\n                    $14c0b72509d70225$var$state = \"default\";\n                }\n            });\n        }, 300);\n    } else if (target instanceof HTMLElement || target instanceof SVGElement) // Ignore state since it doesn't apply for non iOS\n    {\n        if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {\n            let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);\n            if (target.style.userSelect === \"none\") target.style.userSelect = targetOldUserSelect;\n            if (target.getAttribute(\"style\") === \"\") target.removeAttribute(\"style\");\n            $14c0b72509d70225$var$modifiedElementMap.delete(target);\n        }\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext({\n    register: ()=>{}\n});\n$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = \"PressResponderContext\";\nfunction $f6c31cce2adf654f$var$usePressResponderContext(props) {\n    // Consume context from <PressResponder> and merge with props.\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n    if (context) {\n        let { register: register, ...contextProps } = context;\n        props = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(contextProps, props);\n        register();\n    }\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useSyncRef)(context, props.ref);\n    return props;\n}\nvar $f6c31cce2adf654f$var$_shouldStopPropagation = /*#__PURE__*/ new WeakMap();\nclass $f6c31cce2adf654f$var$PressEvent {\n    continuePropagation() {\n        (0, _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);\n    }\n    get shouldStopPropagation() {\n        return (0, _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);\n    }\n    constructor(type, pointerType, originalEvent){\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {\n            writable: true,\n            value: void 0\n        });\n        (0, _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);\n        this.type = type;\n        this.pointerType = pointerType;\n        this.target = originalEvent.currentTarget;\n        this.shiftKey = originalEvent.shiftKey;\n        this.metaKey = originalEvent.metaKey;\n        this.ctrlKey = originalEvent.ctrlKey;\n        this.altKey = originalEvent.altKey;\n    }\n}\nconst $f6c31cce2adf654f$var$LINK_CLICKED = Symbol(\"linkClicked\");\nfunction $f6c31cce2adf654f$export$45712eceda6fad21(props) {\n    let { onPress: onPress, onPressChange: onPressChange, onPressStart: onPressStart, onPressEnd: onPressEnd, onPressUp: onPressUp, isDisabled: isDisabled, isPressed: isPressedProp, preventFocusOnPress: preventFocusOnPress, shouldCancelOnPointerExit: shouldCancelOnPointerExit, allowTextSelectionOnPress: allowTextSelectionOnPress, ref: _, ...domProps } = $f6c31cce2adf654f$var$usePressResponderContext(props);\n    let [isPressed, setPressed] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isPressed: false,\n        ignoreEmulatedMouseEvents: false,\n        ignoreClickAfterPress: false,\n        didFirePressStart: false,\n        isTriggeringEvent: false,\n        activePointerId: null,\n        target: null,\n        isOverTarget: false,\n        pointerType: null\n    });\n    let { addGlobalListener: addGlobalListener, removeAllGlobalListeners: removeAllGlobalListeners } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let triggerPressStart = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        let state = ref.current;\n        if (isDisabled || state.didFirePressStart) return false;\n        let shouldStopPropagation = true;\n        state.isTriggeringEvent = true;\n        if (onPressStart) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressstart\", pointerType, originalEvent);\n            onPressStart(event);\n            shouldStopPropagation = event.shouldStopPropagation;\n        }\n        if (onPressChange) onPressChange(true);\n        state.isTriggeringEvent = false;\n        state.didFirePressStart = true;\n        setPressed(true);\n        return shouldStopPropagation;\n    });\n    let triggerPressEnd = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{\n        let state = ref.current;\n        if (!state.didFirePressStart) return false;\n        state.ignoreClickAfterPress = true;\n        state.didFirePressStart = false;\n        state.isTriggeringEvent = true;\n        let shouldStopPropagation = true;\n        if (onPressEnd) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressend\", pointerType, originalEvent);\n            onPressEnd(event);\n            shouldStopPropagation = event.shouldStopPropagation;\n        }\n        if (onPressChange) onPressChange(false);\n        setPressed(false);\n        if (onPress && wasPressed && !isDisabled) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"press\", pointerType, originalEvent);\n            onPress(event);\n            shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\n        }\n        state.isTriggeringEvent = false;\n        return shouldStopPropagation;\n    });\n    let triggerPressUp = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        let state = ref.current;\n        if (isDisabled) return false;\n        if (onPressUp) {\n            state.isTriggeringEvent = true;\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressup\", pointerType, originalEvent);\n            onPressUp(event);\n            state.isTriggeringEvent = false;\n            return event.shouldStopPropagation;\n        }\n        return true;\n    });\n    let cancel = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        let state = ref.current;\n        if (state.isPressed && state.target) {\n            if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n            state.isPressed = false;\n            state.isOverTarget = false;\n            state.activePointerId = null;\n            state.pointerType = null;\n            removeAllGlobalListeners();\n            if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n        }\n    });\n    let cancelOnPointerExit = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (shouldCancelOnPointerExit) cancel(e);\n    });\n    let pressProps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let state = ref.current;\n        let pressProps = {\n            onKeyDown (e) {\n                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\n                    var _state_metaKeyEvents;\n                    if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n                    // If the event is repeating, it may have started on a different element\n                    // after which focus moved to the current element. Ignore these events and\n                    // only handle the first key down event.\n                    let shouldStopPropagation = true;\n                    if (!state.isPressed && !e.repeat) {\n                        state.target = e.currentTarget;\n                        state.isPressed = true;\n                        shouldStopPropagation = triggerPressStart(e, \"keyboard\");\n                        // Focus may move before the key up event, so register the event on the document\n                        // instead of the same element where the key down event occurred.\n                        addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"keyup\", onKeyUp, false);\n                    }\n                    if (shouldStopPropagation) e.stopPropagation();\n                    // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n                    // macOS has a bug where keyup events are not fired while the Meta key is down.\n                    // When the Meta key itself is released we will get an event for that, and we'll act as if\n                    // all of these other keys were released as well.\n                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n                    // https://bugs.webkit.org/show_bug.cgi?id=55291\n                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n                    if (e.metaKey && (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isMac)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e.key, e.nativeEvent);\n                } else if (e.key === \"Meta\") state.metaKeyEvents = new Map();\n            },\n            onKeyUp (e) {\n                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e), \"keyboard\");\n            },\n            onClick (e) {\n                if (e && !e.currentTarget.contains(e.target)) return;\n                if (e && e.button === 0 && !state.isTriggeringEvent && !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.openLink).isOpening) {\n                    let shouldStopPropagation = true;\n                    if (isDisabled) e.preventDefault();\n                    // If triggered from a screen reader or by using element.click(),\n                    // trigger as if it were a keyboard click.\n                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === \"virtual\" || (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e.nativeEvent))) {\n                        // Ensure the element receives focus (VoiceOver on iOS does not do this)\n                        if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                        let stopPressStart = triggerPressStart(e, \"virtual\");\n                        let stopPressUp = triggerPressUp(e, \"virtual\");\n                        let stopPressEnd = triggerPressEnd(e, \"virtual\");\n                        shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n                    }\n                    state.ignoreEmulatedMouseEvents = false;\n                    state.ignoreClickAfterPress = false;\n                    if (shouldStopPropagation) e.stopPropagation();\n                }\n            }\n        };\n        let onKeyUp = (e)=>{\n            var _state_metaKeyEvents;\n            if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e, state.target)) {\n                var _state_metaKeyEvents1;\n                if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n                let target = e.target;\n                let shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), \"keyboard\", state.target.contains(target));\n                removeAllGlobalListeners();\n                if (shouldStopPropagation) e.stopPropagation();\n                // If a link was triggered with a key other than Enter, open the URL ourselves.\n                // This means the link has a role override, and the default browser behavior\n                // only applies when using the Enter key.\n                if (e.key !== \"Enter\" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[$f6c31cce2adf654f$var$LINK_CLICKED]) {\n                    // Store a hidden property on the event so we only trigger link click once,\n                    // even if there are multiple usePress instances attached to the element.\n                    e[$f6c31cce2adf654f$var$LINK_CLICKED] = true;\n                    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.openLink)(state.target, e, false);\n                }\n                state.isPressed = false;\n                (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e.key);\n            } else if (e.key === \"Meta\" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {\n                var _state_target;\n                // If we recorded keydown events that occurred while the Meta key was pressed,\n                // and those haven't received keyup events already, fire keyup events ourselves.\n                // See comment above for more info about the macOS bug causing this.\n                let events = state.metaKeyEvents;\n                state.metaKeyEvents = undefined;\n                for (let event of events.values())(_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent(\"keyup\", event));\n            }\n        };\n        if (typeof PointerEvent !== \"undefined\") {\n            pressProps.onPointerDown = (e)=>{\n                // Only handle left clicks, and ignore events that bubbled through portals.\n                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n                // Ignore and let the onClick handler take care of it instead.\n                // https://bugs.webkit.org/show_bug.cgi?id=222627\n                // https://bugs.webkit.org/show_bug.cgi?id=223202\n                if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualPointerEvent)(e.nativeEvent)) {\n                    state.pointerType = \"virtual\";\n                    return;\n                }\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent\n                // default on pointer down and handle focusing the pressable element ourselves.\n                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                state.pointerType = e.pointerType;\n                let shouldStopPropagation = true;\n                if (!state.isPressed) {\n                    state.isPressed = true;\n                    state.isOverTarget = true;\n                    state.activePointerId = e.pointerId;\n                    state.target = e.currentTarget;\n                    if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                    if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n                    shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointermove\", onPointerMove, false);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointerup\", onPointerUp, false);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointercancel\", onPointerCancel, false);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseDown = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (e.button === 0) {\n                    // Chrome and Firefox on touch Windows devices require mouse down events\n                    // to be canceled in addition to pointer events, or an extra asynchronous\n                    // focus event will be fired.\n                    if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                    e.stopPropagation();\n                }\n            };\n            pressProps.onPointerUp = (e)=>{\n                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n                if (!e.currentTarget.contains(e.target) || state.pointerType === \"virtual\") return;\n                // Only handle left clicks\n                // Safari on iOS sometimes fires pointerup events, even\n                // when the touch isn't over the target, so double check.\n                if (e.button === 0 && $f6c31cce2adf654f$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);\n            };\n            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.\n            // Use pointer move events instead to implement our own hit testing.\n            // See https://bugs.webkit.org/show_bug.cgi?id=199803\n            let onPointerMove = (e)=>{\n                if (e.pointerId !== state.activePointerId) return;\n                if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target)) {\n                    if (!state.isOverTarget && state.pointerType != null) {\n                        state.isOverTarget = true;\n                        triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                    }\n                } else if (state.target && state.isOverTarget && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n            };\n            let onPointerUp = (e)=>{\n                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n                    if ($f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                    else if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                    state.isPressed = false;\n                    state.isOverTarget = false;\n                    state.activePointerId = null;\n                    state.pointerType = null;\n                    removeAllGlobalListeners();\n                    if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n                }\n            };\n            let onPointerCancel = (e)=>{\n                cancel(e);\n            };\n            pressProps.onDragStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n                cancel(e);\n            };\n        } else {\n            pressProps.onMouseDown = (e)=>{\n                // Only handle left clicks\n                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent\n                // default on mouse down and handle focusing the pressable element ourselves.\n                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                if (state.ignoreEmulatedMouseEvents) {\n                    e.stopPropagation();\n                    return;\n                }\n                state.isPressed = true;\n                state.isOverTarget = true;\n                state.target = e.currentTarget;\n                state.pointerType = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e.nativeEvent) ? \"virtual\" : \"mouse\";\n                if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                if (shouldStopPropagation) e.stopPropagation();\n                addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"mouseup\", onMouseUp, false);\n            };\n            pressProps.onMouseEnter = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let shouldStopPropagation = true;\n                if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n                    state.isOverTarget = true;\n                    shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseLeave = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let shouldStopPropagation = true;\n                if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseUp = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType || \"mouse\");\n            };\n            let onMouseUp = (e)=>{\n                // Only handle left clicks\n                if (e.button !== 0) return;\n                state.isPressed = false;\n                removeAllGlobalListeners();\n                if (state.ignoreEmulatedMouseEvents) {\n                    state.ignoreEmulatedMouseEvents = false;\n                    return;\n                }\n                if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                else if (state.target && state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                state.isOverTarget = false;\n            };\n            pressProps.onTouchStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e.nativeEvent);\n                if (!touch) return;\n                state.activePointerId = touch.identifier;\n                state.ignoreEmulatedMouseEvents = true;\n                state.isOverTarget = true;\n                state.isPressed = true;\n                state.target = e.currentTarget;\n                state.pointerType = \"touch\";\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent default\n                // on the emulated mouse event and handle focusing the pressable element ourselves.\n                if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n                let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                if (shouldStopPropagation) e.stopPropagation();\n                addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(e.currentTarget), \"scroll\", onScroll, true);\n            };\n            pressProps.onTouchMove = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.isPressed) {\n                    e.stopPropagation();\n                    return;\n                }\n                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n                let shouldStopPropagation = true;\n                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget)) {\n                    if (!state.isOverTarget && state.pointerType != null) {\n                        state.isOverTarget = true;\n                        shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                    }\n                } else if (state.isOverTarget && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onTouchEnd = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.isPressed) {\n                    e.stopPropagation();\n                    return;\n                }\n                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n                let shouldStopPropagation = true;\n                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n                    triggerPressUp(e, state.pointerType);\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n                } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                if (shouldStopPropagation) e.stopPropagation();\n                state.isPressed = false;\n                state.activePointerId = null;\n                state.isOverTarget = false;\n                state.ignoreEmulatedMouseEvents = true;\n                if (state.target && !allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n                removeAllGlobalListeners();\n            };\n            pressProps.onTouchCancel = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                e.stopPropagation();\n                if (state.isPressed) cancel(e);\n            };\n            let onScroll = (e)=>{\n                if (state.isPressed && e.target.contains(state.target)) cancel({\n                    currentTarget: state.target,\n                    shiftKey: false,\n                    ctrlKey: false,\n                    metaKey: false,\n                    altKey: false\n                });\n            };\n            pressProps.onDragStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                cancel(e);\n            };\n        }\n        return pressProps;\n    }, [\n        addGlobalListener,\n        isDisabled,\n        preventFocusOnPress,\n        removeAllGlobalListeners,\n        allowTextSelectionOnPress,\n        cancel,\n        cancelOnPointerExit,\n        triggerPressEnd,\n        triggerPressStart,\n        triggerPressUp\n    ]);\n    // Remove user-select: none in case component unmounts immediately after pressStart\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            var _ref_current_target;\n            if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_ref_current_target = ref.current.target) !== null && _ref_current_target !== void 0 ? _ref_current_target : undefined);\n        };\n    }, [\n        allowTextSelectionOnPress\n    ]);\n    return {\n        isPressed: isPressedProp || isPressed,\n        pressProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(domProps, pressProps)\n    };\n}\nfunction $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {\n    return target.tagName === \"A\" && target.hasAttribute(\"href\");\n}\nfunction $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {\n    const { key: key, code: code } = event;\n    const element = currentTarget;\n    const role = element.getAttribute(\"role\");\n    // Accessibility for keyboards. Space and Enter only.\n    // \"Spacebar\" is for IE 11\n    return (key === \"Enter\" || key === \" \" || key === \"Spacebar\" || code === \"Space\") && !(element instanceof (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(element).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key) || element instanceof (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(element).HTMLTextAreaElement || element.isContentEditable) && // Links should only trigger with Enter key\n    !((role === \"link\" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element)) && key !== \"Enter\");\n}\nfunction $f6c31cce2adf654f$var$getTouchFromEvent(event) {\n    const { targetTouches: targetTouches } = event;\n    if (targetTouches.length > 0) return targetTouches[0];\n    return null;\n}\nfunction $f6c31cce2adf654f$var$getTouchById(event, pointerId) {\n    const changedTouches = event.changedTouches;\n    for(let i = 0; i < changedTouches.length; i++){\n        const touch = changedTouches[i];\n        if (touch.identifier === pointerId) return touch;\n    }\n    return null;\n}\nfunction $f6c31cce2adf654f$var$createEvent(target, e) {\n    return {\n        currentTarget: target,\n        shiftKey: e.shiftKey,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey\n    };\n}\nfunction $f6c31cce2adf654f$var$getPointClientRect(point) {\n    let offsetX = 0;\n    let offsetY = 0;\n    if (point.width !== undefined) offsetX = point.width / 2;\n    else if (point.radiusX !== undefined) offsetX = point.radiusX;\n    if (point.height !== undefined) offsetY = point.height / 2;\n    else if (point.radiusY !== undefined) offsetY = point.radiusY;\n    return {\n        top: point.clientY - offsetY,\n        right: point.clientX + offsetX,\n        bottom: point.clientY + offsetY,\n        left: point.clientX - offsetX\n    };\n}\nfunction $f6c31cce2adf654f$var$areRectanglesOverlapping(a, b) {\n    // check if they cannot overlap on x axis\n    if (a.left > b.right || b.left > a.right) return false;\n    // check if they cannot overlap on y axis\n    if (a.top > b.bottom || b.top > a.bottom) return false;\n    return true;\n}\nfunction $f6c31cce2adf654f$var$isOverTarget(point, target) {\n    let rect = target.getBoundingClientRect();\n    let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);\n    return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefault(target) {\n    // We cannot prevent default if the target is a draggable element.\n    return !(target instanceof HTMLElement) || !target.hasAttribute(\"draggable\");\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {\n    if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);\n    if (target instanceof HTMLButtonElement) return target.type !== \"submit\" && target.type !== \"reset\";\n    if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;\n    return true;\n}\nconst $f6c31cce2adf654f$var$nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\nfunction $f6c31cce2adf654f$var$isValidInputKey(target, key) {\n    // Only space should toggle checkboxes and radios, not enter.\n    return target.type === \"checkbox\" || target.type === \"radio\" ? key === \" \" : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);\n}\nconst $3b117e43dc0ca95d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef(({ children: children, ...props }, ref)=>{\n    ref = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useObjectRef)(ref);\n    let { pressProps: pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({\n        ...props,\n        ref: ref\n    });\n    let child = (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.only(children);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).cloneElement(child, {\n        ref: ref,\n        ...(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(child.props, pressProps)\n    });\n});\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $f1ab8c75478c6f73$export$3351871ee4b288b8 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef(({ children: children, ...props }, ref)=>{\n    let isRegistered = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let prevContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n    ref = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useObjectRef)(ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref));\n    let context = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(prevContext || {}, {\n        ...props,\n        ref: ref,\n        register () {\n            isRegistered.current = true;\n            if (prevContext) prevContext.register();\n        }\n    });\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useSyncRef)(prevContext, ref);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isRegistered.current) {\n            console.warn(\"A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.\");\n            isRegistered.current = true; // only warn once in strict mode.\n        }\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {\n        value: context\n    }, children);\n});\nfunction $f1ab8c75478c6f73$export$cf75428e0b9ed1ea({ children: children }) {\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            register: ()=>{}\n        }), []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {\n        value: context\n    }, children);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $8a9cb279dc87e130$export$905e7fc544a71f36 {\n    isDefaultPrevented() {\n        return this.nativeEvent.defaultPrevented;\n    }\n    preventDefault() {\n        this.defaultPrevented = true;\n        this.nativeEvent.preventDefault();\n    }\n    stopPropagation() {\n        this.nativeEvent.stopPropagation();\n        this.isPropagationStopped = ()=>true;\n    }\n    isPropagationStopped() {\n        return false;\n    }\n    persist() {}\n    constructor(type, nativeEvent){\n        this.nativeEvent = nativeEvent;\n        this.target = nativeEvent.target;\n        this.currentTarget = nativeEvent.currentTarget;\n        this.relatedTarget = nativeEvent.relatedTarget;\n        this.bubbles = nativeEvent.bubbles;\n        this.cancelable = nativeEvent.cancelable;\n        this.defaultPrevented = nativeEvent.defaultPrevented;\n        this.eventPhase = nativeEvent.eventPhase;\n        this.isTrusted = nativeEvent.isTrusted;\n        this.timeStamp = nativeEvent.timeStamp;\n        this.type = type;\n    }\n}\nfunction $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {\n    let stateRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocused: false,\n        observer: null\n    });\n    // Clean up MutationObserver on unmount. See below.\n    // eslint-disable-next-line arrow-body-style\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        const state = stateRef.current;\n        return ()=>{\n            if (state.observer) {\n                state.observer.disconnect();\n                state.observer = null;\n            }\n        };\n    }, []);\n    let dispatchBlur = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);\n    });\n    // This function is called during a React onFocus event.\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {\n            stateRef.current.isFocused = true;\n            let target = e.target;\n            let onBlurHandler = (e)=>{\n                stateRef.current.isFocused = false;\n                if (target.disabled) dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36(\"blur\", e));\n                // We no longer need the MutationObserver once the target is blurred.\n                if (stateRef.current.observer) {\n                    stateRef.current.observer.disconnect();\n                    stateRef.current.observer = null;\n                }\n            };\n            target.addEventListener(\"focusout\", onBlurHandler, {\n                once: true\n            });\n            stateRef.current.observer = new MutationObserver(()=>{\n                if (stateRef.current.isFocused && target.disabled) {\n                    var _stateRef_current_observer;\n                    (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();\n                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n                    target.dispatchEvent(new FocusEvent(\"blur\", {\n                        relatedTarget: relatedTargetEl\n                    }));\n                    target.dispatchEvent(new FocusEvent(\"focusout\", {\n                        bubbles: true,\n                        relatedTarget: relatedTargetEl\n                    }));\n                }\n            });\n            stateRef.current.observer.observe(target, {\n                attributes: true,\n                attributeFilter: [\n                    \"disabled\"\n                ]\n            });\n        }\n    }, [\n        dispatchBlur\n    ]);\n}\nfunction $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {\n    let { isDisabled: isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange: onFocusChange } = props;\n    const onBlur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (e.target === e.currentTarget) {\n            if (onBlurProp) onBlurProp(e);\n            if (onFocusChange) onFocusChange(false);\n            return true;\n        }\n    }, [\n        onBlurProp,\n        onFocusChange\n    ]);\n    const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);\n    const onFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Double check that document.activeElement actually matches e.target in case a previously chained\n        // focus handler already moved focus somewhere else.\n        if (e.target === e.currentTarget && document.activeElement === e.target) {\n            if (onFocusProp) onFocusProp(e);\n            if (onFocusChange) onFocusChange(true);\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusChange,\n        onFocusProp,\n        onSyntheticFocus\n    ]);\n    return {\n        focusProps: {\n            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,\n            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nlet $507fabe10e71c6fb$var$currentModality = null;\nlet $507fabe10e71c6fb$var$changeHandlers = new Set();\nlet $507fabe10e71c6fb$var$hasSetupGlobalListeners = false;\nlet $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\nlet $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n// Only Tab or Esc keys will make focus visible on text input elements\nconst $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n    Tab: true,\n    Escape: true\n};\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {\n    for (let handler of $507fabe10e71c6fb$var$changeHandlers)handler(modality, e);\n}\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */ function $507fabe10e71c6fb$var$isValidKey(e) {\n    // Control and Shift keys trigger when navigating back to the tab with keyboard.\n    return !(e.metaKey || !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isMac)() && e.altKey || e.ctrlKey || e.key === \"Control\" || e.key === \"Shift\" || e.key === \"Meta\");\n}\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e) {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    if ($507fabe10e71c6fb$var$isValidKey(e)) {\n        $507fabe10e71c6fb$var$currentModality = \"keyboard\";\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"keyboard\", e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e) {\n    $507fabe10e71c6fb$var$currentModality = \"pointer\";\n    if (e.type === \"mousedown\" || e.type === \"pointerdown\") {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"pointer\", e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handleClickEvent(e) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e)) {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$currentModality = \"virtual\";\n    }\n}\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e) {\n    // Firefox fires two extra focus events when the user first clicks into an iframe:\n    // first on the window, then on the document. We ignore these events so they don't\n    // cause keyboard focus rings to appear.\n    if (e.target === window || e.target === document) return;\n    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n    if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {\n        $507fabe10e71c6fb$var$currentModality = \"virtual\";\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"virtual\", e);\n    }\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n}\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n    // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n    // for example, since a subsequent focus event won't be fired.\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;\n}\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */ function $507fabe10e71c6fb$var$setupGlobalFocusEvents() {\n    if (true) return;\n    // Programmatic focus() calls shouldn't affect the current input modality.\n    // However, we need to detect other cases when a focus event occurs without\n    // a preceding user event (e.g. screen reader focus). Overriding the focus\n    // method on HTMLElement.prototype is a bit hacky, but works.\n    let focus = HTMLElement.prototype.focus;\n    HTMLElement.prototype.focus = function() {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        focus.apply(this, arguments);\n    };\n    document.addEventListener(\"keydown\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    document.addEventListener(\"keyup\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    document.addEventListener(\"click\", $507fabe10e71c6fb$var$handleClickEvent, true);\n    // Register focus events on the window so they are sure to happen\n    // before React's event listeners (registered on the document).\n    window.addEventListener(\"focus\", $507fabe10e71c6fb$var$handleFocusEvent, true);\n    window.addEventListener(\"blur\", $507fabe10e71c6fb$var$handleWindowBlur, false);\n    if (typeof PointerEvent !== \"undefined\") {\n        document.addEventListener(\"pointerdown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"pointermove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"pointerup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    } else {\n        document.addEventListener(\"mousedown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"mousemove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"mouseup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    }\n    $507fabe10e71c6fb$var$hasSetupGlobalListeners = true;\n}\nif (typeof document !== \"undefined\") {\n    if (document.readyState !== \"loading\") $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    else document.addEventListener(\"DOMContentLoaded\", $507fabe10e71c6fb$var$setupGlobalFocusEvents);\n}\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n    return $507fabe10e71c6fb$var$currentModality !== \"pointer\";\n}\nfunction $507fabe10e71c6fb$export$630ff653c5ada6a9() {\n    return $507fabe10e71c6fb$var$currentModality;\n}\nfunction $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {\n    $507fabe10e71c6fb$var$currentModality = modality;\n    $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);\n}\nfunction $507fabe10e71c6fb$export$98e20ec92f614cfe() {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    let [modality, setModality] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($507fabe10e71c6fb$var$currentModality);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let handler = ()=>{\n            setModality($507fabe10e71c6fb$var$currentModality);\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    }, []);\n    return (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_5__.useIsSSR)() ? null : modality;\n}\nconst $507fabe10e71c6fb$var$nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */ function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n    var _e_target;\n    isTextInput = isTextInput || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(e === null || e === void 0 ? void 0 : (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.type) || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLTextAreaElement || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLElement && (e === null || e === void 0 ? void 0 : e.target.isContentEditable);\n    return !(isTextInput && modality === \"keyboard\" && e instanceof KeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $507fabe10e71c6fb$export$ffd9e5021c1fb2d6(props = {}) {\n    let { isTextInput: isTextInput, autoFocus: autoFocus } = props;\n    let [isFocusVisibleState, setFocusVisible] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());\n    $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible)=>{\n        setFocusVisible(isFocusVisible);\n    }, [\n        isTextInput\n    ], {\n        isTextInput: isTextInput\n    });\n    return {\n        isFocusVisible: isFocusVisibleState\n    };\n}\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let handler = (modality, e)=>{\n            if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;\n            fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nfunction $9ab94262bd0047c7$export$420e68273165f4ec(props) {\n    let { isDisabled: isDisabled, onBlurWithin: onBlurWithin, onFocusWithin: onFocusWithin, onFocusWithinChange: onFocusWithinChange } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocusWithin: false\n    });\n    let onBlur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again\n        // when moving focus inside the element. Only trigger if the currentTarget doesn't\n        // include the relatedTarget (where focus is moving).\n        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {\n            state.current.isFocusWithin = false;\n            if (onBlurWithin) onBlurWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(false);\n        }\n    }, [\n        onBlurWithin,\n        onFocusWithinChange,\n        state\n    ]);\n    let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);\n    let onFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Double check that document.activeElement actually matches e.target in case a previously chained\n        // focus handler already moved focus somewhere else.\n        if (!state.current.isFocusWithin && document.activeElement === e.target) {\n            if (onFocusWithin) onFocusWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(true);\n            state.current.isFocusWithin = true;\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusWithin,\n        onFocusWithinChange,\n        onSyntheticFocus\n    ]);\n    if (isDisabled) return {\n        focusWithinProps: {\n            // These should not have been null, that would conflict in mergeProps\n            onFocus: undefined,\n            onBlur: undefined\n        }\n    };\n    return {\n        focusWithinProps: {\n            onFocus: onFocus,\n            onBlur: onBlur\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\nlet $6179b936705e76d3$var$hoverCount = 0;\nfunction $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {\n    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;\n    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n    // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n    // the distant future because a user previously touched the element.\n    setTimeout(()=>{\n        $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\n    }, 50);\n}\nfunction $6179b936705e76d3$var$handleGlobalPointerEvent(e) {\n    if (e.pointerType === \"touch\") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();\n}\nfunction $6179b936705e76d3$var$setupGlobalTouchEvents() {\n    if (typeof document === \"undefined\") return;\n    if (typeof PointerEvent !== \"undefined\") document.addEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n    else document.addEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n    $6179b936705e76d3$var$hoverCount++;\n    return ()=>{\n        $6179b936705e76d3$var$hoverCount--;\n        if ($6179b936705e76d3$var$hoverCount > 0) return;\n        if (typeof PointerEvent !== \"undefined\") document.removeEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n        else document.removeEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n    };\n}\nfunction $6179b936705e76d3$export$ae780daf29e6d456(props) {\n    let { onHoverStart: onHoverStart, onHoverChange: onHoverChange, onHoverEnd: onHoverEnd, isDisabled: isDisabled } = props;\n    let [isHovered, setHovered] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isHovered: false,\n        ignoreEmulatedMouseEvents: false,\n        pointerType: \"\",\n        target: null\n    }).current;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);\n    let { hoverProps: hoverProps, triggerHoverEnd: triggerHoverEnd } = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let triggerHoverStart = (event, pointerType)=>{\n            state.pointerType = pointerType;\n            if (isDisabled || pointerType === \"touch\" || state.isHovered || !event.currentTarget.contains(event.target)) return;\n            state.isHovered = true;\n            let target = event.currentTarget;\n            state.target = target;\n            if (onHoverStart) onHoverStart({\n                type: \"hoverstart\",\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(true);\n            setHovered(true);\n        };\n        let triggerHoverEnd = (event, pointerType)=>{\n            state.pointerType = \"\";\n            state.target = null;\n            if (pointerType === \"touch\" || !state.isHovered) return;\n            state.isHovered = false;\n            let target = event.currentTarget;\n            if (onHoverEnd) onHoverEnd({\n                type: \"hoverend\",\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(false);\n            setHovered(false);\n        };\n        let hoverProps = {};\n        if (typeof PointerEvent !== \"undefined\") {\n            hoverProps.onPointerEnter = (e)=>{\n                if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === \"mouse\") return;\n                triggerHoverStart(e, e.pointerType);\n            };\n            hoverProps.onPointerLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);\n            };\n        } else {\n            hoverProps.onTouchStart = ()=>{\n                state.ignoreEmulatedMouseEvents = true;\n            };\n            hoverProps.onMouseEnter = (e)=>{\n                if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, \"mouse\");\n                state.ignoreEmulatedMouseEvents = false;\n            };\n            hoverProps.onMouseLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, \"mouse\");\n            };\n        }\n        return {\n            hoverProps: hoverProps,\n            triggerHoverEnd: triggerHoverEnd\n        };\n    }, [\n        onHoverStart,\n        onHoverChange,\n        onHoverEnd,\n        isDisabled,\n        state\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Call the triggerHoverEnd as soon as isDisabled changes to true\n        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n        if (isDisabled) triggerHoverEnd({\n            currentTarget: state.target\n        }, state.pointerType);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled\n    ]);\n    return {\n        hoverProps: hoverProps,\n        isHovered: isHovered\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nfunction $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {\n    let { ref: ref, onInteractOutside: onInteractOutside, isDisabled: isDisabled, onInteractOutsideStart: onInteractOutsideStart } = props;\n    let stateRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isPointerDown: false,\n        ignoreEmulatedMouseEvents: false\n    });\n    let onPointerDown = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) {\n            if (onInteractOutsideStart) onInteractOutsideStart(e);\n            stateRef.current.isPointerDown = true;\n        }\n    });\n    let triggerInteractOutside = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (onInteractOutside) onInteractOutside(e);\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let state = stateRef.current;\n        if (isDisabled) return;\n        const element = ref.current;\n        const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(element);\n        // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n        if (typeof PointerEvent !== \"undefined\") {\n            let onPointerUp = (e)=>{\n                if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            // changing these to capture phase fixed combobox\n            documentObject.addEventListener(\"pointerdown\", onPointerDown, true);\n            documentObject.addEventListener(\"pointerup\", onPointerUp, true);\n            return ()=>{\n                documentObject.removeEventListener(\"pointerdown\", onPointerDown, true);\n                documentObject.removeEventListener(\"pointerup\", onPointerUp, true);\n            };\n        } else {\n            let onMouseUp = (e)=>{\n                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;\n                else if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            let onTouchEnd = (e)=>{\n                state.ignoreEmulatedMouseEvents = true;\n                if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            documentObject.addEventListener(\"mousedown\", onPointerDown, true);\n            documentObject.addEventListener(\"mouseup\", onMouseUp, true);\n            documentObject.addEventListener(\"touchstart\", onPointerDown, true);\n            documentObject.addEventListener(\"touchend\", onTouchEnd, true);\n            return ()=>{\n                documentObject.removeEventListener(\"mousedown\", onPointerDown, true);\n                documentObject.removeEventListener(\"mouseup\", onMouseUp, true);\n                documentObject.removeEventListener(\"touchstart\", onPointerDown, true);\n                documentObject.removeEventListener(\"touchend\", onTouchEnd, true);\n            };\n        }\n    }, [\n        ref,\n        isDisabled,\n        onPointerDown,\n        triggerInteractOutside\n    ]);\n}\nfunction $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {\n    if (event.button > 0) return false;\n    if (event.target) {\n        // if the event target is no longer in the document, ignore\n        const ownerDocument = event.target.ownerDocument;\n        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;\n        // If the target is within a top layer element (e.g. toasts), ignore.\n        if (event.target.closest(\"[data-react-aria-top-layer]\")) return false;\n    }\n    return ref.current && !ref.current.contains(event.target);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $93925083ecbb358c$export$48d1ea6320830260(handler) {\n    if (!handler) return undefined;\n    let shouldStopPropagation = true;\n    return (e)=>{\n        let event = {\n            ...e,\n            preventDefault () {\n                e.preventDefault();\n            },\n            isDefaultPrevented () {\n                return e.isDefaultPrevented();\n            },\n            stopPropagation () {\n                console.error(\"stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.\");\n            },\n            continuePropagation () {\n                shouldStopPropagation = false;\n            }\n        };\n        handler(event);\n        if (shouldStopPropagation) e.stopPropagation();\n    };\n}\nfunction $46d819fcbaf35654$export$8f71654801c2f7cd(props) {\n    return {\n        keyboardProps: props.isDisabled ? {} : {\n            onKeyDown: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyDown),\n            onKeyUp: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyUp)\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e8a7022cf87cba2a$export$36da96379f79f245(props) {\n    let { onMoveStart: onMoveStart, onMove: onMove, onMoveEnd: onMoveEnd } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        didMove: false,\n        lastPosition: null,\n        id: null\n    });\n    let { addGlobalListener: addGlobalListener, removeGlobalListener: removeGlobalListener } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let move = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{\n        if (deltaX === 0 && deltaY === 0) return;\n        if (!state.current.didMove) {\n            state.current.didMove = true;\n            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({\n                type: \"movestart\",\n                pointerType: pointerType,\n                shiftKey: originalEvent.shiftKey,\n                metaKey: originalEvent.metaKey,\n                ctrlKey: originalEvent.ctrlKey,\n                altKey: originalEvent.altKey\n            });\n        }\n        onMove === null || onMove === void 0 ? void 0 : onMove({\n            type: \"move\",\n            pointerType: pointerType,\n            deltaX: deltaX,\n            deltaY: deltaY,\n            shiftKey: originalEvent.shiftKey,\n            metaKey: originalEvent.metaKey,\n            ctrlKey: originalEvent.ctrlKey,\n            altKey: originalEvent.altKey\n        });\n    });\n    let end = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)();\n        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({\n            type: \"moveend\",\n            pointerType: pointerType,\n            shiftKey: originalEvent.shiftKey,\n            metaKey: originalEvent.metaKey,\n            ctrlKey: originalEvent.ctrlKey,\n            altKey: originalEvent.altKey\n        });\n    });\n    let moveProps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let moveProps = {};\n        let start = ()=>{\n            (0, $14c0b72509d70225$export$16a4697467175487)();\n            state.current.didMove = false;\n        };\n        if (typeof PointerEvent === \"undefined\") {\n            let onMouseMove = (e)=>{\n                if (e.button === 0) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    move(e, \"mouse\", e.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                }\n            };\n            let onMouseUp = (e)=>{\n                if (e.button === 0) {\n                    end(e, \"mouse\");\n                    removeGlobalListener(window, \"mousemove\", onMouseMove, false);\n                    removeGlobalListener(window, \"mouseup\", onMouseUp, false);\n                }\n            };\n            moveProps.onMouseDown = (e)=>{\n                if (e.button === 0) {\n                    start();\n                    e.stopPropagation();\n                    e.preventDefault();\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                    addGlobalListener(window, \"mousemove\", onMouseMove, false);\n                    addGlobalListener(window, \"mouseup\", onMouseUp, false);\n                }\n            };\n            let onTouchMove = (e)=>{\n                let touch = [\n                    ...e.changedTouches\n                ].findIndex(({ identifier: identifier })=>identifier === state.current.id);\n                if (touch >= 0) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    let { pageX: pageX, pageY: pageY } = e.changedTouches[touch];\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    move(e, \"touch\", pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: pageX,\n                        pageY: pageY\n                    };\n                }\n            };\n            let onTouchEnd = (e)=>{\n                let touch = [\n                    ...e.changedTouches\n                ].findIndex(({ identifier: identifier })=>identifier === state.current.id);\n                if (touch >= 0) {\n                    end(e, \"touch\");\n                    state.current.id = null;\n                    removeGlobalListener(window, \"touchmove\", onTouchMove);\n                    removeGlobalListener(window, \"touchend\", onTouchEnd);\n                    removeGlobalListener(window, \"touchcancel\", onTouchEnd);\n                }\n            };\n            moveProps.onTouchStart = (e)=>{\n                if (e.changedTouches.length === 0 || state.current.id != null) return;\n                let { pageX: pageX, pageY: pageY, identifier: identifier } = e.changedTouches[0];\n                start();\n                e.stopPropagation();\n                e.preventDefault();\n                state.current.lastPosition = {\n                    pageX: pageX,\n                    pageY: pageY\n                };\n                state.current.id = identifier;\n                addGlobalListener(window, \"touchmove\", onTouchMove, false);\n                addGlobalListener(window, \"touchend\", onTouchEnd, false);\n                addGlobalListener(window, \"touchcancel\", onTouchEnd, false);\n            };\n        } else {\n            let onPointerMove = (e)=>{\n                if (e.pointerId === state.current.id) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    let pointerType = e.pointerType || \"mouse\";\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    // Problems with PointerEvent#movementX/movementY:\n                    // 1. it is always 0 on macOS Safari.\n                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS\n                    move(e, pointerType, e.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                }\n            };\n            let onPointerUp = (e)=>{\n                if (e.pointerId === state.current.id) {\n                    let pointerType = e.pointerType || \"mouse\";\n                    end(e, pointerType);\n                    state.current.id = null;\n                    removeGlobalListener(window, \"pointermove\", onPointerMove, false);\n                    removeGlobalListener(window, \"pointerup\", onPointerUp, false);\n                    removeGlobalListener(window, \"pointercancel\", onPointerUp, false);\n                }\n            };\n            moveProps.onPointerDown = (e)=>{\n                if (e.button === 0 && state.current.id == null) {\n                    start();\n                    e.stopPropagation();\n                    e.preventDefault();\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                    state.current.id = e.pointerId;\n                    addGlobalListener(window, \"pointermove\", onPointerMove, false);\n                    addGlobalListener(window, \"pointerup\", onPointerUp, false);\n                    addGlobalListener(window, \"pointercancel\", onPointerUp, false);\n                }\n            };\n        }\n        let triggerKeyboardMove = (e, deltaX, deltaY)=>{\n            start();\n            move(e, \"keyboard\", deltaX, deltaY);\n            end(e, \"keyboard\");\n        };\n        moveProps.onKeyDown = (e)=>{\n            switch(e.key){\n                case \"Left\":\n                case \"ArrowLeft\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, -1, 0);\n                    break;\n                case \"Right\":\n                case \"ArrowRight\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 1, 0);\n                    break;\n                case \"Up\":\n                case \"ArrowUp\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 0, -1);\n                    break;\n                case \"Down\":\n                case \"ArrowDown\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 0, 1);\n                    break;\n            }\n        };\n        return moveProps;\n    }, [\n        state,\n        addGlobalListener,\n        removeGlobalListener,\n        move,\n        end\n    ]);\n    return {\n        moveProps: moveProps\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $7d0a636d7a4dcefd$export$2123ff2b87c81ca(props, ref) {\n    let { onScroll: onScroll, isDisabled: isDisabled } = props;\n    let onScrollHandler = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // If the ctrlKey is pressed, this is a zoom event, do nothing.\n        if (e.ctrlKey) return;\n        // stop scrolling the page\n        e.preventDefault();\n        e.stopPropagation();\n        if (onScroll) onScroll({\n            deltaX: e.deltaX,\n            deltaY: e.deltaY\n        });\n    }, [\n        onScroll\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEvent)(ref, \"wheel\", isDisabled ? undefined : onScrollHandler);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $8a26561d2877236e$var$DEFAULT_THRESHOLD = 500;\nfunction $8a26561d2877236e$export$c24ed0104d07eab9(props) {\n    let { isDisabled: isDisabled, onLongPressStart: onLongPressStart, onLongPressEnd: onLongPressEnd, onLongPress: onLongPress, threshold: threshold = $8a26561d2877236e$var$DEFAULT_THRESHOLD, accessibilityDescription: accessibilityDescription } = props;\n    const timeRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let { addGlobalListener: addGlobalListener, removeGlobalListener: removeGlobalListener } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let { pressProps: pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({\n        isDisabled: isDisabled,\n        onPressStart (e) {\n            e.continuePropagation();\n            if (e.pointerType === \"mouse\" || e.pointerType === \"touch\") {\n                if (onLongPressStart) onLongPressStart({\n                    ...e,\n                    type: \"longpressstart\"\n                });\n                timeRef.current = setTimeout(()=>{\n                    // Prevent other usePress handlers from also handling this event.\n                    e.target.dispatchEvent(new PointerEvent(\"pointercancel\", {\n                        bubbles: true\n                    }));\n                    if (onLongPress) onLongPress({\n                        ...e,\n                        type: \"longpress\"\n                    });\n                    timeRef.current = undefined;\n                }, threshold);\n                // Prevent context menu, which may be opened on long press on touch devices\n                if (e.pointerType === \"touch\") {\n                    let onContextMenu = (e)=>{\n                        e.preventDefault();\n                    };\n                    addGlobalListener(e.target, \"contextmenu\", onContextMenu, {\n                        once: true\n                    });\n                    addGlobalListener(window, \"pointerup\", ()=>{\n                        // If no contextmenu event is fired quickly after pointerup, remove the handler\n                        // so future context menu events outside a long press are not prevented.\n                        setTimeout(()=>{\n                            removeGlobalListener(e.target, \"contextmenu\", onContextMenu);\n                        }, 30);\n                    }, {\n                        once: true\n                    });\n                }\n            }\n        },\n        onPressEnd (e) {\n            if (timeRef.current) clearTimeout(timeRef.current);\n            if (onLongPressEnd && (e.pointerType === \"mouse\" || e.pointerType === \"touch\")) onLongPressEnd({\n                ...e,\n                type: \"longpressend\"\n            });\n        }\n    });\n    let descriptionProps = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : undefined);\n    return {\n        longPressProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(pressProps, descriptionProps)\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvZm9jdXMvbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ludGVyYWN0aW9ucy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRyQjtBQUNyZTtBQUNqSjtBQUNFO0FBQ0Q7QUFDWDtBQUU1RDs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNEOzs7Ozs7Ozs7O0NBVUMsR0FBRyxrRUFBa0U7QUFDdEUsMkRBQTJEO0FBQzNELHlEQUF5RDtBQUN6RCxrSEFBa0g7QUFJbEg7Ozs7Ozs7Ozs7Q0FVQyxHQUNELDBHQUEwRztBQUMxRyw0SEFBNEg7QUFDNUgsSUFBSXFELDhCQUE4QjtBQUNsQyxJQUFJQyx3Q0FBd0M7QUFDNUMsSUFBSUMsMkNBQTJDLElBQUlDO0FBQ25ELFNBQVNDLDBDQUEwQ0MsTUFBTTtJQUNyRCxJQUFJLENBQUMsR0FBR2pDLG9EQUFXLEtBQU07UUFDckIsSUFBSTRCLGdDQUFnQyxXQUFXO1lBQzNDLGlEQUFpRDtZQUNqRCxNQUFNTSxpQkFBaUIsQ0FBQyxHQUFHaEQsK0RBQXNCLEVBQUcrQztZQUNwREosd0NBQXdDSyxlQUFlQyxlQUFlLENBQUNDLEtBQUssQ0FBQ0MsZ0JBQWdCO1lBQzdGSCxlQUFlQyxlQUFlLENBQUNDLEtBQUssQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDNUQ7UUFDQVQsOEJBQThCO0lBQ2xDLE9BQU8sSUFBSUssa0JBQWtCSyxlQUFlTCxrQkFBa0JNLFlBQVk7UUFDdEUsc0ZBQXNGO1FBQ3RGLGtEQUFrRDtRQUNsRFQseUNBQXlDVSxHQUFHLENBQUNQLFFBQVFBLE9BQU9HLEtBQUssQ0FBQ0ssVUFBVTtRQUM1RVIsT0FBT0csS0FBSyxDQUFDSyxVQUFVLEdBQUc7SUFDOUI7QUFDSjtBQUNBLFNBQVNDLDBDQUEwQ1QsTUFBTTtJQUNyRCxJQUFJLENBQUMsR0FBR2pDLG9EQUFXLEtBQU07UUFDckIsMERB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RTt3QkFDeEVoTyxXQUFXOzRCQUNQcVMscUJBQXFCdE8sRUFBRXpFLE1BQU0sRUFBRSxlQUFleVU7d0JBQ2xELEdBQUc7b0JBQ1AsR0FBRzt3QkFDQ2hJLE1BQU07b0JBQ1Y7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0ExSixZQUFZMEIsQ0FBQztZQUNULElBQUkrUCxRQUFRclEsT0FBTyxFQUFFdVEsYUFBYUYsUUFBUXJRLE9BQU87WUFDakQsSUFBSWlRLGtCQUFtQjNQLENBQUFBLEVBQUV6QyxXQUFXLEtBQUssV0FBV3lDLEVBQUV6QyxXQUFXLEtBQUssT0FBTSxHQUFJb1MsZUFBZTtnQkFDM0YsR0FBRzNQLENBQUM7Z0JBQ0oxQyxNQUFNO1lBQ1Y7UUFDSjtJQUNKO0lBQ0EsSUFBSTRTLG1CQUFtQixDQUFDLEdBQUdwVyw2REFBb0IsRUFBRzhWLGVBQWUsQ0FBQ3BSLGFBQWFzUiwyQkFBMkJsTztJQUMxRyxPQUFPO1FBQ0h1TyxnQkFBZ0IsQ0FBQyxHQUFHblkseURBQWdCLEVBQUdtSSxZQUFZK1A7SUFDdkQ7QUFDSjtBQUt5bEMsQ0FDemxDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhcnpvbmUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvZm9jdXMvbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ludGVyYWN0aW9ucy9kaXN0L2ltcG9ydC5tanM/MDk2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU9iamVjdFJlZiBhcyAkYng3U0wkdXNlT2JqZWN0UmVmLCBtZXJnZVByb3BzIGFzICRieDdTTCRtZXJnZVByb3BzLCB1c2VTeW5jUmVmIGFzICRieDdTTCR1c2VTeW5jUmVmLCB1c2VHbG9iYWxMaXN0ZW5lcnMgYXMgJGJ4N1NMJHVzZUdsb2JhbExpc3RlbmVycywgdXNlRWZmZWN0RXZlbnQgYXMgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50LCBnZXRPd25lckRvY3VtZW50IGFzICRieDdTTCRnZXRPd25lckRvY3VtZW50LCBpc01hYyBhcyAkYng3U0wkaXNNYWMsIG9wZW5MaW5rIGFzICRieDdTTCRvcGVuTGluaywgaXNWaXJ0dWFsQ2xpY2sgYXMgJGJ4N1NMJGlzVmlydHVhbENsaWNrLCBmb2N1c1dpdGhvdXRTY3JvbGxpbmcgYXMgJGJ4N1NMJGZvY3VzV2l0aG91dFNjcm9sbGluZywgaXNWaXJ0dWFsUG9pbnRlckV2ZW50IGFzICRieDdTTCRpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIGdldE93bmVyV2luZG93IGFzICRieDdTTCRnZXRPd25lcldpbmRvdywgaXNJT1MgYXMgJGJ4N1NMJGlzSU9TLCBydW5BZnRlclRyYW5zaXRpb24gYXMgJGJ4N1NMJHJ1bkFmdGVyVHJhbnNpdGlvbiwgdXNlTGF5b3V0RWZmZWN0IGFzICRieDdTTCR1c2VMYXlvdXRFZmZlY3QsIHVzZUV2ZW50IGFzICRieDdTTCR1c2VFdmVudCwgdXNlRGVzY3JpcHRpb24gYXMgJGJ4N1NMJHVzZURlc2NyaXB0aW9ufSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcbmltcG9ydCAkYng3U0wkcmVhY3QsIHt1c2VDb250ZXh0IGFzICRieDdTTCR1c2VDb250ZXh0LCB1c2VTdGF0ZSBhcyAkYng3U0wkdXNlU3RhdGUsIHVzZVJlZiBhcyAkYng3U0wkdXNlUmVmLCB1c2VNZW1vIGFzICRieDdTTCR1c2VNZW1vLCB1c2VFZmZlY3QgYXMgJGJ4N1NMJHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgYXMgJGJ4N1NMJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XyBhcyAkYng3U0wkX30gZnJvbSBcIkBzd2MvaGVscGVycy9fL19jbGFzc19wcml2YXRlX2ZpZWxkX2dldFwiO1xuaW1wb3J0IHtfIGFzICRieDdTTCRfMX0gZnJvbSBcIkBzd2MvaGVscGVycy9fL19jbGFzc19wcml2YXRlX2ZpZWxkX2luaXRcIjtcbmltcG9ydCB7XyBhcyAkYng3U0wkXzJ9IGZyb20gXCJAc3djL2hlbHBlcnMvXy9fY2xhc3NfcHJpdmF0ZV9maWVsZF9zZXRcIjtcbmltcG9ydCB7dXNlSXNTU1IgYXMgJGJ4N1NMJHVzZUlzU1NSfSBmcm9tIFwiQHJlYWN0LWFyaWEvc3NyXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8vIE5vdGUgdGhhdCBzdGF0ZSBvbmx5IG1hdHRlcnMgaGVyZSBmb3IgaU9TLiBOb24taU9TIGdldHMgdXNlci1zZWxlY3Q6IG5vbmUgYXBwbGllZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbi8vIHJhdGhlciB0aGFuIGF0IHRoZSBkb2N1bWVudCBsZXZlbCBzbyB3ZSBqdXN0IG5lZWQgdG8gYXBwbHkvcmVtb3ZlIHVzZXItc2VsZWN0OiBub25lIGZvciBlYWNoIHByZXNzZWQgZWxlbWVudCBpbmRpdmlkdWFsbHlcbmxldCAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPSBcImRlZmF1bHRcIjtcbmxldCAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc2F2ZWRVc2VyU2VsZWN0ID0gXCJcIjtcbmxldCAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkbW9kaWZpZWRFbGVtZW50TWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCQxNmE0Njk3NDY3MTc1NDg3KHRhcmdldCkge1xuICAgIGlmICgoMCwgJGJ4N1NMJGlzSU9TKSgpKSB7XG4gICAgICAgIGlmICgkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudE9iamVjdCA9ICgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkodGFyZ2V0KTtcbiAgICAgICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzYXZlZFVzZXJTZWxlY3QgPSBkb2N1bWVudE9iamVjdC5kb2N1bWVudEVsZW1lbnQuc3R5bGUud2Via2l0VXNlclNlbGVjdDtcbiAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LmRvY3VtZW50RWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgJDE0YzBiNzI1MDlkNzAyMjUkdmFyJHN0YXRlID0gXCJkaXNhYmxlZFwiO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAvLyBJZiBub3QgaU9TLCBzdG9yZSB0aGUgdGFyZ2V0J3Mgb3JpZ2luYWwgdXNlci1zZWxlY3QgYW5kIGNoYW5nZSB0byB1c2VyLXNlbGVjdDogbm9uZVxuICAgICAgICAvLyBJZ25vcmUgc3RhdGUgc2luY2UgaXQgZG9lc24ndCBhcHBseSBmb3Igbm9uIGlPU1xuICAgICAgICAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkbW9kaWZpZWRFbGVtZW50TWFwLnNldCh0YXJnZXQsIHRhcmdldC5zdHlsZS51c2VyU2VsZWN0KTtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgICB9XG59XG5mdW5jdGlvbiAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkYjBkNmZhMWFiMzJlMzI5NSh0YXJnZXQpIHtcbiAgICBpZiAoKDAsICRieDdTTCRpc0lPUykoKSkge1xuICAgICAgICAvLyBJZiB0aGUgc3RhdGUgaXMgYWxyZWFkeSBkZWZhdWx0LCB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgIC8vIElmIGl0IGlzIHJlc3RvcmluZywgdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gcXVldWUgYSBzZWNvbmQgcmVzdG9yZS5cbiAgICAgICAgaWYgKCQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSAhPT0gXCJkaXNhYmxlZFwiKSByZXR1cm47XG4gICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSA9IFwicmVzdG9yaW5nXCI7XG4gICAgICAgIC8vIFRoZXJlIGFwcGVhcnMgdG8gYmUgYSBkZWxheSBvbiBpT1Mgd2hlcmUgc2VsZWN0aW9uIHN0aWxsIG1pZ2h0IG9jY3VyXG4gICAgICAgIC8vIGFmdGVyIHBvaW50ZXIgdXAsIHNvIHdhaXQgYSBiaXQgYmVmb3JlIHJlbW92aW5nIHVzZXItc2VsZWN0LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAvLyBXYWl0IGZvciBhbnkgQ1NTIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlIHNvIHdlIGRvbid0IHJlY29tcHV0ZSBzdHlsZVxuICAgICAgICAgICAgLy8gZm9yIHRoZSB3aG9sZSBwYWdlIGluIHRoZSBtaWRkbGUgb2YgdGhlIGFuaW1hdGlvbiBhbmQgY2F1c2UgamFuay5cbiAgICAgICAgICAgICgwLCAkYng3U0wkcnVuQWZ0ZXJUcmFuc2l0aW9uKSgoKT0+e1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIGlmICgkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPT09IFwicmVzdG9yaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudE9iamVjdCA9ICgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50T2JqZWN0LmRvY3VtZW50RWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID09PSBcIm5vbmVcIikgZG9jdW1lbnRPYmplY3QuZG9jdW1lbnRFbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc2F2ZWRVc2VyU2VsZWN0IHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzYXZlZFVzZXJTZWxlY3QgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPSBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIC8vIElmIG5vdCBpT1MsIHJlc3RvcmUgdGhlIHRhcmdldCdzIG9yaWdpbmFsIHVzZXItc2VsZWN0IGlmIGFueVxuICAgIC8vIElnbm9yZSBzdGF0ZSBzaW5jZSBpdCBkb2Vzbid0IGFwcGx5IGZvciBub24gaU9TXG4gICAge1xuICAgICAgICBpZiAodGFyZ2V0ICYmICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRtb2RpZmllZEVsZW1lbnRNYXAuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRPbGRVc2VyU2VsZWN0ID0gJDE0YzBiNzI1MDlkNzAyMjUkdmFyJG1vZGlmaWVkRWxlbWVudE1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuc3R5bGUudXNlclNlbGVjdCA9PT0gXCJub25lXCIpIHRhcmdldC5zdHlsZS51c2VyU2VsZWN0ID0gdGFyZ2V0T2xkVXNlclNlbGVjdDtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgPT09IFwiXCIpIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRtb2RpZmllZEVsZW1lbnRNYXAuZGVsZXRlKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jb25zdCAkYWUxZWViYThiOWVhZmQwOCRleHBvcnQkNTE2NWVjY2IzNWFhYWRiNSA9ICgwLCAkYng3U0wkcmVhY3QpLmNyZWF0ZUNvbnRleHQoe1xuICAgIHJlZ2lzdGVyOiAoKT0+e31cbn0pO1xuJGFlMWVlYmE4YjllYWZkMDgkZXhwb3J0JDUxNjVlY2NiMzVhYWFkYjUuZGlzcGxheU5hbWUgPSBcIlByZXNzUmVzcG9uZGVyQ29udGV4dFwiO1xuXG5cblxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHVzZVByZXNzUmVzcG9uZGVyQ29udGV4dChwcm9wcykge1xuICAgIC8vIENvbnN1bWUgY29udGV4dCBmcm9tIDxQcmVzc1Jlc3BvbmRlcj4gYW5kIG1lcmdlIHdpdGggcHJvcHMuXG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJGJ4N1NMJHVzZUNvbnRleHQpKCgwLCAkYWUxZWViYThiOWVhZmQwOCRleHBvcnQkNTE2NWVjY2IzNWFhYWRiNSkpO1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGxldCB7IHJlZ2lzdGVyOiByZWdpc3RlciwgLi4uY29udGV4dFByb3BzIH0gPSBjb250ZXh0O1xuICAgICAgICBwcm9wcyA9ICgwLCAkYng3U0wkbWVyZ2VQcm9wcykoY29udGV4dFByb3BzLCBwcm9wcyk7XG4gICAgICAgIHJlZ2lzdGVyKCk7XG4gICAgfVxuICAgICgwLCAkYng3U0wkdXNlU3luY1JlZikoY29udGV4dCwgcHJvcHMucmVmKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG52YXIgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJF9zaG91bGRTdG9wUHJvcGFnYXRpb24gPSAvKiNfX1BVUkVfXyovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkUHJlc3NFdmVudCB7XG4gICAgY29udGludWVQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgKDAsICRieDdTTCRfMikodGhpcywgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJF9zaG91bGRTdG9wUHJvcGFnYXRpb24sIGZhbHNlKTtcbiAgICB9XG4gICAgZ2V0IHNob3VsZFN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICgwLCAkYng3U0wkXykodGhpcywgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJF9zaG91bGRTdG9wUHJvcGFnYXRpb24pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBwb2ludGVyVHlwZSwgb3JpZ2luYWxFdmVudCl7XG4gICAgICAgICgwLCAkYng3U0wkXzEpKHRoaXMsICRmNmMzMWNjZTJhZGY2NTRmJHZhciRfc2hvdWxkU3RvcFByb3BhZ2F0aW9uLCB7XG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCAkYng3U0wkXzIpKHRoaXMsICRmNmMzMWNjZTJhZGY2NTRmJHZhciRfc2hvdWxkU3RvcFByb3BhZ2F0aW9uLCB0cnVlKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5wb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG9yaWdpbmFsRXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IG9yaWdpbmFsRXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMubWV0YUtleSA9IG9yaWdpbmFsRXZlbnQubWV0YUtleTtcbiAgICAgICAgdGhpcy5jdHJsS2V5ID0gb3JpZ2luYWxFdmVudC5jdHJsS2V5O1xuICAgICAgICB0aGlzLmFsdEtleSA9IG9yaWdpbmFsRXZlbnQuYWx0S2V5O1xuICAgIH1cbn1cbmNvbnN0ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRMSU5LX0NMSUNLRUQgPSBTeW1ib2woXCJsaW5rQ2xpY2tlZFwiKTtcbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJGV4cG9ydCQ0NTcxMmVjZWRhNmZhZDIxKHByb3BzKSB7XG4gICAgbGV0IHsgb25QcmVzczogb25QcmVzcywgb25QcmVzc0NoYW5nZTogb25QcmVzc0NoYW5nZSwgb25QcmVzc1N0YXJ0OiBvblByZXNzU3RhcnQsIG9uUHJlc3NFbmQ6IG9uUHJlc3NFbmQsIG9uUHJlc3NVcDogb25QcmVzc1VwLCBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLCBpc1ByZXNzZWQ6IGlzUHJlc3NlZFByb3AsIHByZXZlbnRGb2N1c09uUHJlc3M6IHByZXZlbnRGb2N1c09uUHJlc3MsIHNob3VsZENhbmNlbE9uUG9pbnRlckV4aXQ6IHNob3VsZENhbmNlbE9uUG9pbnRlckV4aXQsIGFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3M6IGFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3MsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICByZWY6IF8sIC4uLmRvbVByb3BzIH0gPSAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkdXNlUHJlc3NSZXNwb25kZXJDb250ZXh0KHByb3BzKTtcbiAgICBsZXQgW2lzUHJlc3NlZCwgc2V0UHJlc3NlZF0gPSAoMCwgJGJ4N1NMJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IHJlZiA9ICgwLCAkYng3U0wkdXNlUmVmKSh7XG4gICAgICAgIGlzUHJlc3NlZDogZmFsc2UsXG4gICAgICAgIGlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHM6IGZhbHNlLFxuICAgICAgICBpZ25vcmVDbGlja0FmdGVyUHJlc3M6IGZhbHNlLFxuICAgICAgICBkaWRGaXJlUHJlc3NTdGFydDogZmFsc2UsXG4gICAgICAgIGlzVHJpZ2dlcmluZ0V2ZW50OiBmYWxzZSxcbiAgICAgICAgYWN0aXZlUG9pbnRlcklkOiBudWxsLFxuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIGlzT3ZlclRhcmdldDogZmFsc2UsXG4gICAgICAgIHBvaW50ZXJUeXBlOiBudWxsXG4gICAgfSk7XG4gICAgbGV0IHsgYWRkR2xvYmFsTGlzdGVuZXI6IGFkZEdsb2JhbExpc3RlbmVyLCByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnM6IHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycyB9ID0gKDAsICRieDdTTCR1c2VHbG9iYWxMaXN0ZW5lcnMpKCk7XG4gICAgbGV0IHRyaWdnZXJQcmVzc1N0YXJ0ID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKG9yaWdpbmFsRXZlbnQsIHBvaW50ZXJUeXBlKT0+e1xuICAgICAgICBsZXQgc3RhdGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgc3RhdGUuZGlkRmlyZVByZXNzU3RhcnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgIHN0YXRlLmlzVHJpZ2dlcmluZ0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9uUHJlc3NTdGFydCkge1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRQcmVzc0V2ZW50KFwicHJlc3NzdGFydFwiLCBwb2ludGVyVHlwZSwgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICBvblByZXNzU3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gZXZlbnQuc2hvdWxkU3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblByZXNzQ2hhbmdlKSBvblByZXNzQ2hhbmdlKHRydWUpO1xuICAgICAgICBzdGF0ZS5pc1RyaWdnZXJpbmdFdmVudCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5kaWRGaXJlUHJlc3NTdGFydCA9IHRydWU7XG4gICAgICAgIHNldFByZXNzZWQodHJ1ZSk7XG4gICAgICAgIHJldHVybiBzaG91bGRTdG9wUHJvcGFnYXRpb247XG4gICAgfSk7XG4gICAgbGV0IHRyaWdnZXJQcmVzc0VuZCA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChvcmlnaW5hbEV2ZW50LCBwb2ludGVyVHlwZSwgd2FzUHJlc3NlZCA9IHRydWUpPT57XG4gICAgICAgIGxldCBzdGF0ZSA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXN0YXRlLmRpZEZpcmVQcmVzc1N0YXJ0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN0YXRlLmlnbm9yZUNsaWNrQWZ0ZXJQcmVzcyA9IHRydWU7XG4gICAgICAgIHN0YXRlLmRpZEZpcmVQcmVzc1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmlzVHJpZ2dlcmluZ0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgIGlmIChvblByZXNzRW5kKSB7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJFByZXNzRXZlbnQoXCJwcmVzc2VuZFwiLCBwb2ludGVyVHlwZSwgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICBvblByZXNzRW5kKGV2ZW50KTtcbiAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IGV2ZW50LnNob3VsZFN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25QcmVzc0NoYW5nZSkgb25QcmVzc0NoYW5nZShmYWxzZSk7XG4gICAgICAgIHNldFByZXNzZWQoZmFsc2UpO1xuICAgICAgICBpZiAob25QcmVzcyAmJiB3YXNQcmVzc2VkICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJFByZXNzRXZlbnQoXCJwcmVzc1wiLCBwb2ludGVyVHlwZSwgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICBvblByZXNzKGV2ZW50KTtcbiAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiAmJiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gZXZlbnQuc2hvdWxkU3RvcFByb3BhZ2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pc1RyaWdnZXJpbmdFdmVudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2hvdWxkU3RvcFByb3BhZ2F0aW9uO1xuICAgIH0pO1xuICAgIGxldCB0cmlnZ2VyUHJlc3NVcCA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChvcmlnaW5hbEV2ZW50LCBwb2ludGVyVHlwZSk9PntcbiAgICAgICAgbGV0IHN0YXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChpc0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvblByZXNzVXApIHtcbiAgICAgICAgICAgIHN0YXRlLmlzVHJpZ2dlcmluZ0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkUHJlc3NFdmVudChcInByZXNzdXBcIiwgcG9pbnRlclR5cGUsIG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgb25QcmVzc1VwKGV2ZW50KTtcbiAgICAgICAgICAgIHN0YXRlLmlzVHJpZ2dlcmluZ0V2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQuc2hvdWxkU3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGxldCBjYW5jZWwgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgoZSk9PntcbiAgICAgICAgbGV0IHN0YXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChzdGF0ZS5pc1ByZXNzZWQgJiYgc3RhdGUudGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNPdmVyVGFyZ2V0ICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHRyaWdnZXJQcmVzc0VuZCgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQoc3RhdGUudGFyZ2V0LCBlKSwgc3RhdGUucG9pbnRlclR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVQb2ludGVySWQgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBpZiAoIWFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3MpICgwLCAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkYjBkNmZhMWFiMzJlMzI5NSkoc3RhdGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBjYW5jZWxPblBvaW50ZXJFeGl0ID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKGUpPT57XG4gICAgICAgIGlmIChzaG91bGRDYW5jZWxPblBvaW50ZXJFeGl0KSBjYW5jZWwoZSk7XG4gICAgfSk7XG4gICAgbGV0IHByZXNzUHJvcHMgPSAoMCwgJGJ4N1NMJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIGxldCBzdGF0ZSA9IHJlZi5jdXJyZW50O1xuICAgICAgICBsZXQgcHJlc3NQcm9wcyA9IHtcbiAgICAgICAgICAgIG9uS2V5RG93biAoZSkge1xuICAgICAgICAgICAgICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNWYWxpZEtleWJvYXJkRXZlbnQoZS5uYXRpdmVFdmVudCwgZS5jdXJyZW50VGFyZ2V0KSAmJiBlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVfbWV0YUtleUV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRzaG91bGRQcmV2ZW50RGVmYXVsdEtleWJvYXJkKGUudGFyZ2V0LCBlLmtleSkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGV2ZW50IGlzIHJlcGVhdGluZywgaXQgbWF5IGhhdmUgc3RhcnRlZCBvbiBhIGRpZmZlcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHdoaWNoIGZvY3VzIG1vdmVkIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQuIElnbm9yZSB0aGVzZSBldmVudHMgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgaGFuZGxlIHRoZSBmaXJzdCBrZXkgZG93biBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNQcmVzc2VkICYmICFlLnJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc1N0YXJ0KGUsIFwia2V5Ym9hcmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb2N1cyBtYXkgbW92ZSBiZWZvcmUgdGhlIGtleSB1cCBldmVudCwgc28gcmVnaXN0ZXIgdGhlIGV2ZW50IG9uIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgc2FtZSBlbGVtZW50IHdoZXJlIHRoZSBrZXkgZG93biBldmVudCBvY2N1cnJlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKCgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkoZS5jdXJyZW50VGFyZ2V0KSwgXCJrZXl1cFwiLCBvbktleVVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUga2V5ZG93biBldmVudHMgdGhhdCBvY2N1ciB3aGlsZSB0aGUgTWV0YSAoZS5nLiBDb21tYW5kKSBrZXkgaXMgaGVsZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWFjT1MgaGFzIGEgYnVnIHdoZXJlIGtleXVwIGV2ZW50cyBhcmUgbm90IGZpcmVkIHdoaWxlIHRoZSBNZXRhIGtleSBpcyBkb3duLlxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBNZXRhIGtleSBpdHNlbGYgaXMgcmVsZWFzZWQgd2Ugd2lsbCBnZXQgYW4gZXZlbnQgZm9yIHRoYXQsIGFuZCB3ZSdsbCBhY3QgYXMgaWZcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG9mIHRoZXNlIG90aGVyIGtleXMgd2VyZSByZWxlYXNlZCBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMzkzNTI0XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD01NTI5MVxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjk5NTUzXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm1ldGFLZXkgJiYgKDAsICRieDdTTCRpc01hYykoKSkgKF9zdGF0ZV9tZXRhS2V5RXZlbnRzID0gc3RhdGUubWV0YUtleUV2ZW50cykgPT09IG51bGwgfHwgX3N0YXRlX21ldGFLZXlFdmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9tZXRhS2V5RXZlbnRzLnNldChlLmtleSwgZS5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleSA9PT0gXCJNZXRhXCIpIHN0YXRlLm1ldGFLZXlFdmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25LZXlVcCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNWYWxpZEtleWJvYXJkRXZlbnQoZS5uYXRpdmVFdmVudCwgZS5jdXJyZW50VGFyZ2V0KSAmJiAhZS5yZXBlYXQgJiYgZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSAmJiBzdGF0ZS50YXJnZXQpIHRyaWdnZXJQcmVzc1VwKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBcImtleWJvYXJkXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2xpY2sgKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSAmJiAhZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChlICYmIGUuYnV0dG9uID09PSAwICYmICFzdGF0ZS5pc1RyaWdnZXJpbmdFdmVudCAmJiAhKDAsICRieDdTTCRvcGVuTGluaykuaXNPcGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0cmlnZ2VyZWQgZnJvbSBhIHNjcmVlbiByZWFkZXIgb3IgYnkgdXNpbmcgZWxlbWVudC5jbGljaygpLFxuICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGFzIGlmIGl0IHdlcmUgYSBrZXlib2FyZCBjbGljay5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pZ25vcmVDbGlja0FmdGVyUHJlc3MgJiYgIXN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgIXN0YXRlLmlzUHJlc3NlZCAmJiAoc3RhdGUucG9pbnRlclR5cGUgPT09IFwidmlydHVhbFwiIHx8ICgwLCAkYng3U0wkaXNWaXJ0dWFsQ2xpY2spKGUubmF0aXZlRXZlbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBlbGVtZW50IHJlY2VpdmVzIGZvY3VzIChWb2ljZU92ZXIgb24gaU9TIGRvZXMgbm90IGRvIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgIXByZXZlbnRGb2N1c09uUHJlc3MpICgwLCAkYng3U0wkZm9jdXNXaXRob3V0U2Nyb2xsaW5nKShlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0b3BQcmVzc1N0YXJ0ID0gdHJpZ2dlclByZXNzU3RhcnQoZSwgXCJ2aXJ0dWFsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0b3BQcmVzc1VwID0gdHJpZ2dlclByZXNzVXAoZSwgXCJ2aXJ0dWFsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0b3BQcmVzc0VuZCA9IHRyaWdnZXJQcmVzc0VuZChlLCBcInZpcnR1YWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJlc3NTdGFydCAmJiBzdG9wUHJlc3NVcCAmJiBzdG9wUHJlc3NFbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVDbGlja0FmdGVyUHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBvbktleVVwID0gKGUpPT57XG4gICAgICAgICAgICB2YXIgX3N0YXRlX21ldGFLZXlFdmVudHM7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNQcmVzc2VkICYmIHN0YXRlLnRhcmdldCAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNWYWxpZEtleWJvYXJkRXZlbnQoZSwgc3RhdGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHZhciBfc3RhdGVfbWV0YUtleUV2ZW50czE7XG4gICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRzaG91bGRQcmV2ZW50RGVmYXVsdEtleWJvYXJkKGUudGFyZ2V0LCBlLmtleSkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc0VuZCgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQoc3RhdGUudGFyZ2V0LCBlKSwgXCJrZXlib2FyZFwiLCBzdGF0ZS50YXJnZXQuY29udGFpbnModGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIGxpbmsgd2FzIHRyaWdnZXJlZCB3aXRoIGEga2V5IG90aGVyIHRoYW4gRW50ZXIsIG9wZW4gdGhlIFVSTCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGUgbGluayBoYXMgYSByb2xlIG92ZXJyaWRlLCBhbmQgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgYXBwbGllcyB3aGVuIHVzaW5nIHRoZSBFbnRlciBrZXkuXG4gICAgICAgICAgICAgICAgaWYgKGUua2V5ICE9PSBcIkVudGVyXCIgJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzSFRNTEFuY2hvckxpbmsoc3RhdGUudGFyZ2V0KSAmJiBzdGF0ZS50YXJnZXQuY29udGFpbnModGFyZ2V0KSAmJiAhZVskZjZjMzFjY2UyYWRmNjU0ZiR2YXIkTElOS19DTElDS0VEXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBhIGhpZGRlbiBwcm9wZXJ0eSBvbiB0aGUgZXZlbnQgc28gd2Ugb25seSB0cmlnZ2VyIGxpbmsgY2xpY2sgb25jZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgdXNlUHJlc3MgaW5zdGFuY2VzIGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBlWyRmNmMzMWNjZTJhZGY2NTRmJHZhciRMSU5LX0NMSUNLRURdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgKDAsICRieDdTTCRvcGVuTGluaykoc3RhdGUudGFyZ2V0LCBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIChfc3RhdGVfbWV0YUtleUV2ZW50czEgPSBzdGF0ZS5tZXRhS2V5RXZlbnRzKSA9PT0gbnVsbCB8fCBfc3RhdGVfbWV0YUtleUV2ZW50czEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9tZXRhS2V5RXZlbnRzMS5kZWxldGUoZS5rZXkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleSA9PT0gXCJNZXRhXCIgJiYgKChfc3RhdGVfbWV0YUtleUV2ZW50cyA9IHN0YXRlLm1ldGFLZXlFdmVudHMpID09PSBudWxsIHx8IF9zdGF0ZV9tZXRhS2V5RXZlbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfbWV0YUtleUV2ZW50cy5zaXplKSkge1xuICAgICAgICAgICAgICAgIHZhciBfc3RhdGVfdGFyZ2V0O1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlY29yZGVkIGtleWRvd24gZXZlbnRzIHRoYXQgb2NjdXJyZWQgd2hpbGUgdGhlIE1ldGEga2V5IHdhcyBwcmVzc2VkLFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aG9zZSBoYXZlbid0IHJlY2VpdmVkIGtleXVwIGV2ZW50cyBhbHJlYWR5LCBmaXJlIGtleXVwIGV2ZW50cyBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgZm9yIG1vcmUgaW5mbyBhYm91dCB0aGUgbWFjT1MgYnVnIGNhdXNpbmcgdGhpcy5cbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRzID0gc3RhdGUubWV0YUtleUV2ZW50cztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tZXRhS2V5RXZlbnRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGV2ZW50IG9mIGV2ZW50cy52YWx1ZXMoKSkoX3N0YXRlX3RhcmdldCA9IHN0YXRlLnRhcmdldCkgPT09IG51bGwgfHwgX3N0YXRlX3RhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX3RhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBLZXlib2FyZEV2ZW50KFwia2V5dXBcIiwgZXZlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Qb2ludGVyRG93biA9IChlKT0+e1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgaGFuZGxlIGxlZnQgY2xpY2tzLCBhbmQgaWdub3JlIGV2ZW50cyB0aGF0IGJ1YmJsZWQgdGhyb3VnaCBwb3J0YWxzLlxuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMCB8fCAhZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIGlPUyBzYWZhcmkgZmlyZXMgcG9pbnRlciBldmVudHMgZnJvbSBWb2ljZU92ZXIgd2l0aCBpbmNvcnJlY3QgY29vcmRpbmF0ZXMvdGFyZ2V0LlxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbmQgbGV0IHRoZSBvbkNsaWNrIGhhbmRsZXIgdGFrZSBjYXJlIG9mIGl0IGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIyMjYyN1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMjMyMDJcbiAgICAgICAgICAgICAgICBpZiAoKDAsICRieDdTTCRpc1ZpcnR1YWxQb2ludGVyRXZlbnQpKGUubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXJUeXBlID0gXCJ2aXJ0dWFsXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRHVlIHRvIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzLCBlc3BlY2lhbGx5IG9uIG1vYmlsZSBicm93c2Vycywgd2UgcHJldmVudFxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgb24gcG9pbnRlciBkb3duIGFuZCBoYW5kbGUgZm9jdXNpbmcgdGhlIHByZXNzYWJsZSBlbGVtZW50IG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0KGUuY3VycmVudFRhcmdldCkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wb2ludGVyVHlwZSA9IGUucG9pbnRlclR5cGU7XG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc1ByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUG9pbnRlcklkID0gZS5wb2ludGVySWQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Rpc2FibGVkICYmICFwcmV2ZW50Rm9jdXNPblByZXNzKSAoMCwgJGJ4N1NMJGZvY3VzV2l0aG91dFNjcm9sbGluZykoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzKSAoMCwgJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JDE2YTQ2OTc0NjcxNzU0ODcpKHN0YXRlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc1N0YXJ0KGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIoKDAsICRieDdTTCRnZXRPd25lckRvY3VtZW50KShlLmN1cnJlbnRUYXJnZXQpLCBcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIoKDAsICRieDdTTCRnZXRPd25lckRvY3VtZW50KShlLmN1cnJlbnRUYXJnZXQpLCBcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcigoMCwgJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQpKGUuY3VycmVudFRhcmdldCksIFwicG9pbnRlcmNhbmNlbFwiLCBvblBvaW50ZXJDYW5jZWwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uTW91c2VEb3duID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBhbmQgRmlyZWZveCBvbiB0b3VjaCBXaW5kb3dzIGRldmljZXMgcmVxdWlyZSBtb3VzZSBkb3duIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSBjYW5jZWxlZCBpbiBhZGRpdGlvbiB0byBwb2ludGVyIGV2ZW50cywgb3IgYW4gZXh0cmEgYXN5bmNocm9ub3VzXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvY3VzIGV2ZW50IHdpbGwgYmUgZmlyZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkc2hvdWxkUHJldmVudERlZmF1bHQoZS5jdXJyZW50VGFyZ2V0KSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uUG9pbnRlclVwID0gKGUpPT57XG4gICAgICAgICAgICAgICAgLy8gaU9TIGZpcmVzIHBvaW50ZXJ1cCB3aXRoIHplcm8gd2lkdGggYW5kIGhlaWdodCwgc28gY2hlY2sgdGhlIHBvaW50ZXJUeXBlIHJlY29yZGVkIGR1cmluZyBwb2ludGVyZG93bi5cbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkgfHwgc3RhdGUucG9pbnRlclR5cGUgPT09IFwidmlydHVhbFwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gT25seSBoYW5kbGUgbGVmdCBjbGlja3NcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgb24gaU9TIHNvbWV0aW1lcyBmaXJlcyBwb2ludGVydXAgZXZlbnRzLCBldmVuXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgdG91Y2ggaXNuJ3Qgb3ZlciB0aGUgdGFyZ2V0LCBzbyBkb3VibGUgY2hlY2suXG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwICYmICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc092ZXJUYXJnZXQoZSwgZS5jdXJyZW50VGFyZ2V0KSkgdHJpZ2dlclByZXNzVXAoZSwgc3RhdGUucG9pbnRlclR5cGUgfHwgZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU2FmYXJpIG9uIGlPUyA8IDEzLjIgZG9lcyBub3QgaW1wbGVtZW50IHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgZXZlbnRzIGNvcnJlY3RseS5cbiAgICAgICAgICAgIC8vIFVzZSBwb2ludGVyIG1vdmUgZXZlbnRzIGluc3RlYWQgdG8gaW1wbGVtZW50IG91ciBvd24gaGl0IHRlc3RpbmcuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5OTgwM1xuICAgICAgICAgICAgbGV0IG9uUG9pbnRlck1vdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5wb2ludGVySWQgIT09IHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS50YXJnZXQgJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldChlLCBzdGF0ZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNPdmVyVGFyZ2V0ICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyUHJlc3NTdGFydCgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQoc3RhdGUudGFyZ2V0LCBlKSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS50YXJnZXQgJiYgc3RhdGUuaXNPdmVyVGFyZ2V0ICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJQcmVzc0VuZCgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQoc3RhdGUudGFyZ2V0LCBlKSwgc3RhdGUucG9pbnRlclR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsT25Qb2ludGVyRXhpdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uUG9pbnRlclVwID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUucG9pbnRlcklkID09PSBzdGF0ZS5hY3RpdmVQb2ludGVySWQgJiYgc3RhdGUuaXNQcmVzc2VkICYmIGUuYnV0dG9uID09PSAwICYmIHN0YXRlLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldChlLCBzdGF0ZS50YXJnZXQpICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHRyaWdnZXJQcmVzc0VuZCgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQoc3RhdGUudGFyZ2V0LCBlKSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkgdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcykgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1KShzdGF0ZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Qb2ludGVyQ2FuY2VsID0gKGUpPT57XG4gICAgICAgICAgICAgICAgY2FuY2VsKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25EcmFnU3RhcnQgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZG9lcyBub3QgY2FsbCBvblBvaW50ZXJDYW5jZWwgd2hlbiBhIGRyYWcgc3RhcnRzLCB3aGVyZWFzIENocm9tZSBhbmQgRmlyZWZveCBkby5cbiAgICAgICAgICAgICAgICBjYW5jZWwoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vbk1vdXNlRG93biA9IChlKT0+e1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgaGFuZGxlIGxlZnQgY2xpY2tzXG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwIHx8ICFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gRHVlIHRvIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzLCBlc3BlY2lhbGx5IG9uIG1vYmlsZSBicm93c2Vycywgd2UgcHJldmVudFxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgb24gbW91c2UgZG93biBhbmQgaGFuZGxlIGZvY3VzaW5nIHRoZSBwcmVzc2FibGUgZWxlbWVudCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRzaG91bGRQcmV2ZW50RGVmYXVsdChlLmN1cnJlbnRUYXJnZXQpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGUudGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXJUeXBlID0gKDAsICRieDdTTCRpc1ZpcnR1YWxDbGljaykoZS5uYXRpdmVFdmVudCkgPyBcInZpcnR1YWxcIiA6IFwibW91c2VcIjtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgIXByZXZlbnRGb2N1c09uUHJlc3MpICgwLCAkYng3U0wkZm9jdXNXaXRob3V0U2Nyb2xsaW5nKShlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NTdGFydChlLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcigoMCwgJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQpKGUuY3VycmVudFRhcmdldCksIFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uTW91c2VFbnRlciA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc1ByZXNzZWQgJiYgIXN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NTdGFydChlLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vbk1vdXNlTGVhdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNQcmVzc2VkICYmICFzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc0VuZChlLCBzdGF0ZS5wb2ludGVyVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxPblBvaW50ZXJFeGl0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Nb3VzZVVwID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzICYmIGUuYnV0dG9uID09PSAwKSB0cmlnZ2VyUHJlc3NVcChlLCBzdGF0ZS5wb2ludGVyVHlwZSB8fCBcIm1vdXNlXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvbk1vdXNlVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGhhbmRsZSBsZWZ0IGNsaWNrc1xuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUudGFyZ2V0ICYmICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc092ZXJUYXJnZXQoZSwgc3RhdGUudGFyZ2V0KSAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB0cmlnZ2VyUHJlc3NFbmQoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS50YXJnZXQgJiYgc3RhdGUuaXNPdmVyVGFyZ2V0ICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHRyaWdnZXJQcmVzc0VuZCgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQoc3RhdGUudGFyZ2V0LCBlKSwgc3RhdGUucG9pbnRlclR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uVG91Y2hTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCB0b3VjaCA9ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRUb3VjaEZyb21FdmVudChlLm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRvdWNoKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUG9pbnRlcklkID0gdG91Y2guaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGUudGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXJUeXBlID0gXCJ0b3VjaFwiO1xuICAgICAgICAgICAgICAgIC8vIER1ZSB0byBicm93c2VyIGluY29uc2lzdGVuY2llcywgZXNwZWNpYWxseSBvbiBtb2JpbGUgYnJvd3NlcnMsIHdlIHByZXZlbnQgZGVmYXVsdFxuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBlbXVsYXRlZCBtb3VzZSBldmVudCBhbmQgaGFuZGxlIGZvY3VzaW5nIHRoZSBwcmVzc2FibGUgZWxlbWVudCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Rpc2FibGVkICYmICFwcmV2ZW50Rm9jdXNPblByZXNzKSAoMCwgJGJ4N1NMJGZvY3VzV2l0aG91dFNjcm9sbGluZykoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3MpICgwLCAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkMTZhNDY5NzQ2NzE3NTQ4Nykoc3RhdGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzU3RhcnQoZSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIoKDAsICRieDdTTCRnZXRPd25lcldpbmRvdykoZS5jdXJyZW50VGFyZ2V0KSwgXCJzY3JvbGxcIiwgb25TY3JvbGwsIHRydWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Ub3VjaE1vdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0b3VjaCA9ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRUb3VjaEJ5SWQoZS5uYXRpdmVFdmVudCwgc3RhdGUuYWN0aXZlUG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG91Y2ggJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldCh0b3VjaCwgZS5jdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzU3RhcnQoZSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzRW5kKGUsIHN0YXRlLnBvaW50ZXJUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbE9uUG9pbnRlckV4aXQoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vblRvdWNoRW5kID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc1ByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdG91Y2ggPSAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0VG91Y2hCeUlkKGUubmF0aXZlRXZlbnQsIHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoICYmICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc092ZXJUYXJnZXQodG91Y2gsIGUuY3VycmVudFRhcmdldCkgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyUHJlc3NVcChlLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc0VuZChlLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzRW5kKGUsIHN0YXRlLnBvaW50ZXJUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQb2ludGVySWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS50YXJnZXQgJiYgIWFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3MpICgwLCAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkYjBkNmZhMWFiMzJlMzI5NSkoc3RhdGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uVG91Y2hDYW5jZWwgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc1ByZXNzZWQpIGNhbmNlbChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25TY3JvbGwgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNQcmVzc2VkICYmIGUudGFyZ2V0LmNvbnRhaW5zKHN0YXRlLnRhcmdldCkpIGNhbmNlbCh7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHN0YXRlLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsdEtleTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uRHJhZ1N0YXJ0ID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FuY2VsKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlc3NQcm9wcztcbiAgICB9LCBbXG4gICAgICAgIGFkZEdsb2JhbExpc3RlbmVyLFxuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICBwcmV2ZW50Rm9jdXNPblByZXNzLFxuICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMsXG4gICAgICAgIGFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3MsXG4gICAgICAgIGNhbmNlbCxcbiAgICAgICAgY2FuY2VsT25Qb2ludGVyRXhpdCxcbiAgICAgICAgdHJpZ2dlclByZXNzRW5kLFxuICAgICAgICB0cmlnZ2VyUHJlc3NTdGFydCxcbiAgICAgICAgdHJpZ2dlclByZXNzVXBcbiAgICBdKTtcbiAgICAvLyBSZW1vdmUgdXNlci1zZWxlY3Q6IG5vbmUgaW4gY2FzZSBjb21wb25lbnQgdW5tb3VudHMgaW1tZWRpYXRlbHkgYWZ0ZXIgcHJlc3NTdGFydFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgKDAsICRieDdTTCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdmFyIF9yZWZfY3VycmVudF90YXJnZXQ7XG4gICAgICAgICAgICBpZiAoIWFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3MpIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgICAgICgwLCAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkYjBkNmZhMWFiMzJlMzI5NSkoKF9yZWZfY3VycmVudF90YXJnZXQgPSByZWYuY3VycmVudC50YXJnZXQpICE9PSBudWxsICYmIF9yZWZfY3VycmVudF90YXJnZXQgIT09IHZvaWQgMCA/IF9yZWZfY3VycmVudF90YXJnZXQgOiB1bmRlZmluZWQpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzc1xuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzUHJlc3NlZDogaXNQcmVzc2VkUHJvcCB8fCBpc1ByZXNzZWQsXG4gICAgICAgIHByZXNzUHJvcHM6ICgwLCAkYng3U0wkbWVyZ2VQcm9wcykoZG9tUHJvcHMsIHByZXNzUHJvcHMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc0hUTUxBbmNob3JMaW5rKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQudGFnTmFtZSA9PT0gXCJBXCIgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImhyZWZcIik7XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNWYWxpZEtleWJvYXJkRXZlbnQoZXZlbnQsIGN1cnJlbnRUYXJnZXQpIHtcbiAgICBjb25zdCB7IGtleToga2V5LCBjb2RlOiBjb2RlIH0gPSBldmVudDtcbiAgICBjb25zdCBlbGVtZW50ID0gY3VycmVudFRhcmdldDtcbiAgICBjb25zdCByb2xlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpO1xuICAgIC8vIEFjY2Vzc2liaWxpdHkgZm9yIGtleWJvYXJkcy4gU3BhY2UgYW5kIEVudGVyIG9ubHkuXG4gICAgLy8gXCJTcGFjZWJhclwiIGlzIGZvciBJRSAxMVxuICAgIHJldHVybiAoa2V5ID09PSBcIkVudGVyXCIgfHwga2V5ID09PSBcIiBcIiB8fCBrZXkgPT09IFwiU3BhY2ViYXJcIiB8fCBjb2RlID09PSBcIlNwYWNlXCIpICYmICEoZWxlbWVudCBpbnN0YW5jZW9mICgwLCAkYng3U0wkZ2V0T3duZXJXaW5kb3cpKGVsZW1lbnQpLkhUTUxJbnB1dEVsZW1lbnQgJiYgISRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkSW5wdXRLZXkoZWxlbWVudCwga2V5KSB8fCBlbGVtZW50IGluc3RhbmNlb2YgKDAsICRieDdTTCRnZXRPd25lcldpbmRvdykoZWxlbWVudCkuSFRNTFRleHRBcmVhRWxlbWVudCB8fCBlbGVtZW50LmlzQ29udGVudEVkaXRhYmxlKSAmJiAvLyBMaW5rcyBzaG91bGQgb25seSB0cmlnZ2VyIHdpdGggRW50ZXIga2V5XG4gICAgISgocm9sZSA9PT0gXCJsaW5rXCIgfHwgIXJvbGUgJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzSFRNTEFuY2hvckxpbmsoZWxlbWVudCkpICYmIGtleSAhPT0gXCJFbnRlclwiKTtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRUb3VjaEZyb21FdmVudChldmVudCkge1xuICAgIGNvbnN0IHsgdGFyZ2V0VG91Y2hlczogdGFyZ2V0VG91Y2hlcyB9ID0gZXZlbnQ7XG4gICAgaWYgKHRhcmdldFRvdWNoZXMubGVuZ3RoID4gMCkgcmV0dXJuIHRhcmdldFRvdWNoZXNbMF07XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0VG91Y2hCeUlkKGV2ZW50LCBwb2ludGVySWQpIHtcbiAgICBjb25zdCBjaGFuZ2VkVG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSBwb2ludGVySWQpIHJldHVybiB0b3VjaDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQodGFyZ2V0LCBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudFRhcmdldDogdGFyZ2V0LFxuICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleTogZS5hbHRLZXlcbiAgICB9O1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFBvaW50Q2xpZW50UmVjdChwb2ludCkge1xuICAgIGxldCBvZmZzZXRYID0gMDtcbiAgICBsZXQgb2Zmc2V0WSA9IDA7XG4gICAgaWYgKHBvaW50LndpZHRoICE9PSB1bmRlZmluZWQpIG9mZnNldFggPSBwb2ludC53aWR0aCAvIDI7XG4gICAgZWxzZSBpZiAocG9pbnQucmFkaXVzWCAhPT0gdW5kZWZpbmVkKSBvZmZzZXRYID0gcG9pbnQucmFkaXVzWDtcbiAgICBpZiAocG9pbnQuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIG9mZnNldFkgPSBwb2ludC5oZWlnaHQgLyAyO1xuICAgIGVsc2UgaWYgKHBvaW50LnJhZGl1c1kgIT09IHVuZGVmaW5lZCkgb2Zmc2V0WSA9IHBvaW50LnJhZGl1c1k7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBwb2ludC5jbGllbnRZIC0gb2Zmc2V0WSxcbiAgICAgICAgcmlnaHQ6IHBvaW50LmNsaWVudFggKyBvZmZzZXRYLFxuICAgICAgICBib3R0b206IHBvaW50LmNsaWVudFkgKyBvZmZzZXRZLFxuICAgICAgICBsZWZ0OiBwb2ludC5jbGllbnRYIC0gb2Zmc2V0WFxuICAgIH07XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkYXJlUmVjdGFuZ2xlc092ZXJsYXBwaW5nKGEsIGIpIHtcbiAgICAvLyBjaGVjayBpZiB0aGV5IGNhbm5vdCBvdmVybGFwIG9uIHggYXhpc1xuICAgIGlmIChhLmxlZnQgPiBiLnJpZ2h0IHx8IGIubGVmdCA+IGEucmlnaHQpIHJldHVybiBmYWxzZTtcbiAgICAvLyBjaGVjayBpZiB0aGV5IGNhbm5vdCBvdmVybGFwIG9uIHkgYXhpc1xuICAgIGlmIChhLnRvcCA+IGIuYm90dG9tIHx8IGIudG9wID4gYS5ib3R0b20pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc092ZXJUYXJnZXQocG9pbnQsIHRhcmdldCkge1xuICAgIGxldCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBwb2ludFJlY3QgPSAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0UG9pbnRDbGllbnRSZWN0KHBvaW50KTtcbiAgICByZXR1cm4gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGFyZVJlY3RhbmdsZXNPdmVybGFwcGluZyhyZWN0LCBwb2ludFJlY3QpO1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0KHRhcmdldCkge1xuICAgIC8vIFdlIGNhbm5vdCBwcmV2ZW50IGRlZmF1bHQgaWYgdGhlIHRhcmdldCBpcyBhIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgIHJldHVybiAhKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB8fCAhdGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRzaG91bGRQcmV2ZW50RGVmYXVsdEtleWJvYXJkKHRhcmdldCwga2V5KSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHJldHVybiAhJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRJbnB1dEtleSh0YXJnZXQsIGtleSk7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSByZXR1cm4gdGFyZ2V0LnR5cGUgIT09IFwic3VibWl0XCIgJiYgdGFyZ2V0LnR5cGUgIT09IFwicmVzZXRcIjtcbiAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzSFRNTEFuY2hvckxpbmsodGFyZ2V0KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJG5vblRleHRJbnB1dFR5cGVzID0gbmV3IFNldChbXG4gICAgXCJjaGVja2JveFwiLFxuICAgIFwicmFkaW9cIixcbiAgICBcInJhbmdlXCIsXG4gICAgXCJjb2xvclwiLFxuICAgIFwiZmlsZVwiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwic3VibWl0XCIsXG4gICAgXCJyZXNldFwiXG5dKTtcbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkSW5wdXRLZXkodGFyZ2V0LCBrZXkpIHtcbiAgICAvLyBPbmx5IHNwYWNlIHNob3VsZCB0b2dnbGUgY2hlY2tib3hlcyBhbmQgcmFkaW9zLCBub3QgZW50ZXIuXG4gICAgcmV0dXJuIHRhcmdldC50eXBlID09PSBcImNoZWNrYm94XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwicmFkaW9cIiA/IGtleSA9PT0gXCIgXCIgOiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkbm9uVGV4dElucHV0VHlwZXMuaGFzKHRhcmdldC50eXBlKTtcbn1cblxuXG5cbmNvbnN0ICQzYjExN2U0M2RjMGNhOTVkJGV4cG9ydCQyN2M3MDFlZDllNDQ5ZTk5ID0gLyojX19QVVJFX18qLyAoMCwgJGJ4N1NMJHJlYWN0KS5mb3J3YXJkUmVmKCh7IGNoaWxkcmVuOiBjaGlsZHJlbiwgLi4ucHJvcHMgfSwgcmVmKT0+e1xuICAgIHJlZiA9ICgwLCAkYng3U0wkdXNlT2JqZWN0UmVmKShyZWYpO1xuICAgIGxldCB7IHByZXNzUHJvcHM6IHByZXNzUHJvcHMgfSA9ICgwLCAkZjZjMzFjY2UyYWRmNjU0ZiRleHBvcnQkNDU3MTJlY2VkYTZmYWQyMSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgcmVmOiByZWZcbiAgICB9KTtcbiAgICBsZXQgY2hpbGQgPSAoMCwgJGJ4N1NMJHJlYWN0KS5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJGJ4N1NMJHJlYWN0KS5jbG9uZUVsZW1lbnQoY2hpbGQsIC8vIEB0cy1pZ25vcmVcbiAgICB7XG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICAuLi4oMCwgJGJ4N1NMJG1lcmdlUHJvcHMpKGNoaWxkLnByb3BzLCBwcmVzc1Byb3BzKVxuICAgIH0pO1xufSk7XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmNvbnN0ICRmMWFiOGM3NTQ3OGM2ZjczJGV4cG9ydCQzMzUxODcxZWU0YjI4OGI4ID0gLyojX19QVVJFX18qLyAoMCwgJGJ4N1NMJHJlYWN0KS5mb3J3YXJkUmVmKCh7IGNoaWxkcmVuOiBjaGlsZHJlbiwgLi4ucHJvcHMgfSwgcmVmKT0+e1xuICAgIGxldCBpc1JlZ2lzdGVyZWQgPSAoMCwgJGJ4N1NMJHVzZVJlZikoZmFsc2UpO1xuICAgIGxldCBwcmV2Q29udGV4dCA9ICgwLCAkYng3U0wkdXNlQ29udGV4dCkoKDAsICRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1KSk7XG4gICAgcmVmID0gKDAsICRieDdTTCR1c2VPYmplY3RSZWYpKHJlZiB8fCAocHJldkNvbnRleHQgPT09IG51bGwgfHwgcHJldkNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZDb250ZXh0LnJlZikpO1xuICAgIGxldCBjb250ZXh0ID0gKDAsICRieDdTTCRtZXJnZVByb3BzKShwcmV2Q29udGV4dCB8fCB7fSwge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgcmVmOiByZWYsXG4gICAgICAgIHJlZ2lzdGVyICgpIHtcbiAgICAgICAgICAgIGlzUmVnaXN0ZXJlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwcmV2Q29udGV4dCkgcHJldkNvbnRleHQucmVnaXN0ZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgICgwLCAkYng3U0wkdXNlU3luY1JlZikocHJldkNvbnRleHQsIHJlZik7XG4gICAgKDAsICRieDdTTCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmICghaXNSZWdpc3RlcmVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkEgUHJlc3NSZXNwb25kZXIgd2FzIHJlbmRlcmVkIHdpdGhvdXQgYSBwcmVzc2FibGUgY2hpbGQuIEVpdGhlciBjYWxsIHRoZSB1c2VQcmVzcyBob29rLCBvciB3cmFwIHlvdXIgRE9NIG5vZGUgd2l0aCA8UHJlc3NhYmxlPiBjb21wb25lbnQuXCIpO1xuICAgICAgICAgICAgaXNSZWdpc3RlcmVkLmN1cnJlbnQgPSB0cnVlOyAvLyBvbmx5IHdhcm4gb25jZSBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJGJ4N1NMJHJlYWN0KS5jcmVhdGVFbGVtZW50KCgwLCAkYWUxZWViYThiOWVhZmQwOCRleHBvcnQkNTE2NWVjY2IzNWFhYWRiNSkuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHRcbiAgICB9LCBjaGlsZHJlbik7XG59KTtcbmZ1bmN0aW9uICRmMWFiOGM3NTQ3OGM2ZjczJGV4cG9ydCRjZjc1NDI4ZTBiOWVkMWVhKHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pIHtcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkYng3U0wkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICByZWdpc3RlcjogKCk9Pnt9XG4gICAgICAgIH0pLCBbXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICRieDdTTCRyZWFjdCkuY3JlYXRlRWxlbWVudCgoMCwgJGFlMWVlYmE4YjllYWZkMDgkZXhwb3J0JDUxNjVlY2NiMzVhYWFkYjUpLlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgfSwgY2hpbGRyZW4pO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSByZWFjdC5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBmb3IgdGhlIGZvbGxvd2luZyBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBOT1RJQ0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9jYzdjMWFlY2U0NmE2YjY5YjQxOTU4ZDczMWUwZmQyN2M5NGJmYzZjL3BhY2thZ2VzL3JlYWN0LWludGVyYWN0aW9uc1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNsYXNzICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ5MDVlN2ZjNTQ0YTcxZjM2IHtcbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgfVxuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgdGhpcy5uYXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9ICgpPT50cnVlO1xuICAgIH1cbiAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwZXJzaXN0KCkge31cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBuYXRpdmVFdmVudCl7XG4gICAgICAgIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQ7XG4gICAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG5hdGl2ZUV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHRoaXMucmVsYXRlZFRhcmdldCA9IG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIHRoaXMuYnViYmxlcyA9IG5hdGl2ZUV2ZW50LmJ1YmJsZXM7XG4gICAgICAgIHRoaXMuY2FuY2VsYWJsZSA9IG5hdGl2ZUV2ZW50LmNhbmNlbGFibGU7XG4gICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICAgIHRoaXMuZXZlbnRQaGFzZSA9IG5hdGl2ZUV2ZW50LmV2ZW50UGhhc2U7XG4gICAgICAgIHRoaXMuaXNUcnVzdGVkID0gbmF0aXZlRXZlbnQuaXNUcnVzdGVkO1xuICAgICAgICB0aGlzLnRpbWVTdGFtcCA9IG5hdGl2ZUV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG59XG5mdW5jdGlvbiAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkNzE1YzY4MmQwOWQ2MzljYyhvbkJsdXIpIHtcbiAgICBsZXQgc3RhdGVSZWYgPSAoMCwgJGJ4N1NMJHVzZVJlZikoe1xuICAgICAgICBpc0ZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICBvYnNlcnZlcjogbnVsbFxuICAgIH0pO1xuICAgIC8vIENsZWFuIHVwIE11dGF0aW9uT2JzZXJ2ZXIgb24gdW5tb3VudC4gU2VlIGJlbG93LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgKDAsICRieDdTTCR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVSZWYuY3VycmVudDtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoc3RhdGUub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgc3RhdGUub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBsZXQgZGlzcGF0Y2hCbHVyID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKGUpPT57XG4gICAgICAgIG9uQmx1ciA9PT0gbnVsbCB8fCBvbkJsdXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQmx1cihlKTtcbiAgICB9KTtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBkdXJpbmcgYSBSZWFjdCBvbkZvY3VzIGV2ZW50LlxuICAgIHJldHVybiAoMCwgJGJ4N1NMJHVzZUNhbGxiYWNrKSgoZSk9PntcbiAgICAgICAgLy8gUmVhY3QgZG9lcyBub3QgZmlyZSBvbkJsdXIgd2hlbiBhbiBlbGVtZW50IGlzIGRpc2FibGVkLiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzkxNDJcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBmaXJlIGEgbmF0aXZlIGZvY3Vzb3V0IGV2ZW50IGluIHRoaXMgY2FzZSwgZXhjZXB0IGZvciBGaXJlZm94LiBJbiB0aGF0IGNhc2UsIHdlIHVzZSBhXG4gICAgICAgIC8vIE11dGF0aW9uT2JzZXJ2ZXIgdG8gd2F0Y2ggZm9yIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUsIGFuZCBkaXNwYXRjaCB0aGVzZSBldmVudHMgb3Vyc2VsdmVzLlxuICAgICAgICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBkbywgZm9jdXNvdXQgZmlyZXMgYmVmb3JlIHRoZSBNdXRhdGlvbk9ic2VydmVyLCBzbyBvbkJsdXIgc2hvdWxkIG5vdCBmaXJlIHR3aWNlLlxuICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHwgZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50IHx8IGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIGxldCBvbkJsdXJIYW5kbGVyID0gKGUpPT57XG4gICAgICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmRpc2FibGVkKSAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgZGlzcGF0Y2ggYSAoZmFrZSkgUmVhY3Qgc3ludGhldGljIGV2ZW50LlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoQmx1cihuZXcgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDkwNWU3ZmM1NDRhNzFmMzYoXCJibHVyXCIsIGUpKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBubyBsb25nZXIgbmVlZCB0aGUgTXV0YXRpb25PYnNlcnZlciBvbmNlIHRoZSB0YXJnZXQgaXMgYmx1cnJlZC5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgb25CbHVySGFuZGxlciwge1xuICAgICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlUmVmLmN1cnJlbnQuaXNGb2N1c2VkICYmIHRhcmdldC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlUmVmX2N1cnJlbnRfb2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgICAgIChfc3RhdGVSZWZfY3VycmVudF9vYnNlcnZlciA9IHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIpID09PSBudWxsIHx8IF9zdGF0ZVJlZl9jdXJyZW50X29ic2VydmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVSZWZfY3VycmVudF9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWxhdGVkVGFyZ2V0RWwgPSB0YXJnZXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPyBudWxsIDogZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEZvY3VzRXZlbnQoXCJibHVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXRFbFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBGb2N1c0V2ZW50KFwiZm9jdXNvdXRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXRFbFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyLm9ic2VydmUodGFyZ2V0LCB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoQmx1clxuICAgIF0pO1xufVxuXG5cbmZ1bmN0aW9uICRhMWVhNTlkNjgyNzBmMGRkJGV4cG9ydCRmODE2OGQ4ZGQ4ZmQ2NmU2KHByb3BzKSB7XG4gICAgbGV0IHsgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCwgb25Gb2N1czogb25Gb2N1c1Byb3AsIG9uQmx1cjogb25CbHVyUHJvcCwgb25Gb2N1c0NoYW5nZTogb25Gb2N1c0NoYW5nZSB9ID0gcHJvcHM7XG4gICAgY29uc3Qgb25CbHVyID0gKDAsICRieDdTTCR1c2VDYWxsYmFjaykoKGUpPT57XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAob25CbHVyUHJvcCkgb25CbHVyUHJvcChlKTtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzQ2hhbmdlKSBvbkZvY3VzQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBvbkJsdXJQcm9wLFxuICAgICAgICBvbkZvY3VzQ2hhbmdlXG4gICAgXSk7XG4gICAgY29uc3Qgb25TeW50aGV0aWNGb2N1cyA9ICgwLCAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkNzE1YzY4MmQwOWQ2MzljYykob25CbHVyKTtcbiAgICBjb25zdCBvbkZvY3VzID0gKDAsICRieDdTTCR1c2VDYWxsYmFjaykoKGUpPT57XG4gICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYWN0dWFsbHkgbWF0Y2hlcyBlLnRhcmdldCBpbiBjYXNlIGEgcHJldmlvdXNseSBjaGFpbmVkXG4gICAgICAgIC8vIGZvY3VzIGhhbmRsZXIgYWxyZWFkeSBtb3ZlZCBmb2N1cyBzb21ld2hlcmUgZWxzZS5cbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZS50YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzUHJvcCkgb25Gb2N1c1Byb3AoZSk7XG4gICAgICAgICAgICBpZiAob25Gb2N1c0NoYW5nZSkgb25Gb2N1c0NoYW5nZSh0cnVlKTtcbiAgICAgICAgICAgIG9uU3ludGhldGljRm9jdXMoZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uRm9jdXNDaGFuZ2UsXG4gICAgICAgIG9uRm9jdXNQcm9wLFxuICAgICAgICBvblN5bnRoZXRpY0ZvY3VzXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNQcm9wczoge1xuICAgICAgICAgICAgb25Gb2N1czogIWlzRGlzYWJsZWQgJiYgKG9uRm9jdXNQcm9wIHx8IG9uRm9jdXNDaGFuZ2UgfHwgb25CbHVyUHJvcCkgPyBvbkZvY3VzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb25CbHVyOiAhaXNEaXNhYmxlZCAmJiAob25CbHVyUHJvcCB8fCBvbkZvY3VzQ2hhbmdlKSA/IG9uQmx1ciA6IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuXG5cbmxldCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ID0gbnVsbDtcbmxldCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY2hhbmdlSGFuZGxlcnMgPSBuZXcgU2V0KCk7XG5sZXQgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc1NldHVwR2xvYmFsTGlzdGVuZXJzID0gZmFsc2U7XG5sZXQgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSBmYWxzZTtcbmxldCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzQmx1cnJlZFdpbmRvd1JlY2VudGx5ID0gZmFsc2U7XG4vLyBPbmx5IFRhYiBvciBFc2Mga2V5cyB3aWxsIG1ha2UgZm9jdXMgdmlzaWJsZSBvbiB0ZXh0IGlucHV0IGVsZW1lbnRzXG5jb25zdCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkRk9DVVNfVklTSUJMRV9JTlBVVF9LRVlTID0ge1xuICAgIFRhYjogdHJ1ZSxcbiAgICBFc2NhcGU6IHRydWVcbn07XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdHJpZ2dlckNoYW5nZUhhbmRsZXJzKG1vZGFsaXR5LCBlKSB7XG4gICAgZm9yIChsZXQgaGFuZGxlciBvZiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY2hhbmdlSGFuZGxlcnMpaGFuZGxlcihtb2RhbGl0eSwgZSk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgYSBLZXlib2FyZEV2ZW50IGlzIHVubW9kaWZpZWQgYW5kIGNvdWxkIG1ha2Uga2V5Ym9hcmQgZm9jdXMgc3R5bGVzIHZpc2libGUuXG4gKi8gZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGlzVmFsaWRLZXkoZSkge1xuICAgIC8vIENvbnRyb2wgYW5kIFNoaWZ0IGtleXMgdHJpZ2dlciB3aGVuIG5hdmlnYXRpbmcgYmFjayB0byB0aGUgdGFiIHdpdGgga2V5Ym9hcmQuXG4gICAgcmV0dXJuICEoZS5tZXRhS2V5IHx8ICEoMCwgJGJ4N1NMJGlzTWFjKSgpICYmIGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLmtleSA9PT0gXCJDb250cm9sXCIgfHwgZS5rZXkgPT09IFwiU2hpZnRcIiB8fCBlLmtleSA9PT0gXCJNZXRhXCIpO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUtleWJvYXJkRXZlbnQoZSkge1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gdHJ1ZTtcbiAgICBpZiAoJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGlzVmFsaWRLZXkoZSkpIHtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IFwia2V5Ym9hcmRcIjtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHRyaWdnZXJDaGFuZ2VIYW5kbGVycyhcImtleWJvYXJkXCIsIGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQoZSkge1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBcInBvaW50ZXJcIjtcbiAgICBpZiAoZS50eXBlID09PSBcIm1vdXNlZG93blwiIHx8IGUudHlwZSA9PT0gXCJwb2ludGVyZG93blwiKSB7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gdHJ1ZTtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHRyaWdnZXJDaGFuZ2VIYW5kbGVycyhcInBvaW50ZXJcIiwgZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUNsaWNrRXZlbnQoZSkge1xuICAgIGlmICgoMCwgJGJ4N1NMJGlzVmlydHVhbENsaWNrKShlKSkge1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IHRydWU7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBcInZpcnR1YWxcIjtcbiAgICB9XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlRm9jdXNFdmVudChlKSB7XG4gICAgLy8gRmlyZWZveCBmaXJlcyB0d28gZXh0cmEgZm9jdXMgZXZlbnRzIHdoZW4gdGhlIHVzZXIgZmlyc3QgY2xpY2tzIGludG8gYW4gaWZyYW1lOlxuICAgIC8vIGZpcnN0IG9uIHRoZSB3aW5kb3csIHRoZW4gb24gdGhlIGRvY3VtZW50LiBXZSBpZ25vcmUgdGhlc2UgZXZlbnRzIHNvIHRoZXkgZG9uJ3RcbiAgICAvLyBjYXVzZSBrZXlib2FyZCBmb2N1cyByaW5ncyB0byBhcHBlYXIuXG4gICAgaWYgKGUudGFyZ2V0ID09PSB3aW5kb3cgfHwgZS50YXJnZXQgPT09IGRvY3VtZW50KSByZXR1cm47XG4gICAgLy8gSWYgYSBmb2N1cyBldmVudCBvY2N1cnMgd2l0aG91dCBhIHByZWNlZGluZyBrZXlib2FyZCBvciBwb2ludGVyIGV2ZW50LCBzd2l0Y2ggdG8gdmlydHVhbCBtb2RhbGl0eS5cbiAgICAvLyBUaGlzIG9jY3VycywgZm9yIGV4YW1wbGUsIHdoZW4gbmF2aWdhdGluZyBhIGZvcm0gd2l0aCB0aGUgbmV4dC9wcmV2aW91cyBidXR0b25zIG9uIGlPUy5cbiAgICBpZiAoISQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzICYmICEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzQmx1cnJlZFdpbmRvd1JlY2VudGx5KSB7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBcInZpcnR1YWxcIjtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHRyaWdnZXJDaGFuZ2VIYW5kbGVycyhcInZpcnR1YWxcIiwgZSk7XG4gICAgfVxuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gZmFsc2U7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0JsdXJyZWRXaW5kb3dSZWNlbnRseSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVdpbmRvd0JsdXIoKSB7XG4gICAgLy8gV2hlbiB0aGUgd2luZG93IGlzIGJsdXJyZWQsIHJlc2V0IHN0YXRlLiBUaGlzIGlzIG5lY2Vzc2FyeSB3aGVuIHRhYmJpbmcgb3V0IG9mIHRoZSB3aW5kb3csXG4gICAgLy8gZm9yIGV4YW1wbGUsIHNpbmNlIGEgc3Vic2VxdWVudCBmb2N1cyBldmVudCB3b24ndCBiZSBmaXJlZC5cbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IGZhbHNlO1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNCbHVycmVkV2luZG93UmVjZW50bHkgPSB0cnVlO1xufVxuLyoqXG4gKiBTZXR1cCBnbG9iYWwgZXZlbnQgbGlzdGVuZXJzIHRvIGNvbnRyb2wgd2hlbiBrZXlib2FyZCBmb2N1cyBzdHlsZSBzaG91bGQgYmUgdmlzaWJsZS5cbiAqLyBmdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkc2V0dXBHbG9iYWxGb2N1c0V2ZW50cygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzU2V0dXBHbG9iYWxMaXN0ZW5lcnMpIHJldHVybjtcbiAgICAvLyBQcm9ncmFtbWF0aWMgZm9jdXMoKSBjYWxscyBzaG91bGRuJ3QgYWZmZWN0IHRoZSBjdXJyZW50IGlucHV0IG1vZGFsaXR5LlxuICAgIC8vIEhvd2V2ZXIsIHdlIG5lZWQgdG8gZGV0ZWN0IG90aGVyIGNhc2VzIHdoZW4gYSBmb2N1cyBldmVudCBvY2N1cnMgd2l0aG91dFxuICAgIC8vIGEgcHJlY2VkaW5nIHVzZXIgZXZlbnQgKGUuZy4gc2NyZWVuIHJlYWRlciBmb2N1cykuIE92ZXJyaWRpbmcgdGhlIGZvY3VzXG4gICAgLy8gbWV0aG9kIG9uIEhUTUxFbGVtZW50LnByb3RvdHlwZSBpcyBhIGJpdCBoYWNreSwgYnV0IHdvcmtzLlxuICAgIGxldCBmb2N1cyA9IEhUTUxFbGVtZW50LnByb3RvdHlwZS5mb2N1cztcbiAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSB0cnVlO1xuICAgICAgICBmb2N1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUtleWJvYXJkRXZlbnQsIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlS2V5Ym9hcmRFdmVudCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVDbGlja0V2ZW50LCB0cnVlKTtcbiAgICAvLyBSZWdpc3RlciBmb2N1cyBldmVudHMgb24gdGhlIHdpbmRvdyBzbyB0aGV5IGFyZSBzdXJlIHRvIGhhcHBlblxuICAgIC8vIGJlZm9yZSBSZWFjdCdzIGV2ZW50IGxpc3RlbmVycyAocmVnaXN0ZXJlZCBvbiB0aGUgZG9jdW1lbnQpLlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUZvY3VzRXZlbnQsIHRydWUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlV2luZG93Qmx1ciwgZmFsc2UpO1xuICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgIH1cbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzU2V0dXBHbG9iYWxMaXN0ZW5lcnMgPSB0cnVlO1xufVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMoKTtcbiAgICBlbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzKTtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRiOWIzZGZkZGFiMTdkYjI3KCkge1xuICAgIHJldHVybiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ICE9PSBcInBvaW50ZXJcIjtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ2MzBmZjY1M2M1YWRhNmE5KCkge1xuICAgIHJldHVybiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5O1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDgzOTdkZGZjNTA0ZmRiOWEobW9kYWxpdHkpIHtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ID0gbW9kYWxpdHk7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHRyaWdnZXJDaGFuZ2VIYW5kbGVycyhtb2RhbGl0eSwgbnVsbCk7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkOThlMjBlYzkyZjYxNGNmZSgpIHtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkc2V0dXBHbG9iYWxGb2N1c0V2ZW50cygpO1xuICAgIGxldCBbbW9kYWxpdHksIHNldE1vZGFsaXR5XSA9ICgwLCAkYng3U0wkdXNlU3RhdGUpKCQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkpO1xuICAgICgwLCAkYng3U0wkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgaGFuZGxlciA9ICgpPT57XG4gICAgICAgICAgICBzZXRNb2RhbGl0eSgkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5KTtcbiAgICAgICAgfTtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzLmFkZChoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY2hhbmdlSGFuZGxlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKDAsICRieDdTTCR1c2VJc1NTUikoKSA/IG51bGwgOiBtb2RhbGl0eTtcbn1cbmNvbnN0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRub25UZXh0SW5wdXRUeXBlcyA9IG5ldyBTZXQoW1xuICAgIFwiY2hlY2tib3hcIixcbiAgICBcInJhZGlvXCIsXG4gICAgXCJyYW5nZVwiLFxuICAgIFwiY29sb3JcIixcbiAgICBcImZpbGVcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJidXR0b25cIixcbiAgICBcInN1Ym1pdFwiLFxuICAgIFwicmVzZXRcIlxuXSk7XG4vKipcbiAqIElmIHRoaXMgaXMgYXR0YWNoZWQgdG8gdGV4dCBpbnB1dCBjb21wb25lbnQsIHJldHVybiBpZiB0aGUgZXZlbnQgaXMgYSBmb2N1cyBldmVudCAoVGFiL0VzY2FwZSBrZXlzIHByZXNzZWQpIHNvIHRoYXRcbiAqIGZvY3VzIHZpc2libGUgc3R5bGUgY2FuIGJlIHByb3Blcmx5IHNldC5cbiAqLyBmdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNLZXlib2FyZEZvY3VzRXZlbnQoaXNUZXh0SW5wdXQsIG1vZGFsaXR5LCBlKSB7XG4gICAgdmFyIF9lX3RhcmdldDtcbiAgICBpc1RleHRJbnB1dCA9IGlzVGV4dElucHV0IHx8IChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudGFyZ2V0KSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgISQ1MDdmYWJlMTBlNzFjNmZiJHZhciRub25UZXh0SW5wdXRUeXBlcy5oYXMoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2VfdGFyZ2V0ID0gZS50YXJnZXQpID09PSBudWxsIHx8IF9lX3RhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VfdGFyZ2V0LnR5cGUpIHx8IChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudGFyZ2V0KSBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50YXJnZXQpIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50YXJnZXQuaXNDb250ZW50RWRpdGFibGUpO1xuICAgIHJldHVybiAhKGlzVGV4dElucHV0ICYmIG1vZGFsaXR5ID09PSBcImtleWJvYXJkXCIgJiYgZSBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQgJiYgISQ1MDdmYWJlMTBlNzFjNmZiJHZhciRGT0NVU19WSVNJQkxFX0lOUFVUX0tFWVNbZS5rZXldKTtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRmZmQ5ZTUwMjFjMWZiMmQ2KHByb3BzID0ge30pIHtcbiAgICBsZXQgeyBpc1RleHRJbnB1dDogaXNUZXh0SW5wdXQsIGF1dG9Gb2N1czogYXV0b0ZvY3VzIH0gPSBwcm9wcztcbiAgICBsZXQgW2lzRm9jdXNWaXNpYmxlU3RhdGUsIHNldEZvY3VzVmlzaWJsZV0gPSAoMCwgJGJ4N1NMJHVzZVN0YXRlKShhdXRvRm9jdXMgfHwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGI5YjNkZmRkYWIxN2RiMjcoKSk7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGVjNzFiNGI4M2FjMDhlYzMoKGlzRm9jdXNWaXNpYmxlKT0+e1xuICAgICAgICBzZXRGb2N1c1Zpc2libGUoaXNGb2N1c1Zpc2libGUpO1xuICAgIH0sIFtcbiAgICAgICAgaXNUZXh0SW5wdXRcbiAgICBdLCB7XG4gICAgICAgIGlzVGV4dElucHV0OiBpc1RleHRJbnB1dFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzRm9jdXNWaXNpYmxlOiBpc0ZvY3VzVmlzaWJsZVN0YXRlXG4gICAgfTtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRlYzcxYjRiODNhYzA4ZWMzKGZuLCBkZXBzLCBvcHRzKSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMoKTtcbiAgICAoMCwgJGJ4N1NMJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IGhhbmRsZXIgPSAobW9kYWxpdHksIGUpPT57XG4gICAgICAgICAgICBpZiAoISQ1MDdmYWJlMTBlNzFjNmZiJHZhciRpc0tleWJvYXJkRm9jdXNFdmVudCghIShvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuaXNUZXh0SW5wdXQpLCBtb2RhbGl0eSwgZSkpIHJldHVybjtcbiAgICAgICAgICAgIGZuKCQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRiOWIzZGZkZGFiMTdkYjI3KCkpO1xuICAgICAgICB9O1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY2hhbmdlSGFuZGxlcnMuYWRkKGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycy5kZWxldGUoaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIGRlcHMpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSByZWFjdC5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBmb3IgdGhlIGZvbGxvd2luZyBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBOT1RJQ0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9jYzdjMWFlY2U0NmE2YjY5YjQxOTU4ZDczMWUwZmQyN2M5NGJmYzZjL3BhY2thZ2VzL3JlYWN0LWludGVyYWN0aW9uc1xuXG5cbmZ1bmN0aW9uICQ5YWI5NDI2MmJkMDA0N2M3JGV4cG9ydCQ0MjBlNjgyNzMxNjVmNGVjKHByb3BzKSB7XG4gICAgbGV0IHsgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCwgb25CbHVyV2l0aGluOiBvbkJsdXJXaXRoaW4sIG9uRm9jdXNXaXRoaW46IG9uRm9jdXNXaXRoaW4sIG9uRm9jdXNXaXRoaW5DaGFuZ2U6IG9uRm9jdXNXaXRoaW5DaGFuZ2UgfSA9IHByb3BzO1xuICAgIGxldCBzdGF0ZSA9ICgwLCAkYng3U0wkdXNlUmVmKSh7XG4gICAgICAgIGlzRm9jdXNXaXRoaW46IGZhbHNlXG4gICAgfSk7XG4gICAgbGV0IG9uQmx1ciA9ICgwLCAkYng3U0wkdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgb25CbHVyV2l0aGluIGFuZCB0aGVuIGltbWVkaWF0ZWx5IG9uRm9jdXNXaXRoaW4gYWdhaW5cbiAgICAgICAgLy8gd2hlbiBtb3ZpbmcgZm9jdXMgaW5zaWRlIHRoZSBlbGVtZW50LiBPbmx5IHRyaWdnZXIgaWYgdGhlIGN1cnJlbnRUYXJnZXQgZG9lc24ndFxuICAgICAgICAvLyBpbmNsdWRlIHRoZSByZWxhdGVkVGFyZ2V0ICh3aGVyZSBmb2N1cyBpcyBtb3ZpbmcpLlxuICAgICAgICBpZiAoc3RhdGUuY3VycmVudC5pc0ZvY3VzV2l0aGluICYmICFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudC5pc0ZvY3VzV2l0aGluID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAob25CbHVyV2l0aGluKSBvbkJsdXJXaXRoaW4oZSk7XG4gICAgICAgICAgICBpZiAob25Gb2N1c1dpdGhpbkNoYW5nZSkgb25Gb2N1c1dpdGhpbkNoYW5nZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uQmx1cldpdGhpbixcbiAgICAgICAgb25Gb2N1c1dpdGhpbkNoYW5nZSxcbiAgICAgICAgc3RhdGVcbiAgICBdKTtcbiAgICBsZXQgb25TeW50aGV0aWNGb2N1cyA9ICgwLCAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkNzE1YzY4MmQwOWQ2MzljYykob25CbHVyKTtcbiAgICBsZXQgb25Gb2N1cyA9ICgwLCAkYng3U0wkdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICAvLyBEb3VibGUgY2hlY2sgdGhhdCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFjdHVhbGx5IG1hdGNoZXMgZS50YXJnZXQgaW4gY2FzZSBhIHByZXZpb3VzbHkgY2hhaW5lZFxuICAgICAgICAvLyBmb2N1cyBoYW5kbGVyIGFscmVhZHkgbW92ZWQgZm9jdXMgc29tZXdoZXJlIGVsc2UuXG4gICAgICAgIGlmICghc3RhdGUuY3VycmVudC5pc0ZvY3VzV2l0aGluICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGUudGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAob25Gb2N1c1dpdGhpbikgb25Gb2N1c1dpdGhpbihlKTtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzV2l0aGluQ2hhbmdlKSBvbkZvY3VzV2l0aGluQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudC5pc0ZvY3VzV2l0aGluID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uU3ludGhldGljRm9jdXMoZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uRm9jdXNXaXRoaW4sXG4gICAgICAgIG9uRm9jdXNXaXRoaW5DaGFuZ2UsXG4gICAgICAgIG9uU3ludGhldGljRm9jdXNcbiAgICBdKTtcbiAgICBpZiAoaXNEaXNhYmxlZCkgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNXaXRoaW5Qcm9wczoge1xuICAgICAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIG5vdCBoYXZlIGJlZW4gbnVsbCwgdGhhdCB3b3VsZCBjb25mbGljdCBpbiBtZXJnZVByb3BzXG4gICAgICAgICAgICBvbkZvY3VzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvbkJsdXI6IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb2N1c1dpdGhpblByb3BzOiB7XG4gICAgICAgICAgICBvbkZvY3VzOiBvbkZvY3VzLFxuICAgICAgICAgICAgb25CbHVyOiBvbkJsdXJcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIHJlYWN0LlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGZvciB0aGUgZm9sbG93aW5nIGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL2NjN2MxYWVjZTQ2YTZiNjliNDE5NThkNzMxZTBmZDI3Yzk0YmZjNmMvcGFja2FnZXMvcmVhY3QtaW50ZXJhY3Rpb25zXG5cbi8vIGlPUyBmaXJlcyBvblBvaW50ZXJFbnRlciB0d2ljZTogb25jZSB3aXRoIHBvaW50ZXJUeXBlPVwidG91Y2hcIiBhbmQgYWdhaW4gd2l0aCBwb2ludGVyVHlwZT1cIm1vdXNlXCIuXG4vLyBXZSB3YW50IHRvIGlnbm9yZSB0aGVzZSBlbXVsYXRlZCBldmVudHMgc28gdGhleSBkbyBub3QgdHJpZ2dlciBob3ZlciBiZWhhdmlvci5cbi8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjE0NjA5LlxubGV0ICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gZmFsc2U7XG5sZXQgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhvdmVyQ291bnQgPSAwO1xuZnVuY3Rpb24gJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldEdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMoKSB7XG4gICAgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSB0cnVlO1xuICAgIC8vIENsZWFyIGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgYWZ0ZXIgYSBzaG9ydCB0aW1lb3V0LiBpT1MgZmlyZXMgb25Qb2ludGVyRW50ZXJcbiAgICAvLyB3aXRoIHBvaW50ZXJUeXBlPVwibW91c2VcIiBpbW1lZGlhdGVseSBhZnRlciBvblBvaW50ZXJVcCBhbmQgYmVmb3JlIG9uRm9jdXMuIE9uIG90aGVyXG4gICAgLy8gZGV2aWNlcyB0aGF0IGRvbid0IGhhdmUgdGhpcyBxdWlyaywgd2UgZG9uJ3Qgd2FudCB0byBpZ25vcmUgYSBtb3VzZSBob3ZlciBzb21ldGltZSBpblxuICAgIC8vIHRoZSBkaXN0YW50IGZ1dHVyZSBiZWNhdXNlIGEgdXNlciBwcmV2aW91c2x5IHRvdWNoZWQgdGhlIGVsZW1lbnQuXG4gICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRoYW5kbGVHbG9iYWxQb2ludGVyRXZlbnQoZSkge1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKCk7XG59XG5mdW5jdGlvbiAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0dXBHbG9iYWxUb3VjaEV2ZW50cygpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhhbmRsZUdsb2JhbFBvaW50ZXJFdmVudCk7XG4gICAgZWxzZSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldEdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMpO1xuICAgICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRob3ZlckNvdW50Kys7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRob3ZlckNvdW50LS07XG4gICAgICAgIGlmICgkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudCA+IDApIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhhbmRsZUdsb2JhbFBvaW50ZXJFdmVudCk7XG4gICAgICAgIGVsc2UgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gJDYxNzliOTM2NzA1ZTc2ZDMkZXhwb3J0JGFlNzgwZGFmMjllNmQ0NTYocHJvcHMpIHtcbiAgICBsZXQgeyBvbkhvdmVyU3RhcnQ6IG9uSG92ZXJTdGFydCwgb25Ib3ZlckNoYW5nZTogb25Ib3ZlckNoYW5nZSwgb25Ib3ZlckVuZDogb25Ib3ZlckVuZCwgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCB9ID0gcHJvcHM7XG4gICAgbGV0IFtpc0hvdmVyZWQsIHNldEhvdmVyZWRdID0gKDAsICRieDdTTCR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCBzdGF0ZSA9ICgwLCAkYng3U0wkdXNlUmVmKSh7XG4gICAgICAgIGlzSG92ZXJlZDogZmFsc2UsXG4gICAgICAgIGlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHM6IGZhbHNlLFxuICAgICAgICBwb2ludGVyVHlwZTogXCJcIixcbiAgICAgICAgdGFyZ2V0OiBudWxsXG4gICAgfSkuY3VycmVudDtcbiAgICAoMCwgJGJ4N1NMJHVzZUVmZmVjdCkoJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldHVwR2xvYmFsVG91Y2hFdmVudHMsIFtdKTtcbiAgICBsZXQgeyBob3ZlclByb3BzOiBob3ZlclByb3BzLCB0cmlnZ2VySG92ZXJFbmQ6IHRyaWdnZXJIb3ZlckVuZCB9ID0gKDAsICRieDdTTCR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBsZXQgdHJpZ2dlckhvdmVyU3RhcnQgPSAoZXZlbnQsIHBvaW50ZXJUeXBlKT0+e1xuICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZTtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgc3RhdGUuaXNIb3ZlcmVkIHx8ICFldmVudC5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgIHN0YXRlLmlzSG92ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIHN0YXRlLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmIChvbkhvdmVyU3RhcnQpIG9uSG92ZXJTdGFydCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJob3ZlcnN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvbkhvdmVyQ2hhbmdlKSBvbkhvdmVyQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgc2V0SG92ZXJlZCh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRyaWdnZXJIb3ZlckVuZCA9IChldmVudCwgcG9pbnRlclR5cGUpPT57XG4gICAgICAgICAgICBzdGF0ZS5wb2ludGVyVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgIXN0YXRlLmlzSG92ZXJlZCkgcmV0dXJuO1xuICAgICAgICAgICAgc3RhdGUuaXNIb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGlmIChvbkhvdmVyRW5kKSBvbkhvdmVyRW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImhvdmVyZW5kXCIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvbkhvdmVyQ2hhbmdlKSBvbkhvdmVyQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICAgIHNldEhvdmVyZWQoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgaG92ZXJQcm9wcyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaG92ZXJQcm9wcy5vblBvaW50ZXJFbnRlciA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICgkNjE3OWI5MzY3MDVlNzZkMyR2YXIkZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyAmJiBlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICB0cmlnZ2VySG92ZXJTdGFydChlLCBlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBob3ZlclByb3BzLm9uUG9pbnRlckxlYXZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Rpc2FibGVkICYmIGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHRyaWdnZXJIb3ZlckVuZChlLCBlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob3ZlclByb3BzLm9uVG91Y2hTdGFydCA9ICgpPT57XG4gICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaG92ZXJQcm9wcy5vbk1vdXNlRW50ZXIgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgISQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKSB0cmlnZ2VySG92ZXJTdGFydChlLCBcIm1vdXNlXCIpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBob3ZlclByb3BzLm9uTW91c2VMZWF2ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghaXNEaXNhYmxlZCAmJiBlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSB0cmlnZ2VySG92ZXJFbmQoZSwgXCJtb3VzZVwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhvdmVyUHJvcHM6IGhvdmVyUHJvcHMsXG4gICAgICAgICAgICB0cmlnZ2VySG92ZXJFbmQ6IHRyaWdnZXJIb3ZlckVuZFxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgb25Ib3ZlclN0YXJ0LFxuICAgICAgICBvbkhvdmVyQ2hhbmdlLFxuICAgICAgICBvbkhvdmVyRW5kLFxuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICBzdGF0ZVxuICAgIF0pO1xuICAgICgwLCAkYng3U0wkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICAvLyBDYWxsIHRoZSB0cmlnZ2VySG92ZXJFbmQgYXMgc29vbiBhcyBpc0Rpc2FibGVkIGNoYW5nZXMgdG8gdHJ1ZVxuICAgICAgICAvLyBTYWZlIHRvIGNhbGwgdHJpZ2dlckhvdmVyRW5kLCBpdCB3aWxsIGVhcmx5IHJldHVybiBpZiB3ZSBhcmVuJ3QgY3VycmVudGx5IGhvdmVyaW5nXG4gICAgICAgIGlmIChpc0Rpc2FibGVkKSB0cmlnZ2VySG92ZXJFbmQoe1xuICAgICAgICAgICAgY3VycmVudFRhcmdldDogc3RhdGUudGFyZ2V0XG4gICAgICAgIH0sIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBpc0Rpc2FibGVkXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaG92ZXJQcm9wczogaG92ZXJQcm9wcyxcbiAgICAgICAgaXNIb3ZlcmVkOiBpc0hvdmVyZWRcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSByZWFjdC5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBmb3IgdGhlIGZvbGxvd2luZyBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBOT1RJQ0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9jYzdjMWFlY2U0NmE2YjY5YjQxOTU4ZDczMWUwZmQyN2M5NGJmYzZjL3BhY2thZ2VzL3JlYWN0LWludGVyYWN0aW9uc1xuXG5cbmZ1bmN0aW9uICRlMGI2ZTBiNjhlYzdmNTBmJGV4cG9ydCQ4NzJiNjYwYWM1YTFmZjk4KHByb3BzKSB7XG4gICAgbGV0IHsgcmVmOiByZWYsIG9uSW50ZXJhY3RPdXRzaWRlOiBvbkludGVyYWN0T3V0c2lkZSwgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCwgb25JbnRlcmFjdE91dHNpZGVTdGFydDogb25JbnRlcmFjdE91dHNpZGVTdGFydCB9ID0gcHJvcHM7XG4gICAgbGV0IHN0YXRlUmVmID0gKDAsICRieDdTTCR1c2VSZWYpKHtcbiAgICAgICAgaXNQb2ludGVyRG93bjogZmFsc2UsXG4gICAgICAgIGlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHM6IGZhbHNlXG4gICAgfSk7XG4gICAgbGV0IG9uUG9pbnRlckRvd24gPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgoZSk9PntcbiAgICAgICAgaWYgKG9uSW50ZXJhY3RPdXRzaWRlICYmICRlMGI2ZTBiNjhlYzdmNTBmJHZhciRpc1ZhbGlkRXZlbnQoZSwgcmVmKSkge1xuICAgICAgICAgICAgaWYgKG9uSW50ZXJhY3RPdXRzaWRlU3RhcnQpIG9uSW50ZXJhY3RPdXRzaWRlU3RhcnQoZSk7XG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50LmlzUG9pbnRlckRvd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHRyaWdnZXJJbnRlcmFjdE91dHNpZGUgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgoZSk9PntcbiAgICAgICAgaWYgKG9uSW50ZXJhY3RPdXRzaWRlKSBvbkludGVyYWN0T3V0c2lkZShlKTtcbiAgICB9KTtcbiAgICAoMCwgJGJ4N1NMJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IHN0YXRlID0gc3RhdGVSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBkb2N1bWVudE9iamVjdCA9ICgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkoZWxlbWVudCk7XG4gICAgICAgIC8vIFVzZSBwb2ludGVyIGV2ZW50cyBpZiBhdmFpbGFibGUuIE90aGVyd2lzZSwgZmFsbCBiYWNrIHRvIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuXG4gICAgICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgb25Qb2ludGVyVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNQb2ludGVyRG93biAmJiAkZTBiNmUwYjY4ZWM3ZjUwZiR2YXIkaXNWYWxpZEV2ZW50KGUsIHJlZikpIHRyaWdnZXJJbnRlcmFjdE91dHNpZGUoZSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNoYW5naW5nIHRoZXNlIHRvIGNhcHR1cmUgcGhhc2UgZml4ZWQgY29tYm9ib3hcbiAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgb25Qb2ludGVyVXAsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgb25Qb2ludGVyVXAsIHRydWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBvbk1vdXNlVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cykgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLmlzUG9pbnRlckRvd24gJiYgJGUwYjZlMGI2OGVjN2Y1MGYkdmFyJGlzVmFsaWRFdmVudChlLCByZWYpKSB0cmlnZ2VySW50ZXJhY3RPdXRzaWRlKGUpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Ub3VjaEVuZCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc1BvaW50ZXJEb3duICYmICRlMGI2ZTBiNjhlYzdmNTBmJHZhciRpc1ZhbGlkRXZlbnQoZSwgcmVmKSkgdHJpZ2dlckludGVyYWN0T3V0c2lkZShlKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgdHJ1ZSk7XG4gICAgICAgICAgICBkb2N1bWVudE9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgb25Ub3VjaEVuZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICByZWYsXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIG9uUG9pbnRlckRvd24sXG4gICAgICAgIHRyaWdnZXJJbnRlcmFjdE91dHNpZGVcbiAgICBdKTtcbn1cbmZ1bmN0aW9uICRlMGI2ZTBiNjhlYzdmNTBmJHZhciRpc1ZhbGlkRXZlbnQoZXZlbnQsIHJlZikge1xuICAgIGlmIChldmVudC5idXR0b24gPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV2ZW50LnRhcmdldCkge1xuICAgICAgICAvLyBpZiB0aGUgZXZlbnQgdGFyZ2V0IGlzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQsIGlnbm9yZVxuICAgICAgICBjb25zdCBvd25lckRvY3VtZW50ID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGlmICghb3duZXJEb2N1bWVudCB8fCAhb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIHdpdGhpbiBhIHRvcCBsYXllciBlbGVtZW50IChlLmcuIHRvYXN0cyksIGlnbm9yZS5cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5jbG9zZXN0KFwiW2RhdGEtcmVhY3QtYXJpYS10b3AtbGF5ZXJdXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudCAmJiAhcmVmLmN1cnJlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ5MzkyNTA4M2VjYmIzNThjJGV4cG9ydCQ0OGQxZWE2MzIwODMwMjYwKGhhbmRsZXIpIHtcbiAgICBpZiAoIWhhbmRsZXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgcmV0dXJuIChlKT0+e1xuICAgICAgICBsZXQgZXZlbnQgPSB7XG4gICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQgKCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0RlZmF1bHRQcmV2ZW50ZWQgKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInN0b3BQcm9wYWdhdGlvbiBpcyBub3cgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGV2ZW50cyBpbiBSZWFjdCBTcGVjdHJ1bS4gWW91IGNhbiB1c2UgY29udGludWVQcm9wYWdhdGlvbigpIHRvIHJldmVydCB0aGlzIGJlaGF2aW9yLlwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250aW51ZVByb3BhZ2F0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbn1cblxuXG5mdW5jdGlvbiAkNDZkODE5ZmNiYWYzNTY1NCRleHBvcnQkOGY3MTY1NDgwMWMyZjdjZChwcm9wcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleWJvYXJkUHJvcHM6IHByb3BzLmlzRGlzYWJsZWQgPyB7fSA6IHtcbiAgICAgICAgICAgIG9uS2V5RG93bjogKDAsICQ5MzkyNTA4M2VjYmIzNThjJGV4cG9ydCQ0OGQxZWE2MzIwODMwMjYwKShwcm9wcy5vbktleURvd24pLFxuICAgICAgICAgICAgb25LZXlVcDogKDAsICQ5MzkyNTA4M2VjYmIzNThjJGV4cG9ydCQ0OGQxZWE2MzIwODMwMjYwKShwcm9wcy5vbktleVVwKVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuZnVuY3Rpb24gJGU4YTcwMjJjZjg3Y2JhMmEkZXhwb3J0JDM2ZGE5NjM3OWY3OWYyNDUocHJvcHMpIHtcbiAgICBsZXQgeyBvbk1vdmVTdGFydDogb25Nb3ZlU3RhcnQsIG9uTW92ZTogb25Nb3ZlLCBvbk1vdmVFbmQ6IG9uTW92ZUVuZCB9ID0gcHJvcHM7XG4gICAgbGV0IHN0YXRlID0gKDAsICRieDdTTCR1c2VSZWYpKHtcbiAgICAgICAgZGlkTW92ZTogZmFsc2UsXG4gICAgICAgIGxhc3RQb3NpdGlvbjogbnVsbCxcbiAgICAgICAgaWQ6IG51bGxcbiAgICB9KTtcbiAgICBsZXQgeyBhZGRHbG9iYWxMaXN0ZW5lcjogYWRkR2xvYmFsTGlzdGVuZXIsIHJlbW92ZUdsb2JhbExpc3RlbmVyOiByZW1vdmVHbG9iYWxMaXN0ZW5lciB9ID0gKDAsICRieDdTTCR1c2VHbG9iYWxMaXN0ZW5lcnMpKCk7XG4gICAgbGV0IG1vdmUgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgob3JpZ2luYWxFdmVudCwgcG9pbnRlclR5cGUsIGRlbHRhWCwgZGVsdGFZKT0+e1xuICAgICAgICBpZiAoZGVsdGFYID09PSAwICYmIGRlbHRhWSA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBpZiAoIXN0YXRlLmN1cnJlbnQuZGlkTW92ZSkge1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudC5kaWRNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uTW92ZVN0YXJ0ID09PSBudWxsIHx8IG9uTW92ZVN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk1vdmVTdGFydCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJtb3Zlc3RhcnRcIixcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgc2hpZnRLZXk6IG9yaWdpbmFsRXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICAgICAgbWV0YUtleTogb3JpZ2luYWxFdmVudC5tZXRhS2V5LFxuICAgICAgICAgICAgICAgIGN0cmxLZXk6IG9yaWdpbmFsRXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgICAgICBhbHRLZXk6IG9yaWdpbmFsRXZlbnQuYWx0S2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbk1vdmUgPT09IG51bGwgfHwgb25Nb3ZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk1vdmUoe1xuICAgICAgICAgICAgdHlwZTogXCJtb3ZlXCIsXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWTogZGVsdGFZLFxuICAgICAgICAgICAgc2hpZnRLZXk6IG9yaWdpbmFsRXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICBtZXRhS2V5OiBvcmlnaW5hbEV2ZW50Lm1ldGFLZXksXG4gICAgICAgICAgICBjdHJsS2V5OiBvcmlnaW5hbEV2ZW50LmN0cmxLZXksXG4gICAgICAgICAgICBhbHRLZXk6IG9yaWdpbmFsRXZlbnQuYWx0S2V5XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGxldCBlbmQgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgob3JpZ2luYWxFdmVudCwgcG9pbnRlclR5cGUpPT57XG4gICAgICAgICgwLCAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkYjBkNmZhMWFiMzJlMzI5NSkoKTtcbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnQuZGlkTW92ZSkgb25Nb3ZlRW5kID09PSBudWxsIHx8IG9uTW92ZUVuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Nb3ZlRW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibW92ZWVuZFwiLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IG9yaWdpbmFsRXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICBtZXRhS2V5OiBvcmlnaW5hbEV2ZW50Lm1ldGFLZXksXG4gICAgICAgICAgICBjdHJsS2V5OiBvcmlnaW5hbEV2ZW50LmN0cmxLZXksXG4gICAgICAgICAgICBhbHRLZXk6IG9yaWdpbmFsRXZlbnQuYWx0S2V5XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGxldCBtb3ZlUHJvcHMgPSAoMCwgJGJ4N1NMJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIGxldCBtb3ZlUHJvcHMgPSB7fTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gKCk9PntcbiAgICAgICAgICAgICgwLCAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkMTZhNDY5NzQ2NzE3NTQ4NykoKTtcbiAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQuZGlkTW92ZSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IG9uTW91c2VNb3ZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24sIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVgsIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZShlLCBcIm1vdXNlXCIsIGUucGFnZVggLSAoKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCA9IChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24gPSBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbikgPT09IG51bGwgfHwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24ucGFnZVgpICE9PSBudWxsICYmIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCAhPT0gdm9pZCAwID8gX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYIDogMCksIGUucGFnZVkgLSAoKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSA9IChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xID0gc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24pID09PSBudWxsIHx8IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEucGFnZVkpICE9PSBudWxsICYmIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSAhPT0gdm9pZCAwID8gX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVk6IGUucGFnZVlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uTW91c2VVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlbmQoZSwgXCJtb3VzZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbW92ZVByb3BzLm9uTW91c2VEb3duID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBlLnBhZ2VZXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvblRvdWNoTW92ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGxldCB0b3VjaCA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uZS5jaGFuZ2VkVG91Y2hlc1xuICAgICAgICAgICAgICAgIF0uZmluZEluZGV4KCh7IGlkZW50aWZpZXI6IGlkZW50aWZpZXIgfSk9PmlkZW50aWZpZXIgPT09IHN0YXRlLmN1cnJlbnQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0b3VjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24sIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjE7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHBhZ2VYOiBwYWdlWCwgcGFnZVk6IHBhZ2VZIH0gPSBlLmNoYW5nZWRUb3VjaGVzW3RvdWNoXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlKGUsIFwidG91Y2hcIiwgcGFnZVggLSAoKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCA9IChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24gPSBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbikgPT09IG51bGwgfHwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24ucGFnZVgpICE9PSBudWxsICYmIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCAhPT0gdm9pZCAwID8gX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYIDogMCksIHBhZ2VZIC0gKChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVkgPSAoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMSA9IHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xLnBhZ2VZKSAhPT0gbnVsbCAmJiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVkgIT09IHZvaWQgMCA/IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGFnZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWTogcGFnZVlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uVG91Y2hFbmQgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBsZXQgdG91Y2ggPSBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmUuY2hhbmdlZFRvdWNoZXNcbiAgICAgICAgICAgICAgICBdLmZpbmRJbmRleCgoeyBpZGVudGlmaWVyOiBpZGVudGlmaWVyIH0pPT5pZGVudGlmaWVyID09PSBzdGF0ZS5jdXJyZW50LmlkKTtcbiAgICAgICAgICAgICAgICBpZiAodG91Y2ggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlbmQoZSwgXCJ0b3VjaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5pZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaG1vdmVcIiwgb25Ub3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwidG91Y2hlbmRcIiwgb25Ub3VjaEVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaGNhbmNlbFwiLCBvblRvdWNoRW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbW92ZVByb3BzLm9uVG91Y2hTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5jdXJyZW50LmlkICE9IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgeyBwYWdlWDogcGFnZVgsIHBhZ2VZOiBwYWdlWSwgaWRlbnRpZmllcjogaWRlbnRpZmllciB9ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGFnZVgsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBwYWdlWVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5pZCA9IGlkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInRvdWNobW92ZVwiLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInRvdWNoY2FuY2VsXCIsIG9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgb25Qb2ludGVyTW92ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLnBvaW50ZXJJZCA9PT0gc3RhdGUuY3VycmVudC5pZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uLCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlclR5cGUgPSBlLnBvaW50ZXJUeXBlIHx8IFwibW91c2VcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm9ibGVtcyB3aXRoIFBvaW50ZXJFdmVudCNtb3ZlbWVudFgvbW92ZW1lbnRZOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBpdCBpcyBhbHdheXMgMCBvbiBtYWNPUyBTYWZhcmkuXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIE9uIENocm9tZSBBbmRyb2lkLCBpdCdzIHNjYWxlZCBieSBkZXZpY2VQaXhlbFJhdGlvLCBidXQgbm90IG9uIENocm9tZSBtYWNPU1xuICAgICAgICAgICAgICAgICAgICBtb3ZlKGUsIHBvaW50ZXJUeXBlLCBlLnBhZ2VYIC0gKChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggPSAoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uID0gc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24pID09PSBudWxsIHx8IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uLnBhZ2VYKSAhPT0gbnVsbCAmJiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggIT09IHZvaWQgMCA/IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCA6IDApLCBlLnBhZ2VZIC0gKChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVkgPSAoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMSA9IHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xLnBhZ2VZKSAhPT0gbnVsbCAmJiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVkgIT09IHZvaWQgMCA/IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBlLnBhZ2VZXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvblBvaW50ZXJVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLnBvaW50ZXJJZCA9PT0gc3RhdGUuY3VycmVudC5pZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlclR5cGUgPSBlLnBvaW50ZXJUeXBlIHx8IFwibW91c2VcIjtcbiAgICAgICAgICAgICAgICAgICAgZW5kKGUsIHBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5pZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJwb2ludGVybW92ZVwiLCBvblBvaW50ZXJNb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJwb2ludGVydXBcIiwgb25Qb2ludGVyVXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyVXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbW92ZVByb3BzLm9uUG9pbnRlckRvd24gPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDAgJiYgc3RhdGUuY3VycmVudC5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBlLnBhZ2VZXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQuaWQgPSBlLnBvaW50ZXJJZDtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcmNhbmNlbFwiLCBvblBvaW50ZXJVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyaWdnZXJLZXlib2FyZE1vdmUgPSAoZSwgZGVsdGFYLCBkZWx0YVkpPT57XG4gICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICAgICAgbW92ZShlLCBcImtleWJvYXJkXCIsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgICAgIGVuZChlLCBcImtleWJvYXJkXCIpO1xuICAgICAgICB9O1xuICAgICAgICBtb3ZlUHJvcHMub25LZXlEb3duID0gKGUpPT57XG4gICAgICAgICAgICBzd2l0Y2goZS5rZXkpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJMZWZ0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJLZXlib2FyZE1vdmUoZSwgLTEsIDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiUmlnaHRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJLZXlib2FyZE1vdmUoZSwgMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJVcFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcktleWJvYXJkTW92ZShlLCAwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJEb3duXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJLZXlib2FyZE1vdmUoZSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbW92ZVByb3BzO1xuICAgIH0sIFtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGFkZEdsb2JhbExpc3RlbmVyLFxuICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcixcbiAgICAgICAgbW92ZSxcbiAgICAgICAgZW5kXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbW92ZVByb3BzOiBtb3ZlUHJvcHNcbiAgICB9O1xufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIxIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkN2QwYTYzNmQ3YTRkY2VmZCRleHBvcnQkMjEyM2ZmMmI4N2M4MWNhKHByb3BzLCByZWYpIHtcbiAgICBsZXQgeyBvblNjcm9sbDogb25TY3JvbGwsIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQgfSA9IHByb3BzO1xuICAgIGxldCBvblNjcm9sbEhhbmRsZXIgPSAoMCwgJGJ4N1NMJHVzZUNhbGxiYWNrKSgoZSk9PntcbiAgICAgICAgLy8gSWYgdGhlIGN0cmxLZXkgaXMgcHJlc3NlZCwgdGhpcyBpcyBhIHpvb20gZXZlbnQsIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmIChlLmN0cmxLZXkpIHJldHVybjtcbiAgICAgICAgLy8gc3RvcCBzY3JvbGxpbmcgdGhlIHBhZ2VcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAob25TY3JvbGwpIG9uU2Nyb2xsKHtcbiAgICAgICAgICAgIGRlbHRhWDogZS5kZWx0YVgsXG4gICAgICAgICAgICBkZWx0YVk6IGUuZGVsdGFZXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgb25TY3JvbGxcbiAgICBdKTtcbiAgICAoMCwgJGJ4N1NMJHVzZUV2ZW50KShyZWYsIFwid2hlZWxcIiwgaXNEaXNhYmxlZCA/IHVuZGVmaW5lZCA6IG9uU2Nyb2xsSGFuZGxlcik7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmNvbnN0ICQ4YTI2NTYxZDI4NzcyMzZlJHZhciRERUZBVUxUX1RIUkVTSE9MRCA9IDUwMDtcbmZ1bmN0aW9uICQ4YTI2NTYxZDI4NzcyMzZlJGV4cG9ydCRjMjRlZDAxMDRkMDdlYWI5KHByb3BzKSB7XG4gICAgbGV0IHsgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCwgb25Mb25nUHJlc3NTdGFydDogb25Mb25nUHJlc3NTdGFydCwgb25Mb25nUHJlc3NFbmQ6IG9uTG9uZ1ByZXNzRW5kLCBvbkxvbmdQcmVzczogb25Mb25nUHJlc3MsIHRocmVzaG9sZDogdGhyZXNob2xkID0gJDhhMjY1NjFkMjg3NzIzNmUkdmFyJERFRkFVTFRfVEhSRVNIT0xELCBhY2Nlc3NpYmlsaXR5RGVzY3JpcHRpb246IGFjY2Vzc2liaWxpdHlEZXNjcmlwdGlvbiB9ID0gcHJvcHM7XG4gICAgY29uc3QgdGltZVJlZiA9ICgwLCAkYng3U0wkdXNlUmVmKSgpO1xuICAgIGxldCB7IGFkZEdsb2JhbExpc3RlbmVyOiBhZGRHbG9iYWxMaXN0ZW5lciwgcmVtb3ZlR2xvYmFsTGlzdGVuZXI6IHJlbW92ZUdsb2JhbExpc3RlbmVyIH0gPSAoMCwgJGJ4N1NMJHVzZUdsb2JhbExpc3RlbmVycykoKTtcbiAgICBsZXQgeyBwcmVzc1Byb3BzOiBwcmVzc1Byb3BzIH0gPSAoMCwgJGY2YzMxY2NlMmFkZjY1NGYkZXhwb3J0JDQ1NzEyZWNlZGE2ZmFkMjEpKHtcbiAgICAgICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgICAgb25QcmVzc1N0YXJ0IChlKSB7XG4gICAgICAgICAgICBlLmNvbnRpbnVlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uTG9uZ1ByZXNzU3RhcnQpIG9uTG9uZ1ByZXNzU3RhcnQoe1xuICAgICAgICAgICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImxvbmdwcmVzc3N0YXJ0XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aW1lUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgb3RoZXIgdXNlUHJlc3MgaGFuZGxlcnMgZnJvbSBhbHNvIGhhbmRsaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IFBvaW50ZXJFdmVudChcInBvaW50ZXJjYW5jZWxcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkxvbmdQcmVzcykgb25Mb25nUHJlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibG9uZ3ByZXNzXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9LCB0aHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgY29udGV4dCBtZW51LCB3aGljaCBtYXkgYmUgb3BlbmVkIG9uIGxvbmcgcHJlc3Mgb24gdG91Y2ggZGV2aWNlc1xuICAgICAgICAgICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9uQ29udGV4dE1lbnUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIoZS50YXJnZXQsIFwiY29udGV4dG1lbnVcIiwgb25Db250ZXh0TWVudSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJ1cFwiLCAoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gY29udGV4dG1lbnUgZXZlbnQgaXMgZmlyZWQgcXVpY2tseSBhZnRlciBwb2ludGVydXAsIHJlbW92ZSB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gZnV0dXJlIGNvbnRleHQgbWVudSBldmVudHMgb3V0c2lkZSBhIGxvbmcgcHJlc3MgYXJlIG5vdCBwcmV2ZW50ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIoZS50YXJnZXQsIFwiY29udGV4dG1lbnVcIiwgb25Db250ZXh0TWVudSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblByZXNzRW5kIChlKSB7XG4gICAgICAgICAgICBpZiAodGltZVJlZi5jdXJyZW50KSBjbGVhclRpbWVvdXQodGltZVJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChvbkxvbmdQcmVzc0VuZCAmJiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikpIG9uTG9uZ1ByZXNzRW5kKHtcbiAgICAgICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwibG9uZ3ByZXNzZW5kXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGRlc2NyaXB0aW9uUHJvcHMgPSAoMCwgJGJ4N1NMJHVzZURlc2NyaXB0aW9uKShvbkxvbmdQcmVzcyAmJiAhaXNEaXNhYmxlZCA/IGFjY2Vzc2liaWxpdHlEZXNjcmlwdGlvbiA6IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9uZ1ByZXNzUHJvcHM6ICgwLCAkYng3U0wkbWVyZ2VQcm9wcykocHJlc3NQcm9wcywgZGVzY3JpcHRpb25Qcm9wcylcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgeyQzYjExN2U0M2RjMGNhOTVkJGV4cG9ydCQyN2M3MDFlZDllNDQ5ZTk5IGFzIFByZXNzYWJsZSwgJGYxYWI4Yzc1NDc4YzZmNzMkZXhwb3J0JDMzNTE4NzFlZTRiMjg4YjggYXMgUHJlc3NSZXNwb25kZXIsICRmMWFiOGM3NTQ3OGM2ZjczJGV4cG9ydCRjZjc1NDI4ZTBiOWVkMWVhIGFzIENsZWFyUHJlc3NSZXNwb25kZXIsICRhMWVhNTlkNjgyNzBmMGRkJGV4cG9ydCRmODE2OGQ4ZGQ4ZmQ2NmU2IGFzIHVzZUZvY3VzLCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkYjliM2RmZGRhYjE3ZGIyNyBhcyBpc0ZvY3VzVmlzaWJsZSwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDYzMGZmNjUzYzVhZGE2YTkgYXMgZ2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDgzOTdkZGZjNTA0ZmRiOWEgYXMgc2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDk4ZTIwZWM5MmY2MTRjZmUgYXMgdXNlSW50ZXJhY3Rpb25Nb2RhbGl0eSwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGZmZDllNTAyMWMxZmIyZDYgYXMgdXNlRm9jdXNWaXNpYmxlLCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZWM3MWI0YjgzYWMwOGVjMyBhcyB1c2VGb2N1c1Zpc2libGVMaXN0ZW5lciwgJDlhYjk0MjYyYmQwMDQ3YzckZXhwb3J0JDQyMGU2ODI3MzE2NWY0ZWMgYXMgdXNlRm9jdXNXaXRoaW4sICQ2MTc5YjkzNjcwNWU3NmQzJGV4cG9ydCRhZTc4MGRhZjI5ZTZkNDU2IGFzIHVzZUhvdmVyLCAkZTBiNmUwYjY4ZWM3ZjUwZiRleHBvcnQkODcyYjY2MGFjNWExZmY5OCBhcyB1c2VJbnRlcmFjdE91dHNpZGUsICQ0NmQ4MTlmY2JhZjM1NjU0JGV4cG9ydCQ4ZjcxNjU0ODAxYzJmN2NkIGFzIHVzZUtleWJvYXJkLCAkZThhNzAyMmNmODdjYmEyYSRleHBvcnQkMzZkYTk2Mzc5Zjc5ZjI0NSBhcyB1c2VNb3ZlLCAkZjZjMzFjY2UyYWRmNjU0ZiRleHBvcnQkNDU3MTJlY2VkYTZmYWQyMSBhcyB1c2VQcmVzcywgJDdkMGE2MzZkN2E0ZGNlZmQkZXhwb3J0JDIxMjNmZjJiODdjODFjYSBhcyB1c2VTY3JvbGxXaGVlbCwgJDhhMjY1NjFkMjg3NzIzNmUkZXhwb3J0JGMyNGVkMDEwNGQwN2VhYjkgYXMgdXNlTG9uZ1ByZXNzfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VPYmplY3RSZWYiLCIkYng3U0wkdXNlT2JqZWN0UmVmIiwibWVyZ2VQcm9wcyIsIiRieDdTTCRtZXJnZVByb3BzIiwidXNlU3luY1JlZiIsIiRieDdTTCR1c2VTeW5jUmVmIiwidXNlR2xvYmFsTGlzdGVuZXJzIiwiJGJ4N1NMJHVzZUdsb2JhbExpc3RlbmVycyIsInVzZUVmZmVjdEV2ZW50IiwiJGJ4N1NMJHVzZUVmZmVjdEV2ZW50IiwiZ2V0T3duZXJEb2N1bWVudCIsIiRieDdTTCRnZXRPd25lckRvY3VtZW50IiwiaXNNYWMiLCIkYng3U0wkaXNNYWMiLCJvcGVuTGluayIsIiRieDdTTCRvcGVuTGluayIsImlzVmlydHVhbENsaWNrIiwiJGJ4N1NMJGlzVmlydHVhbENsaWNrIiwiZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwiJGJ4N1NMJGZvY3VzV2l0aG91dFNjcm9sbGluZyIsImlzVmlydHVhbFBvaW50ZXJFdmVudCIsIiRieDdTTCRpc1ZpcnR1YWxQb2ludGVyRXZlbnQiLCJnZXRPd25lcldpbmRvdyIsIiRieDdTTCRnZXRPd25lcldpbmRvdyIsImlzSU9TIiwiJGJ4N1NMJGlzSU9TIiwicnVuQWZ0ZXJUcmFuc2l0aW9uIiwiJGJ4N1NMJHJ1bkFmdGVyVHJhbnNpdGlvbiIsInVzZUxheW91dEVmZmVjdCIsIiRieDdTTCR1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFdmVudCIsIiRieDdTTCR1c2VFdmVudCIsInVzZURlc2NyaXB0aW9uIiwiJGJ4N1NMJHVzZURlc2NyaXB0aW9uIiwiJGJ4N1NMJHJlYWN0IiwidXNlQ29udGV4dCIsIiRieDdTTCR1c2VDb250ZXh0IiwidXNlU3RhdGUiLCIkYng3U0wkdXNlU3RhdGUiLCJ1c2VSZWYiLCIkYng3U0wkdXNlUmVmIiwidXNlTWVtbyIsIiRieDdTTCR1c2VNZW1vIiwidXNlRWZmZWN0IiwiJGJ4N1NMJHVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiJGJ4N1NMJHVzZUNhbGxiYWNrIiwiXyIsIiRieDdTTCRfIiwiJGJ4N1NMJF8xIiwiJGJ4N1NMJF8yIiwidXNlSXNTU1IiLCIkYng3U0wkdXNlSXNTU1IiLCIkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUiLCIkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc2F2ZWRVc2VyU2VsZWN0IiwiJDE0YzBiNzI1MDlkNzAyMjUkdmFyJG1vZGlmaWVkRWxlbWVudE1hcCIsIldlYWtNYXAiLCIkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkMTZhNDY5NzQ2NzE3NTQ4NyIsInRhcmdldCIsImRvY3VtZW50T2JqZWN0IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJ3ZWJraXRVc2VyU2VsZWN0IiwiSFRNTEVsZW1lbnQiLCJTVkdFbGVtZW50Iiwic2V0IiwidXNlclNlbGVjdCIsIiQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1Iiwic2V0VGltZW91dCIsImhhcyIsInRhcmdldE9sZFVzZXJTZWxlY3QiLCJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJkZWxldGUiLCIkYWUxZWViYThiOWVhZmQwOCRleHBvcnQkNTE2NWVjY2IzNWFhYWRiNSIsImNyZWF0ZUNvbnRleHQiLCJyZWdpc3RlciIsImRpc3BsYXlOYW1lIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHVzZVByZXNzUmVzcG9uZGVyQ29udGV4dCIsInByb3BzIiwiY29udGV4dCIsImNvbnRleHRQcm9wcyIsInJlZiIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRfc2hvdWxkU3RvcFByb3BhZ2F0aW9uIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJFByZXNzRXZlbnQiLCJjb250aW51ZVByb3BhZ2F0aW9uIiwic2hvdWxkU3RvcFByb3BhZ2F0aW9uIiwiY29uc3RydWN0b3IiLCJ0eXBlIiwicG9pbnRlclR5cGUiLCJvcmlnaW5hbEV2ZW50Iiwid3JpdGFibGUiLCJ2YWx1ZSIsImN1cnJlbnRUYXJnZXQiLCJzaGlmdEtleSIsIm1ldGFLZXkiLCJjdHJsS2V5IiwiYWx0S2V5IiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJExJTktfQ0xJQ0tFRCIsIlN5bWJvbCIsIiRmNmMzMWNjZTJhZGY2NTRmJGV4cG9ydCQ0NTcxMmVjZWRhNmZhZDIxIiwib25QcmVzcyIsIm9uUHJlc3NDaGFuZ2UiLCJvblByZXNzU3RhcnQiLCJvblByZXNzRW5kIiwib25QcmVzc1VwIiwiaXNEaXNhYmxlZCIsImlzUHJlc3NlZCIsImlzUHJlc3NlZFByb3AiLCJwcmV2ZW50Rm9jdXNPblByZXNzIiwic2hvdWxkQ2FuY2VsT25Qb2ludGVyRXhpdCIsImFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3MiLCJkb21Qcm9wcyIsInNldFByZXNzZWQiLCJpZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzIiwiaWdub3JlQ2xpY2tBZnRlclByZXNzIiwiZGlkRmlyZVByZXNzU3RhcnQiLCJpc1RyaWdnZXJpbmdFdmVudCIsImFjdGl2ZVBvaW50ZXJJZCIsImlzT3ZlclRhcmdldCIsImFkZEdsb2JhbExpc3RlbmVyIiwicmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzIiwidHJpZ2dlclByZXNzU3RhcnQiLCJzdGF0ZSIsImN1cnJlbnQiLCJldmVudCIsInRyaWdnZXJQcmVzc0VuZCIsIndhc1ByZXNzZWQiLCJ0cmlnZ2VyUHJlc3NVcCIsImNhbmNlbCIsImUiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQiLCJjYW5jZWxPblBvaW50ZXJFeGl0IiwicHJlc3NQcm9wcyIsIm9uS2V5RG93biIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkS2V5Ym9hcmRFdmVudCIsIm5hdGl2ZUV2ZW50IiwiY29udGFpbnMiLCJfc3RhdGVfbWV0YUtleUV2ZW50cyIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRzaG91bGRQcmV2ZW50RGVmYXVsdEtleWJvYXJkIiwia2V5IiwicHJldmVudERlZmF1bHQiLCJyZXBlYXQiLCJvbktleVVwIiwic3RvcFByb3BhZ2F0aW9uIiwibWV0YUtleUV2ZW50cyIsIk1hcCIsIm9uQ2xpY2siLCJidXR0b24iLCJpc09wZW5pbmciLCJzdG9wUHJlc3NTdGFydCIsInN0b3BQcmVzc1VwIiwic3RvcFByZXNzRW5kIiwiX3N0YXRlX21ldGFLZXlFdmVudHMxIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzSFRNTEFuY2hvckxpbmsiLCJzaXplIiwiX3N0YXRlX3RhcmdldCIsImV2ZW50cyIsInVuZGVmaW5lZCIsInZhbHVlcyIsImRpc3BhdGNoRXZlbnQiLCJLZXlib2FyZEV2ZW50IiwiUG9pbnRlckV2ZW50Iiwib25Qb2ludGVyRG93biIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRzaG91bGRQcmV2ZW50RGVmYXVsdCIsInBvaW50ZXJJZCIsIm9uUG9pbnRlck1vdmUiLCJvblBvaW50ZXJVcCIsIm9uUG9pbnRlckNhbmNlbCIsIm9uTW91c2VEb3duIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldCIsIm9uRHJhZ1N0YXJ0Iiwib25Nb3VzZVVwIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwib25Ub3VjaFN0YXJ0IiwidG91Y2giLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0VG91Y2hGcm9tRXZlbnQiLCJpZGVudGlmaWVyIiwib25TY3JvbGwiLCJvblRvdWNoTW92ZSIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRUb3VjaEJ5SWQiLCJvblRvdWNoRW5kIiwib25Ub3VjaENhbmNlbCIsIl9yZWZfY3VycmVudF90YXJnZXQiLCJ0YWdOYW1lIiwiaGFzQXR0cmlidXRlIiwiY29kZSIsImVsZW1lbnQiLCJyb2xlIiwiSFRNTElucHV0RWxlbWVudCIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkSW5wdXRLZXkiLCJIVE1MVGV4dEFyZWFFbGVtZW50IiwiaXNDb250ZW50RWRpdGFibGUiLCJ0YXJnZXRUb3VjaGVzIiwibGVuZ3RoIiwiY2hhbmdlZFRvdWNoZXMiLCJpIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFBvaW50Q2xpZW50UmVjdCIsInBvaW50Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJ3aWR0aCIsInJhZGl1c1giLCJoZWlnaHQiLCJyYWRpdXNZIiwidG9wIiwiY2xpZW50WSIsInJpZ2h0IiwiY2xpZW50WCIsImJvdHRvbSIsImxlZnQiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkYXJlUmVjdGFuZ2xlc092ZXJsYXBwaW5nIiwiYSIsImIiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicG9pbnRSZWN0IiwiSFRNTEJ1dHRvbkVsZW1lbnQiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkbm9uVGV4dElucHV0VHlwZXMiLCJTZXQiLCIkM2IxMTdlNDNkYzBjYTk1ZCRleHBvcnQkMjdjNzAxZWQ5ZTQ0OWU5OSIsImZvcndhcmRSZWYiLCJjaGlsZHJlbiIsImNoaWxkIiwiQ2hpbGRyZW4iLCJvbmx5IiwiY2xvbmVFbGVtZW50IiwiJGYxYWI4Yzc1NDc4YzZmNzMkZXhwb3J0JDMzNTE4NzFlZTRiMjg4YjgiLCJpc1JlZ2lzdGVyZWQiLCJwcmV2Q29udGV4dCIsImNvbnNvbGUiLCJ3YXJuIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwiJGYxYWI4Yzc1NDc4YzZmNzMkZXhwb3J0JGNmNzU0MjhlMGI5ZWQxZWEiLCIkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkOTA1ZTdmYzU0NGE3MWYzNiIsImlzRGVmYXVsdFByZXZlbnRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsInBlcnNpc3QiLCJyZWxhdGVkVGFyZ2V0IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJldmVudFBoYXNlIiwiaXNUcnVzdGVkIiwidGltZVN0YW1wIiwiJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDcxNWM2ODJkMDlkNjM5Y2MiLCJvbkJsdXIiLCJzdGF0ZVJlZiIsImlzRm9jdXNlZCIsIm9ic2VydmVyIiwiZGlzY29ubmVjdCIsImRpc3BhdGNoQmx1ciIsIkhUTUxTZWxlY3RFbGVtZW50Iiwib25CbHVySGFuZGxlciIsImRpc2FibGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJNdXRhdGlvbk9ic2VydmVyIiwiX3N0YXRlUmVmX2N1cnJlbnRfb2JzZXJ2ZXIiLCJyZWxhdGVkVGFyZ2V0RWwiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJGb2N1c0V2ZW50Iiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVGaWx0ZXIiLCIkYTFlYTU5ZDY4MjcwZjBkZCRleHBvcnQkZjgxNjhkOGRkOGZkNjZlNiIsIm9uRm9jdXMiLCJvbkZvY3VzUHJvcCIsIm9uQmx1clByb3AiLCJvbkZvY3VzQ2hhbmdlIiwib25TeW50aGV0aWNGb2N1cyIsImZvY3VzUHJvcHMiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc1NldHVwR2xvYmFsTGlzdGVuZXJzIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzQmx1cnJlZFdpbmRvd1JlY2VudGx5IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJEZPQ1VTX1ZJU0lCTEVfSU5QVVRfS0VZUyIsIlRhYiIsIkVzY2FwZSIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMiLCJtb2RhbGl0eSIsImhhbmRsZXIiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNWYWxpZEtleSIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVLZXlib2FyZEV2ZW50IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVDbGlja0V2ZW50IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUZvY3VzRXZlbnQiLCJ3aW5kb3ciLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlV2luZG93Qmx1ciIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzIiwiZm9jdXMiLCJwcm90b3R5cGUiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlYWR5U3RhdGUiLCIkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkYjliM2RmZGRhYjE3ZGIyNyIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ2MzBmZjY1M2M1YWRhNmE5IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDgzOTdkZGZjNTA0ZmRiOWEiLCIkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkOThlMjBlYzkyZjYxNGNmZSIsInNldE1vZGFsaXR5IiwiYWRkIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJG5vblRleHRJbnB1dFR5cGVzIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGlzS2V5Ym9hcmRGb2N1c0V2ZW50IiwiaXNUZXh0SW5wdXQiLCJfZV90YXJnZXQiLCIkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZmZkOWU1MDIxYzFmYjJkNiIsImF1dG9Gb2N1cyIsImlzRm9jdXNWaXNpYmxlU3RhdGUiLCJzZXRGb2N1c1Zpc2libGUiLCIkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZWM3MWI0YjgzYWMwOGVjMyIsImlzRm9jdXNWaXNpYmxlIiwiZm4iLCJkZXBzIiwib3B0cyIsIiQ5YWI5NDI2MmJkMDA0N2M3JGV4cG9ydCQ0MjBlNjgyNzMxNjVmNGVjIiwib25CbHVyV2l0aGluIiwib25Gb2N1c1dpdGhpbiIsIm9uRm9jdXNXaXRoaW5DaGFuZ2UiLCJpc0ZvY3VzV2l0aGluIiwiZm9jdXNXaXRoaW5Qcm9wcyIsIiQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzIiwiJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhvdmVyQ291bnQiLCIkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0R2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyIsIiQ2MTc5YjkzNjcwNWU3NmQzJHZhciRoYW5kbGVHbG9iYWxQb2ludGVyRXZlbnQiLCIkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0dXBHbG9iYWxUb3VjaEV2ZW50cyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCIkNjE3OWI5MzY3MDVlNzZkMyRleHBvcnQkYWU3ODBkYWYyOWU2ZDQ1NiIsIm9uSG92ZXJTdGFydCIsIm9uSG92ZXJDaGFuZ2UiLCJvbkhvdmVyRW5kIiwiaXNIb3ZlcmVkIiwic2V0SG92ZXJlZCIsImhvdmVyUHJvcHMiLCJ0cmlnZ2VySG92ZXJFbmQiLCJ0cmlnZ2VySG92ZXJTdGFydCIsIm9uUG9pbnRlckVudGVyIiwib25Qb2ludGVyTGVhdmUiLCIkZTBiNmUwYjY4ZWM3ZjUwZiRleHBvcnQkODcyYjY2MGFjNWExZmY5OCIsIm9uSW50ZXJhY3RPdXRzaWRlIiwib25JbnRlcmFjdE91dHNpZGVTdGFydCIsImlzUG9pbnRlckRvd24iLCIkZTBiNmUwYjY4ZWM3ZjUwZiR2YXIkaXNWYWxpZEV2ZW50IiwidHJpZ2dlckludGVyYWN0T3V0c2lkZSIsIm93bmVyRG9jdW1lbnQiLCJjbG9zZXN0IiwiJDkzOTI1MDgzZWNiYjM1OGMkZXhwb3J0JDQ4ZDFlYTYzMjA4MzAyNjAiLCJlcnJvciIsIiQ0NmQ4MTlmY2JhZjM1NjU0JGV4cG9ydCQ4ZjcxNjU0ODAxYzJmN2NkIiwia2V5Ym9hcmRQcm9wcyIsIiRlOGE3MDIyY2Y4N2NiYTJhJGV4cG9ydCQzNmRhOTYzNzlmNzlmMjQ1Iiwib25Nb3ZlU3RhcnQiLCJvbk1vdmUiLCJvbk1vdmVFbmQiLCJkaWRNb3ZlIiwibGFzdFBvc2l0aW9uIiwiaWQiLCJyZW1vdmVHbG9iYWxMaXN0ZW5lciIsIm1vdmUiLCJkZWx0YVgiLCJkZWx0YVkiLCJlbmQiLCJtb3ZlUHJvcHMiLCJzdGFydCIsIm9uTW91c2VNb3ZlIiwiX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uIiwiX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMSIsIl9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCIsIl9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSIsInBhZ2VYIiwicGFnZVkiLCJmaW5kSW5kZXgiLCJ0cmlnZ2VyS2V5Ym9hcmRNb3ZlIiwiJDdkMGE2MzZkN2E0ZGNlZmQkZXhwb3J0JDIxMjNmZjJiODdjODFjYSIsIm9uU2Nyb2xsSGFuZGxlciIsIiQ4YTI2NTYxZDI4NzcyMzZlJHZhciRERUZBVUxUX1RIUkVTSE9MRCIsIiQ4YTI2NTYxZDI4NzcyMzZlJGV4cG9ydCRjMjRlZDAxMDRkMDdlYWI5Iiwib25Mb25nUHJlc3NTdGFydCIsIm9uTG9uZ1ByZXNzRW5kIiwib25Mb25nUHJlc3MiLCJ0aHJlc2hvbGQiLCJhY2Nlc3NpYmlsaXR5RGVzY3JpcHRpb24iLCJ0aW1lUmVmIiwib25Db250ZXh0TWVudSIsImNsZWFyVGltZW91dCIsImRlc2NyaXB0aW9uUHJvcHMiLCJsb25nUHJlc3NQcm9wcyIsIlByZXNzYWJsZSIsIlByZXNzUmVzcG9uZGVyIiwiQ2xlYXJQcmVzc1Jlc3BvbmRlciIsInVzZUZvY3VzIiwiZ2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSIsInNldEludGVyYWN0aW9uTW9kYWxpdHkiLCJ1c2VJbnRlcmFjdGlvbk1vZGFsaXR5IiwidXNlRm9jdXNWaXNpYmxlIiwidXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIiLCJ1c2VGb2N1c1dpdGhpbiIsInVzZUhvdmVyIiwidXNlSW50ZXJhY3RPdXRzaWRlIiwidXNlS2V5Ym9hcmQiLCJ1c2VNb3ZlIiwidXNlUHJlc3MiLCJ1c2VTY3JvbGxXaGVlbCIsInVzZUxvbmdQcmVzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/focus/node_modules/@react-aria/ssr/dist/import.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@react-aria/focus/node_modules/@react-aria/ssr/dist/import.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SSRProvider: () => (/* binding */ $b5e257d569688ac6$export$9f8ac96af4b1b2ae),\n/* harmony export */   useIsSSR: () => (/* binding */ $b5e257d569688ac6$export$535bd6ca7f90a273),\n/* harmony export */   useSSRSafeId: () => (/* binding */ $b5e257d569688ac6$export$619500959fc48b26)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is\n// guarded by a check that it only runs on the client side.\n// eslint-disable-next-line rulesdir/useLayoutEffectRule\n// Default context value to use in case there is no SSRProvider. This is fine for\n// client-only apps. In order to support multiple copies of React Aria potentially\n// being on the page at once, the prefix is set to a random number. SSRProvider\n// will reset this to zero for consistency between server and client, so in the\n// SSR case multiple copies of React Aria is not supported.\nconst $b5e257d569688ac6$var$defaultContext = {\n    prefix: String(Math.round(Math.random() * 10000000000)),\n    current: 0\n};\nconst $b5e257d569688ac6$var$SSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext($b5e257d569688ac6$var$defaultContext);\nconst $b5e257d569688ac6$var$IsSSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(false);\n// This is only used in React < 18.\nfunction $b5e257d569688ac6$var$LegacySSRProvider(props) {\n    let cur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let counter = $b5e257d569688ac6$var$useCounter(cur === $b5e257d569688ac6$var$defaultContext);\n    let [isSSR, setIsSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            // If this is the first SSRProvider, start with an empty string prefix, otherwise\n            // append and increment the counter.\n            prefix: cur === $b5e257d569688ac6$var$defaultContext ? \"\" : `${cur.prefix}-${counter}`,\n            current: 0\n        }), [\n        cur,\n        counter\n    ]);\n    // If on the client, and the component was initially server rendered,\n    // then schedule a layout effect to update the component after hydration.\n    if (typeof document !== \"undefined\") // because the condition never changes after mounting.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        setIsSSR(false);\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$SSRContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$IsSSRContext.Provider, {\n        value: isSSR\n    }, props.children));\n}\nlet $b5e257d569688ac6$var$warnedAboutSSRProvider = false;\nfunction $b5e257d569688ac6$export$9f8ac96af4b1b2ae(props) {\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\") {\n        if ( true && !$b5e257d569688ac6$var$warnedAboutSSRProvider) {\n            console.warn(\"In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.\");\n            $b5e257d569688ac6$var$warnedAboutSSRProvider = true;\n        }\n        return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, react__WEBPACK_IMPORTED_MODULE_0__).Fragment, null, props.children);\n    }\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$LegacySSRProvider, props);\n}\nlet $b5e257d569688ac6$var$canUseDOM = Boolean( false && 0);\nlet $b5e257d569688ac6$var$componentIds = new WeakMap();\nfunction $b5e257d569688ac6$var$useCounter(isDisabled = false) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // eslint-disable-next-line rulesdir/pure-render\n    if (ref.current === null && !isDisabled) {\n        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.\n        // This means our id counter will be incremented twice instead of once. This is a problem because on the\n        // server, components are only rendered once and so ids generated on the server won't match the client.\n        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this\n        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.\n        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.\n        // To ensure that we only increment the global counter once, we store the starting id for this component in\n        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.\n        // Since React runs the second render immediately after the first, this is safe.\n        // @ts-ignore\n        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, react__WEBPACK_IMPORTED_MODULE_0__).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;\n        if (currentOwner) {\n            let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);\n            if (prevComponentValue == null) $b5e257d569688ac6$var$componentIds.set(currentOwner, {\n                id: ctx.current,\n                state: currentOwner.memoizedState\n            });\n            else if (currentOwner.memoizedState !== prevComponentValue.state) {\n                // On the second render, the memoizedState gets reset by React.\n                // Reset the counter, and remove from the weak map so we don't\n                // do this for subsequent useId calls.\n                ctx.current = prevComponentValue.id;\n                $b5e257d569688ac6$var$componentIds.delete(currentOwner);\n            }\n        }\n        // eslint-disable-next-line rulesdir/pure-render\n        ref.current = ++ctx.current;\n    }\n    // eslint-disable-next-line rulesdir/pure-render\n    return ref.current;\n}\nfunction $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    // If we are rendering in a non-DOM environment, and there's no SSRProvider,\n    // provide a warning to hint to the developer to add one.\n    if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM) console.warn(\"When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.\");\n    let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);\n    let prefix = ctx === $b5e257d569688ac6$var$defaultContext && \"development\" === \"test\" ? 0 : `react-aria${ctx.prefix}`;\n    return defaultId || `${prefix}-${counter}`;\n}\nfunction $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {\n    // @ts-ignore\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__).useId();\n    let [didSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());\n    let prefix = didSSR || \"development\" === \"test\" ? \"react-aria\" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;\n    return defaultId || `${prefix}-${id}`;\n}\nconst $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;\nfunction $b5e257d569688ac6$var$getSnapshot() {\n    return false;\n}\nfunction $b5e257d569688ac6$var$getServerSnapshot() {\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction $b5e257d569688ac6$var$subscribe(onStoreChange) {\n    // noop\n    return ()=>{};\n}\nfunction $b5e257d569688ac6$export$535bd6ca7f90a273() {\n    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"] === \"function\") return (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$IsSSRContext);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvZm9jdXMvbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3Nzci9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnTTtBQUVoTTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHLDBGQUEwRjtBQUM5RiwyREFBMkQ7QUFDM0Qsd0RBQXdEO0FBRXhELGlGQUFpRjtBQUNqRixrRkFBa0Y7QUFDbEYsK0VBQStFO0FBQy9FLCtFQUErRTtBQUMvRSwyREFBMkQ7QUFDM0QsTUFBTVcsdUNBQXVDO0lBQ3pDQyxRQUFRQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSztJQUMxQ0MsU0FBUztBQUNiO0FBQ0EsTUFBTUMsbUNBQWlELFdBQUgsR0FBSSxJQUFHbEIsa0NBQVcsRUFBR21CLGFBQWEsQ0FBQ1I7QUFDdkYsTUFBTVMscUNBQW1ELFdBQUgsR0FBSSxJQUFHcEIsa0NBQVcsRUFBR21CLGFBQWEsQ0FBQztBQUN6RixtQ0FBbUM7QUFDbkMsU0FBU0Usd0NBQXdDQyxLQUFLO0lBQ2xELElBQUlDLE1BQU0sQ0FBQyxHQUFHckIsNkNBQWdCLEVBQUdnQjtJQUNqQyxJQUFJTSxVQUFVQyxpQ0FBaUNGLFFBQVFaO0lBQ3ZELElBQUksQ0FBQ2UsT0FBT0MsU0FBUyxHQUFHLENBQUMsR0FBR3ZCLDJDQUFjLEVBQUc7SUFDN0MsSUFBSXdCLFFBQVEsQ0FBQyxHQUFHdEIsMENBQWEsRUFBRyxJQUFLO1lBQzdCLGlGQUFpRjtZQUNqRixvQ0FBb0M7WUFDcENNLFFBQVFXLFFBQVFaLHVDQUF1QyxLQUFLLENBQUMsRUFBRVksSUFBSVgsTUFBTSxDQUFDLENBQUMsRUFBRVksUUFBUSxDQUFDO1lBQ3RGUCxTQUFTO1FBQ2IsSUFBSTtRQUNKTTtRQUNBQztLQUNIO0lBQ0QscUVBQXFFO0lBQ3JFLHlFQUF5RTtJQUN6RSxJQUFJLE9BQU9LLGFBQWEsYUFHeEIsc0RBRnNEO0lB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ZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS9mb2N1cy9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvc3NyL2Rpc3QvaW1wb3J0Lm1qcz9jZTIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkNzNTSngkcmVhY3QsIHt1c2VDb250ZXh0IGFzICQ3M1NKeCR1c2VDb250ZXh0LCB1c2VTdGF0ZSBhcyAkNzNTSngkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDczU0p4JHVzZU1lbW8sIHVzZUxheW91dEVmZmVjdCBhcyAkNzNTSngkdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgYXMgJDczU0p4JHVzZVJlZn0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gV2UgbXVzdCBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCBAcmVhY3QtYXJpYS91dGlscywgYW5kIHRoaXMgdXNlTGF5b3V0RWZmZWN0IGlzXG4vLyBndWFyZGVkIGJ5IGEgY2hlY2sgdGhhdCBpdCBvbmx5IHJ1bnMgb24gdGhlIGNsaWVudCBzaWRlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3VzZUxheW91dEVmZmVjdFJ1bGVcblxuLy8gRGVmYXVsdCBjb250ZXh0IHZhbHVlIHRvIHVzZSBpbiBjYXNlIHRoZXJlIGlzIG5vIFNTUlByb3ZpZGVyLiBUaGlzIGlzIGZpbmUgZm9yXG4vLyBjbGllbnQtb25seSBhcHBzLiBJbiBvcmRlciB0byBzdXBwb3J0IG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBBcmlhIHBvdGVudGlhbGx5XG4vLyBiZWluZyBvbiB0aGUgcGFnZSBhdCBvbmNlLCB0aGUgcHJlZml4IGlzIHNldCB0byBhIHJhbmRvbSBudW1iZXIuIFNTUlByb3ZpZGVyXG4vLyB3aWxsIHJlc2V0IHRoaXMgdG8gemVybyBmb3IgY29uc2lzdGVuY3kgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCwgc28gaW4gdGhlXG4vLyBTU1IgY2FzZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgQXJpYSBpcyBub3Qgc3VwcG9ydGVkLlxuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0ID0ge1xuICAgIHByZWZpeDogU3RyaW5nKE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKSksXG4gICAgY3VycmVudDogMFxufTtcbmNvbnN0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRTU1JDb250ZXh0ID0gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVDb250ZXh0KCRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCk7XG5jb25zdCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0ID0gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8vIFRoaXMgaXMgb25seSB1c2VkIGluIFJlYWN0IDwgMTguXG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkTGVnYWN5U1NSUHJvdmlkZXIocHJvcHMpIHtcbiAgICBsZXQgY3VyID0gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCk7XG4gICAgbGV0IGNvdW50ZXIgPSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlcihjdXIgPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCk7XG4gICAgbGV0IFtpc1NTUiwgc2V0SXNTU1JdID0gKDAsICQ3M1NKeCR1c2VTdGF0ZSkodHJ1ZSk7XG4gICAgbGV0IHZhbHVlID0gKDAsICQ3M1NKeCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IFNTUlByb3ZpZGVyLCBzdGFydCB3aXRoIGFuIGVtcHR5IHN0cmluZyBwcmVmaXgsIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gYXBwZW5kIGFuZCBpbmNyZW1lbnQgdGhlIGNvdW50ZXIuXG4gICAgICAgICAgICBwcmVmaXg6IGN1ciA9PT0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0ID8gXCJcIiA6IGAke2N1ci5wcmVmaXh9LSR7Y291bnRlcn1gLFxuICAgICAgICAgICAgY3VycmVudDogMFxuICAgICAgICB9KSwgW1xuICAgICAgICBjdXIsXG4gICAgICAgIGNvdW50ZXJcbiAgICBdKTtcbiAgICAvLyBJZiBvbiB0aGUgY2xpZW50LCBhbmQgdGhlIGNvbXBvbmVudCB3YXMgaW5pdGlhbGx5IHNlcnZlciByZW5kZXJlZCxcbiAgICAvLyB0aGVuIHNjaGVkdWxlIGEgbGF5b3V0IGVmZmVjdCB0byB1cGRhdGUgdGhlIGNvbXBvbmVudCBhZnRlciBoeWRyYXRpb24uXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikgLy8gVGhpcyBpZiBzdGF0ZW1lbnQgdGVjaG5pY2FsbHkgYnJlYWtzIHRoZSBydWxlcyBvZiBob29rcywgYnV0IGlzIHNhZmVcbiAgICAvLyBiZWNhdXNlIHRoZSBjb25kaXRpb24gbmV2ZXIgY2hhbmdlcyBhZnRlciBtb3VudGluZy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAoMCwgJDczU0p4JHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgc2V0SXNTU1IoZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVFbGVtZW50KCRiNWUyNTdkNTY5Njg4YWM2JHZhciRTU1JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBpc1NTUlxuICAgIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5sZXQgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIgPSBmYWxzZTtcbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ5ZjhhYzk2YWY0YjFiMmFlKHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZUlkXCJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJiAhJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkluIFJlYWN0IDE4LCBTU1JQcm92aWRlciBpcyBub3QgbmVjZXNzYXJ5IGFuZCBpcyBhIG5vb3AuIFlvdSBjYW4gcmVtb3ZlIGl0IGZyb20geW91ciBhcHAuXCIpO1xuICAgICAgICAgICAgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkNzNTSngkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoKDAsICQ3M1NKeCRyZWFjdCkuRnJhZ21lbnQsIG51bGwsIHByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkTGVnYWN5U1NSUHJvdmlkZXIsIHByb3BzKTtcbn1cbmxldCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY2FuVXNlRE9NID0gQm9vbGVhbih0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5sZXQgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNvbXBvbmVudElkcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlcihpc0Rpc2FibGVkID0gZmFsc2UpIHtcbiAgICBsZXQgY3R4ID0gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCk7XG4gICAgbGV0IHJlZiA9ICgwLCAkNzNTSngkdXNlUmVmKShudWxsKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcnVsZXNkaXIvcHVyZS1yZW5kZXJcbiAgICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgdmFyIF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lciwgX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgICAgICAvLyBJbiBzdHJpY3QgbW9kZSwgUmVhY3QgcmVuZGVycyBjb21wb25lbnRzIHR3aWNlLCBhbmQgdGhlIHJlZiB3aWxsIGJlIHJlc2V0IHRvIG51bGwgb24gdGhlIHNlY29uZCByZW5kZXIuXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgb3VyIGlkIGNvdW50ZXIgd2lsbCBiZSBpbmNyZW1lbnRlZCB0d2ljZSBpbnN0ZWFkIG9mIG9uY2UuIFRoaXMgaXMgYSBwcm9ibGVtIGJlY2F1c2Ugb24gdGhlXG4gICAgICAgIC8vIHNlcnZlciwgY29tcG9uZW50cyBhcmUgb25seSByZW5kZXJlZCBvbmNlIGFuZCBzbyBpZHMgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgd29uJ3QgbWF0Y2ggdGhlIGNsaWVudC5cbiAgICAgICAgLy8gSW4gUmVhY3QgMTgsIHVzZUlkIHdhcyBpbnRyb2R1Y2VkIHRvIHNvbHZlIHRoaXMsIGJ1dCBpdCBpcyBub3QgYXZhaWxhYmxlIGluIG9sZGVyIHZlcnNpb25zLiBTbyB0byBzb2x2ZSB0aGlzXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gdXNlIHNvbWUgUmVhY3QgaW50ZXJuYWxzIHRvIGFjY2VzcyB0aGUgdW5kZXJseWluZyBGaWJlciBpbnN0YW5jZSwgd2hpY2ggaXMgc3RhYmxlIGJldHdlZW4gcmVuZGVycy5cbiAgICAgICAgLy8gVGhpcyBpcyBleHBvc2VkIGFzIFJlYWN0Q3VycmVudE93bmVyIGluIGRldmVsb3BtZW50LCB3aGljaCBpcyBhbGwgd2UgbmVlZCBzaW5jZSBTdHJpY3RNb2RlIG9ubHkgcnVucyBpbiBkZXZlbG9wbWVudC5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHRoYXQgd2Ugb25seSBpbmNyZW1lbnQgdGhlIGdsb2JhbCBjb3VudGVyIG9uY2UsIHdlIHN0b3JlIHRoZSBzdGFydGluZyBpZCBmb3IgdGhpcyBjb21wb25lbnQgaW5cbiAgICAgICAgLy8gYSB3ZWFrIG1hcCBhc3NvY2lhdGVkIHdpdGggdGhlIEZpYmVyLiBPbiB0aGUgc2Vjb25kIHJlbmRlciwgd2UgcmVzZXQgdGhlIGdsb2JhbCBjb3VudGVyIHRvIHRoaXMgdmFsdWUuXG4gICAgICAgIC8vIFNpbmNlIFJlYWN0IHJ1bnMgdGhlIHNlY29uZCByZW5kZXIgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGZpcnN0LCB0aGlzIGlzIHNhZmUuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IGN1cnJlbnRPd25lciA9IChfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSAoMCwgJDczU0p4JHJlYWN0KS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCkgPT09IG51bGwgfHwgX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEX1JlYWN0Q3VycmVudE93bmVyID0gX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyKSA9PT0gbnVsbCB8fCBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgICBpZiAoY3VycmVudE93bmVyKSB7XG4gICAgICAgICAgICBsZXQgcHJldkNvbXBvbmVudFZhbHVlID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNvbXBvbmVudElkcy5nZXQoY3VycmVudE93bmVyKTtcbiAgICAgICAgICAgIGlmIChwcmV2Q29tcG9uZW50VmFsdWUgPT0gbnVsbCkgLy8gT24gdGhlIGZpcnN0IHJlbmRlciwgYW5kIGZpcnN0IGNhbGwgdG8gdXNlSWQsIHN0b3JlIHRoZSBpZCBhbmQgc3RhdGUgaW4gb3VyIHdlYWsgbWFwLlxuICAgICAgICAgICAgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNvbXBvbmVudElkcy5zZXQoY3VycmVudE93bmVyLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGN0eC5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHN0YXRlOiBjdXJyZW50T3duZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50T3duZXIubWVtb2l6ZWRTdGF0ZSAhPT0gcHJldkNvbXBvbmVudFZhbHVlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gdGhlIHNlY29uZCByZW5kZXIsIHRoZSBtZW1vaXplZFN0YXRlIGdldHMgcmVzZXQgYnkgUmVhY3QuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvdW50ZXIsIGFuZCByZW1vdmUgZnJvbSB0aGUgd2VhayBtYXAgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBkbyB0aGlzIGZvciBzdWJzZXF1ZW50IHVzZUlkIGNhbGxzLlxuICAgICAgICAgICAgICAgIGN0eC5jdXJyZW50ID0gcHJldkNvbXBvbmVudFZhbHVlLmlkO1xuICAgICAgICAgICAgICAgICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuZGVsZXRlKGN1cnJlbnRPd25lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3B1cmUtcmVuZGVyXG4gICAgICAgIHJlZi5jdXJyZW50ID0gKytjdHguY3VycmVudDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3B1cmUtcmVuZGVyXG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUxlZ2FjeVNTUlNhZmVJZChkZWZhdWx0SWQpIHtcbiAgICBsZXQgY3R4ID0gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCk7XG4gICAgLy8gSWYgd2UgYXJlIHJlbmRlcmluZyBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIGFuZCB0aGVyZSdzIG5vIFNTUlByb3ZpZGVyLFxuICAgIC8vIHByb3ZpZGUgYSB3YXJuaW5nIHRvIGhpbnQgdG8gdGhlIGRldmVsb3BlciB0byBhZGQgb25lLlxuICAgIGlmIChjdHggPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCAmJiAhJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNhblVzZURPTSkgY29uc29sZS53YXJuKFwiV2hlbiBzZXJ2ZXIgcmVuZGVyaW5nLCB5b3UgbXVzdCB3cmFwIHlvdXIgYXBwbGljYXRpb24gaW4gYW4gPFNTUlByb3ZpZGVyPiB0byBlbnN1cmUgY29uc2lzdGVudCBpZHMgYXJlIGdlbmVyYXRlZCBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHNlcnZlci5cIik7XG4gICAgbGV0IGNvdW50ZXIgPSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlcighIWRlZmF1bHRJZCk7XG4gICAgbGV0IHByZWZpeCA9IGN0eCA9PT0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IFwicmVhY3QtYXJpYVwiIDogYHJlYWN0LWFyaWEke2N0eC5wcmVmaXh9YDtcbiAgICByZXR1cm4gZGVmYXVsdElkIHx8IGAke3ByZWZpeH0tJHtjb3VudGVyfWA7XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTW9kZXJuU1NSU2FmZUlkKGRlZmF1bHRJZCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZXQgaWQgPSAoMCwgJDczU0p4JHJlYWN0KS51c2VJZCgpO1xuICAgIGxldCBbZGlkU1NSXSA9ICgwLCAkNzNTSngkdXNlU3RhdGUpKCRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczKCkpO1xuICAgIGxldCBwcmVmaXggPSBkaWRTU1IgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gXCJyZWFjdC1hcmlhXCIgOiBgcmVhY3QtYXJpYSR7JGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0LnByZWZpeH1gO1xuICAgIHJldHVybiBkZWZhdWx0SWQgfHwgYCR7cHJlZml4fS0ke2lkfWA7XG59XG5jb25zdCAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNjE5NTAwOTU5ZmM0OGIyNiA9IHR5cGVvZiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZUlkXCJdID09PSBcImZ1bmN0aW9uXCIgPyAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTW9kZXJuU1NSU2FmZUlkIDogJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUxlZ2FjeVNTUlNhZmVJZDtcbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTbmFwc2hvdCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpIHtcbiAgICAvLyBub29wXG4gICAgcmV0dXJuICgpPT57fTtcbn1cbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczKCkge1xuICAgIC8vIEluIFJlYWN0IDE4LCB3ZSBjYW4gdXNlIHVzZVN5bmNFeHRlcm5hbFN0b3JlIHRvIGRldGVjdCBpZiB3ZSdyZSBzZXJ2ZXIgcmVuZGVyaW5nIG9yIGh5ZHJhdGluZy5cbiAgICBpZiAodHlwZW9mICgwLCAkNzNTSngkcmVhY3QpW1widXNlU3luY0V4dGVybmFsU3RvcmVcIl0gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuICgwLCAkNzNTSngkcmVhY3QpW1widXNlU3luY0V4dGVybmFsU3RvcmVcIl0oJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHN1YnNjcmliZSwgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNuYXBzaG90LCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHJldHVybiAoMCwgJDczU0p4JHVzZUNvbnRleHQpKCRiNWUyNTdkNTY5Njg4YWM2JHZhciRJc1NTUkNvbnRleHQpO1xufVxuXG5cblxuXG5leHBvcnQgeyRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ5ZjhhYzk2YWY0YjFiMmFlIGFzIFNTUlByb3ZpZGVyLCAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNjE5NTAwOTU5ZmM0OGIyNiBhcyB1c2VTU1JTYWZlSWQsICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczIGFzIHVzZUlzU1NSfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyIkNzNTSngkcmVhY3QiLCJ1c2VDb250ZXh0IiwiJDczU0p4JHVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsIiQ3M1NKeCR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkNzNTSngkdXNlTWVtbyIsInVzZUxheW91dEVmZmVjdCIsIiQ3M1NKeCR1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCIkNzNTSngkdXNlUmVmIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0IiwicHJlZml4IiwiU3RyaW5nIiwiTWF0aCIsInJvdW5kIiwicmFuZG9tIiwiY3VycmVudCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRTU1JDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRJc1NTUkNvbnRleHQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkTGVnYWN5U1NSUHJvdmlkZXIiLCJwcm9wcyIsImN1ciIsImNvdW50ZXIiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlciIsImlzU1NSIiwic2V0SXNTU1IiLCJ2YWx1ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwiY2hpbGRyZW4iLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkd2FybmVkQWJvdXRTU1JQcm92aWRlciIsIiRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ5ZjhhYzk2YWY0YjFiMmFlIiwicHJvY2VzcyIsImNvbnNvbGUiLCJ3YXJuIiwiRnJhZ21lbnQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY2FuVXNlRE9NIiwiQm9vbGVhbiIsIndpbmRvdyIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMiLCJXZWFrTWFwIiwiaXNEaXNhYmxlZCIsImN0eCIsInJlZiIsIl9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lciIsIl9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImN1cnJlbnRPd25lciIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiUmVhY3RDdXJyZW50T3duZXIiLCJwcmV2Q29tcG9uZW50VmFsdWUiLCJnZXQiLCJzZXQiLCJpZCIsInN0YXRlIiwibWVtb2l6ZWRTdGF0ZSIsImRlbGV0ZSIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VMZWdhY3lTU1JTYWZlSWQiLCJkZWZhdWx0SWQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTW9kZXJuU1NSU2FmZUlkIiwidXNlSWQiLCJkaWRTU1IiLCIkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MyIsIiRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ2MTk1MDA5NTlmYzQ4YjI2IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNuYXBzaG90IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNlcnZlclNuYXBzaG90IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHN1YnNjcmliZSIsIm9uU3RvcmVDaGFuZ2UiLCJTU1JQcm92aWRlciIsInVzZVNTUlNhZmVJZCIsInVzZUlzU1NSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/focus/node_modules/@react-aria/ssr/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/interactions/dist/import.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@react-aria/interactions/dist/import.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClearPressResponder: () => (/* binding */ $f1ab8c75478c6f73$export$cf75428e0b9ed1ea),\n/* harmony export */   PressResponder: () => (/* binding */ $f1ab8c75478c6f73$export$3351871ee4b288b8),\n/* harmony export */   Pressable: () => (/* binding */ $3b117e43dc0ca95d$export$27c701ed9e449e99),\n/* harmony export */   getInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$630ff653c5ada6a9),\n/* harmony export */   isFocusVisible: () => (/* binding */ $507fabe10e71c6fb$export$b9b3dfddab17db27),\n/* harmony export */   setInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$8397ddfc504fdb9a),\n/* harmony export */   useFocus: () => (/* binding */ $a1ea59d68270f0dd$export$f8168d8dd8fd66e6),\n/* harmony export */   useFocusVisible: () => (/* binding */ $507fabe10e71c6fb$export$ffd9e5021c1fb2d6),\n/* harmony export */   useFocusVisibleListener: () => (/* binding */ $507fabe10e71c6fb$export$ec71b4b83ac08ec3),\n/* harmony export */   useFocusWithin: () => (/* binding */ $9ab94262bd0047c7$export$420e68273165f4ec),\n/* harmony export */   useHover: () => (/* binding */ $6179b936705e76d3$export$ae780daf29e6d456),\n/* harmony export */   useInteractOutside: () => (/* binding */ $e0b6e0b68ec7f50f$export$872b660ac5a1ff98),\n/* harmony export */   useInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$98e20ec92f614cfe),\n/* harmony export */   useKeyboard: () => (/* binding */ $46d819fcbaf35654$export$8f71654801c2f7cd),\n/* harmony export */   useLongPress: () => (/* binding */ $8a26561d2877236e$export$c24ed0104d07eab9),\n/* harmony export */   useMove: () => (/* binding */ $e8a7022cf87cba2a$export$36da96379f79f245),\n/* harmony export */   usePress: () => (/* binding */ $f6c31cce2adf654f$export$45712eceda6fad21),\n/* harmony export */   useScrollWheel: () => (/* binding */ $7d0a636d7a4dcefd$export$2123ff2b87c81ca)\n/* harmony export */ });\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(ssr)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(ssr)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(ssr)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/./node_modules/@react-aria/ssr/dist/import.mjs\");\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element\n// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually\nlet $14c0b72509d70225$var$state = \"default\";\nlet $14c0b72509d70225$var$savedUserSelect = \"\";\nlet $14c0b72509d70225$var$modifiedElementMap = new WeakMap();\nfunction $14c0b72509d70225$export$16a4697467175487(target) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isIOS)()) {\n        if ($14c0b72509d70225$var$state === \"default\") {\n            // eslint-disable-next-line no-restricted-globals\n            const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(target);\n            $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;\n            documentObject.documentElement.style.webkitUserSelect = \"none\";\n        }\n        $14c0b72509d70225$var$state = \"disabled\";\n    } else if (target instanceof HTMLElement || target instanceof SVGElement) {\n        // If not iOS, store the target's original user-select and change to user-select: none\n        // Ignore state since it doesn't apply for non iOS\n        $14c0b72509d70225$var$modifiedElementMap.set(target, target.style.userSelect);\n        target.style.userSelect = \"none\";\n    }\n}\nfunction $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isIOS)()) {\n        // If the state is already default, there's nothing to do.\n        // If it is restoring, then there's no need to queue a second restore.\n        if ($14c0b72509d70225$var$state !== \"disabled\") return;\n        $14c0b72509d70225$var$state = \"restoring\";\n        // There appears to be a delay on iOS where selection still might occur\n        // after pointer up, so wait a bit before removing user-select.\n        setTimeout(()=>{\n            // Wait for any CSS transitions to complete so we don't recompute style\n            // for the whole page in the middle of the animation and cause jank.\n            (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.runAfterTransition)(()=>{\n                // Avoid race conditions\n                if ($14c0b72509d70225$var$state === \"restoring\") {\n                    // eslint-disable-next-line no-restricted-globals\n                    const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(target);\n                    if (documentObject.documentElement.style.webkitUserSelect === \"none\") documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || \"\";\n                    $14c0b72509d70225$var$savedUserSelect = \"\";\n                    $14c0b72509d70225$var$state = \"default\";\n                }\n            });\n        }, 300);\n    } else if (target instanceof HTMLElement || target instanceof SVGElement) // Ignore state since it doesn't apply for non iOS\n    {\n        if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {\n            let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);\n            if (target.style.userSelect === \"none\" && targetOldUserSelect) target.style.userSelect = targetOldUserSelect;\n            if (target.getAttribute(\"style\") === \"\") target.removeAttribute(\"style\");\n            $14c0b72509d70225$var$modifiedElementMap.delete(target);\n        }\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext({\n    register: ()=>{}\n});\n$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = \"PressResponderContext\";\nfunction $f6c31cce2adf654f$var$usePressResponderContext(props) {\n    // Consume context from <PressResponder> and merge with props.\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n    if (context) {\n        let { register: register, ...contextProps } = context;\n        props = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(contextProps, props);\n        register();\n    }\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useSyncRef)(context, props.ref);\n    return props;\n}\nvar $f6c31cce2adf654f$var$_shouldStopPropagation = /*#__PURE__*/ new WeakMap();\nclass $f6c31cce2adf654f$var$PressEvent {\n    continuePropagation() {\n        (0, _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);\n    }\n    get shouldStopPropagation() {\n        return (0, _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);\n    }\n    constructor(type, pointerType, originalEvent){\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {\n            writable: true,\n            value: void 0\n        });\n        (0, _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);\n        this.type = type;\n        this.pointerType = pointerType;\n        this.target = originalEvent.currentTarget;\n        this.shiftKey = originalEvent.shiftKey;\n        this.metaKey = originalEvent.metaKey;\n        this.ctrlKey = originalEvent.ctrlKey;\n        this.altKey = originalEvent.altKey;\n    }\n}\nconst $f6c31cce2adf654f$var$LINK_CLICKED = Symbol(\"linkClicked\");\nfunction $f6c31cce2adf654f$export$45712eceda6fad21(props) {\n    let { onPress: onPress, onPressChange: onPressChange, onPressStart: onPressStart, onPressEnd: onPressEnd, onPressUp: onPressUp, isDisabled: isDisabled, isPressed: isPressedProp, preventFocusOnPress: preventFocusOnPress, shouldCancelOnPointerExit: shouldCancelOnPointerExit, allowTextSelectionOnPress: allowTextSelectionOnPress, ref: _, ...domProps } = $f6c31cce2adf654f$var$usePressResponderContext(props);\n    let [isPressed, setPressed] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isPressed: false,\n        ignoreEmulatedMouseEvents: false,\n        ignoreClickAfterPress: false,\n        didFirePressStart: false,\n        isTriggeringEvent: false,\n        activePointerId: null,\n        target: null,\n        isOverTarget: false,\n        pointerType: null\n    });\n    let { addGlobalListener: addGlobalListener, removeAllGlobalListeners: removeAllGlobalListeners } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let triggerPressStart = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        let state = ref.current;\n        if (isDisabled || state.didFirePressStart) return false;\n        let shouldStopPropagation = true;\n        state.isTriggeringEvent = true;\n        if (onPressStart) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressstart\", pointerType, originalEvent);\n            onPressStart(event);\n            shouldStopPropagation = event.shouldStopPropagation;\n        }\n        if (onPressChange) onPressChange(true);\n        state.isTriggeringEvent = false;\n        state.didFirePressStart = true;\n        setPressed(true);\n        return shouldStopPropagation;\n    });\n    let triggerPressEnd = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{\n        let state = ref.current;\n        if (!state.didFirePressStart) return false;\n        state.ignoreClickAfterPress = true;\n        state.didFirePressStart = false;\n        state.isTriggeringEvent = true;\n        let shouldStopPropagation = true;\n        if (onPressEnd) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressend\", pointerType, originalEvent);\n            onPressEnd(event);\n            shouldStopPropagation = event.shouldStopPropagation;\n        }\n        if (onPressChange) onPressChange(false);\n        setPressed(false);\n        if (onPress && wasPressed && !isDisabled) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"press\", pointerType, originalEvent);\n            onPress(event);\n            shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\n        }\n        state.isTriggeringEvent = false;\n        return shouldStopPropagation;\n    });\n    let triggerPressUp = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        let state = ref.current;\n        if (isDisabled) return false;\n        if (onPressUp) {\n            state.isTriggeringEvent = true;\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressup\", pointerType, originalEvent);\n            onPressUp(event);\n            state.isTriggeringEvent = false;\n            return event.shouldStopPropagation;\n        }\n        return true;\n    });\n    let cancel = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        let state = ref.current;\n        if (state.isPressed && state.target) {\n            if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n            state.isPressed = false;\n            state.isOverTarget = false;\n            state.activePointerId = null;\n            state.pointerType = null;\n            removeAllGlobalListeners();\n            if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n        }\n    });\n    let cancelOnPointerExit = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (shouldCancelOnPointerExit) cancel(e);\n    });\n    let pressProps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let state = ref.current;\n        let pressProps = {\n            onKeyDown (e) {\n                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\n                    var _state_metaKeyEvents;\n                    if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n                    // If the event is repeating, it may have started on a different element\n                    // after which focus moved to the current element. Ignore these events and\n                    // only handle the first key down event.\n                    let shouldStopPropagation = true;\n                    if (!state.isPressed && !e.repeat) {\n                        state.target = e.currentTarget;\n                        state.isPressed = true;\n                        shouldStopPropagation = triggerPressStart(e, \"keyboard\");\n                        // Focus may move before the key up event, so register the event on the document\n                        // instead of the same element where the key down event occurred.\n                        addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"keyup\", onKeyUp, false);\n                    }\n                    if (shouldStopPropagation) e.stopPropagation();\n                    // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n                    // macOS has a bug where keyup events are not fired while the Meta key is down.\n                    // When the Meta key itself is released we will get an event for that, and we'll act as if\n                    // all of these other keys were released as well.\n                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n                    // https://bugs.webkit.org/show_bug.cgi?id=55291\n                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n                    if (e.metaKey && (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isMac)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e.key, e.nativeEvent);\n                } else if (e.key === \"Meta\") state.metaKeyEvents = new Map();\n            },\n            onKeyUp (e) {\n                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e), \"keyboard\");\n            },\n            onClick (e) {\n                if (e && !e.currentTarget.contains(e.target)) return;\n                if (e && e.button === 0 && !state.isTriggeringEvent && !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.openLink).isOpening) {\n                    let shouldStopPropagation = true;\n                    if (isDisabled) e.preventDefault();\n                    // If triggered from a screen reader or by using element.click(),\n                    // trigger as if it were a keyboard click.\n                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === \"virtual\" || (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e.nativeEvent))) {\n                        // Ensure the element receives focus (VoiceOver on iOS does not do this)\n                        if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                        let stopPressStart = triggerPressStart(e, \"virtual\");\n                        let stopPressUp = triggerPressUp(e, \"virtual\");\n                        let stopPressEnd = triggerPressEnd(e, \"virtual\");\n                        shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n                    }\n                    state.ignoreEmulatedMouseEvents = false;\n                    state.ignoreClickAfterPress = false;\n                    if (shouldStopPropagation) e.stopPropagation();\n                }\n            }\n        };\n        let onKeyUp = (e)=>{\n            var _state_metaKeyEvents;\n            if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e, state.target)) {\n                var _state_metaKeyEvents1;\n                if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n                let target = e.target;\n                let shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), \"keyboard\", state.target.contains(target));\n                removeAllGlobalListeners();\n                if (shouldStopPropagation) e.stopPropagation();\n                // If a link was triggered with a key other than Enter, open the URL ourselves.\n                // This means the link has a role override, and the default browser behavior\n                // only applies when using the Enter key.\n                if (e.key !== \"Enter\" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[$f6c31cce2adf654f$var$LINK_CLICKED]) {\n                    // Store a hidden property on the event so we only trigger link click once,\n                    // even if there are multiple usePress instances attached to the element.\n                    e[$f6c31cce2adf654f$var$LINK_CLICKED] = true;\n                    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.openLink)(state.target, e, false);\n                }\n                state.isPressed = false;\n                (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e.key);\n            } else if (e.key === \"Meta\" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {\n                var _state_target;\n                // If we recorded keydown events that occurred while the Meta key was pressed,\n                // and those haven't received keyup events already, fire keyup events ourselves.\n                // See comment above for more info about the macOS bug causing this.\n                let events = state.metaKeyEvents;\n                state.metaKeyEvents = undefined;\n                for (let event of events.values())(_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent(\"keyup\", event));\n            }\n        };\n        if (typeof PointerEvent !== \"undefined\") {\n            pressProps.onPointerDown = (e)=>{\n                // Only handle left clicks, and ignore events that bubbled through portals.\n                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n                // Ignore and let the onClick handler take care of it instead.\n                // https://bugs.webkit.org/show_bug.cgi?id=222627\n                // https://bugs.webkit.org/show_bug.cgi?id=223202\n                if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualPointerEvent)(e.nativeEvent)) {\n                    state.pointerType = \"virtual\";\n                    return;\n                }\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent\n                // default on pointer down and handle focusing the pressable element ourselves.\n                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                state.pointerType = e.pointerType;\n                let shouldStopPropagation = true;\n                if (!state.isPressed) {\n                    state.isPressed = true;\n                    state.isOverTarget = true;\n                    state.activePointerId = e.pointerId;\n                    state.target = e.currentTarget;\n                    if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                    if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n                    shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointermove\", onPointerMove, false);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointerup\", onPointerUp, false);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointercancel\", onPointerCancel, false);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseDown = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (e.button === 0) {\n                    // Chrome and Firefox on touch Windows devices require mouse down events\n                    // to be canceled in addition to pointer events, or an extra asynchronous\n                    // focus event will be fired.\n                    if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                    e.stopPropagation();\n                }\n            };\n            pressProps.onPointerUp = (e)=>{\n                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n                if (!e.currentTarget.contains(e.target) || state.pointerType === \"virtual\") return;\n                // Only handle left clicks\n                // Safari on iOS sometimes fires pointerup events, even\n                // when the touch isn't over the target, so double check.\n                if (e.button === 0 && $f6c31cce2adf654f$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);\n            };\n            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.\n            // Use pointer move events instead to implement our own hit testing.\n            // See https://bugs.webkit.org/show_bug.cgi?id=199803\n            let onPointerMove = (e)=>{\n                if (e.pointerId !== state.activePointerId) return;\n                if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target)) {\n                    if (!state.isOverTarget && state.pointerType != null) {\n                        state.isOverTarget = true;\n                        triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                    }\n                } else if (state.target && state.isOverTarget && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n            };\n            let onPointerUp = (e)=>{\n                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n                    if ($f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                    else if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                    state.isPressed = false;\n                    state.isOverTarget = false;\n                    state.activePointerId = null;\n                    state.pointerType = null;\n                    removeAllGlobalListeners();\n                    if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n                }\n            };\n            let onPointerCancel = (e)=>{\n                cancel(e);\n            };\n            pressProps.onDragStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n                cancel(e);\n            };\n        } else {\n            pressProps.onMouseDown = (e)=>{\n                // Only handle left clicks\n                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent\n                // default on mouse down and handle focusing the pressable element ourselves.\n                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                if (state.ignoreEmulatedMouseEvents) {\n                    e.stopPropagation();\n                    return;\n                }\n                state.isPressed = true;\n                state.isOverTarget = true;\n                state.target = e.currentTarget;\n                state.pointerType = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e.nativeEvent) ? \"virtual\" : \"mouse\";\n                if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                if (shouldStopPropagation) e.stopPropagation();\n                addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"mouseup\", onMouseUp, false);\n            };\n            pressProps.onMouseEnter = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let shouldStopPropagation = true;\n                if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n                    state.isOverTarget = true;\n                    shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseLeave = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let shouldStopPropagation = true;\n                if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseUp = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType || \"mouse\");\n            };\n            let onMouseUp = (e)=>{\n                // Only handle left clicks\n                if (e.button !== 0) return;\n                state.isPressed = false;\n                removeAllGlobalListeners();\n                if (state.ignoreEmulatedMouseEvents) {\n                    state.ignoreEmulatedMouseEvents = false;\n                    return;\n                }\n                if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                else if (state.target && state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                state.isOverTarget = false;\n            };\n            pressProps.onTouchStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e.nativeEvent);\n                if (!touch) return;\n                state.activePointerId = touch.identifier;\n                state.ignoreEmulatedMouseEvents = true;\n                state.isOverTarget = true;\n                state.isPressed = true;\n                state.target = e.currentTarget;\n                state.pointerType = \"touch\";\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent default\n                // on the emulated mouse event and handle focusing the pressable element ourselves.\n                if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n                let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                if (shouldStopPropagation) e.stopPropagation();\n                addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(e.currentTarget), \"scroll\", onScroll, true);\n            };\n            pressProps.onTouchMove = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.isPressed) {\n                    e.stopPropagation();\n                    return;\n                }\n                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n                let shouldStopPropagation = true;\n                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget)) {\n                    if (!state.isOverTarget && state.pointerType != null) {\n                        state.isOverTarget = true;\n                        shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                    }\n                } else if (state.isOverTarget && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onTouchEnd = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.isPressed) {\n                    e.stopPropagation();\n                    return;\n                }\n                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n                let shouldStopPropagation = true;\n                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n                    triggerPressUp(e, state.pointerType);\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n                } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                if (shouldStopPropagation) e.stopPropagation();\n                state.isPressed = false;\n                state.activePointerId = null;\n                state.isOverTarget = false;\n                state.ignoreEmulatedMouseEvents = true;\n                if (state.target && !allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n                removeAllGlobalListeners();\n            };\n            pressProps.onTouchCancel = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                e.stopPropagation();\n                if (state.isPressed) cancel(e);\n            };\n            let onScroll = (e)=>{\n                if (state.isPressed && e.target.contains(state.target)) cancel({\n                    currentTarget: state.target,\n                    shiftKey: false,\n                    ctrlKey: false,\n                    metaKey: false,\n                    altKey: false\n                });\n            };\n            pressProps.onDragStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                cancel(e);\n            };\n        }\n        return pressProps;\n    }, [\n        addGlobalListener,\n        isDisabled,\n        preventFocusOnPress,\n        removeAllGlobalListeners,\n        allowTextSelectionOnPress,\n        cancel,\n        cancelOnPointerExit,\n        triggerPressEnd,\n        triggerPressStart,\n        triggerPressUp\n    ]);\n    // Remove user-select: none in case component unmounts immediately after pressStart\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            var _ref_current_target;\n            if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_ref_current_target = ref.current.target) !== null && _ref_current_target !== void 0 ? _ref_current_target : undefined);\n        };\n    }, [\n        allowTextSelectionOnPress\n    ]);\n    return {\n        isPressed: isPressedProp || isPressed,\n        pressProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(domProps, pressProps)\n    };\n}\nfunction $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {\n    return target.tagName === \"A\" && target.hasAttribute(\"href\");\n}\nfunction $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {\n    const { key: key, code: code } = event;\n    const element = currentTarget;\n    const role = element.getAttribute(\"role\");\n    // Accessibility for keyboards. Space and Enter only.\n    // \"Spacebar\" is for IE 11\n    return (key === \"Enter\" || key === \" \" || key === \"Spacebar\" || code === \"Space\") && !(element instanceof (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(element).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key) || element instanceof (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(element).HTMLTextAreaElement || element.isContentEditable) && // Links should only trigger with Enter key\n    !((role === \"link\" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element)) && key !== \"Enter\");\n}\nfunction $f6c31cce2adf654f$var$getTouchFromEvent(event) {\n    const { targetTouches: targetTouches } = event;\n    if (targetTouches.length > 0) return targetTouches[0];\n    return null;\n}\nfunction $f6c31cce2adf654f$var$getTouchById(event, pointerId) {\n    const changedTouches = event.changedTouches;\n    for(let i = 0; i < changedTouches.length; i++){\n        const touch = changedTouches[i];\n        if (touch.identifier === pointerId) return touch;\n    }\n    return null;\n}\nfunction $f6c31cce2adf654f$var$createEvent(target, e) {\n    return {\n        currentTarget: target,\n        shiftKey: e.shiftKey,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey\n    };\n}\nfunction $f6c31cce2adf654f$var$getPointClientRect(point) {\n    let offsetX = 0;\n    let offsetY = 0;\n    if (point.width !== undefined) offsetX = point.width / 2;\n    else if (point.radiusX !== undefined) offsetX = point.radiusX;\n    if (point.height !== undefined) offsetY = point.height / 2;\n    else if (point.radiusY !== undefined) offsetY = point.radiusY;\n    return {\n        top: point.clientY - offsetY,\n        right: point.clientX + offsetX,\n        bottom: point.clientY + offsetY,\n        left: point.clientX - offsetX\n    };\n}\nfunction $f6c31cce2adf654f$var$areRectanglesOverlapping(a, b) {\n    // check if they cannot overlap on x axis\n    if (a.left > b.right || b.left > a.right) return false;\n    // check if they cannot overlap on y axis\n    if (a.top > b.bottom || b.top > a.bottom) return false;\n    return true;\n}\nfunction $f6c31cce2adf654f$var$isOverTarget(point, target) {\n    let rect = target.getBoundingClientRect();\n    let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);\n    return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefault(target) {\n    // We cannot prevent default if the target is a draggable element.\n    return !(target instanceof HTMLElement) || !target.hasAttribute(\"draggable\");\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {\n    if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);\n    if (target instanceof HTMLButtonElement) return target.type !== \"submit\" && target.type !== \"reset\";\n    if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;\n    return true;\n}\nconst $f6c31cce2adf654f$var$nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\nfunction $f6c31cce2adf654f$var$isValidInputKey(target, key) {\n    // Only space should toggle checkboxes and radios, not enter.\n    return target.type === \"checkbox\" || target.type === \"radio\" ? key === \" \" : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);\n}\nconst $3b117e43dc0ca95d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef(({ children: children, ...props }, ref)=>{\n    ref = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useObjectRef)(ref);\n    let { pressProps: pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({\n        ...props,\n        ref: ref\n    });\n    let child = (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.only(children);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).cloneElement(child, {\n        ref: ref,\n        ...(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(child.props, pressProps)\n    });\n});\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $f1ab8c75478c6f73$export$3351871ee4b288b8 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef(({ children: children, ...props }, ref)=>{\n    let isRegistered = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let prevContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n    ref = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useObjectRef)(ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref));\n    let context = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(prevContext || {}, {\n        ...props,\n        ref: ref,\n        register () {\n            isRegistered.current = true;\n            if (prevContext) prevContext.register();\n        }\n    });\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useSyncRef)(prevContext, ref);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isRegistered.current) {\n            console.warn(\"A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.\");\n            isRegistered.current = true; // only warn once in strict mode.\n        }\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {\n        value: context\n    }, children);\n});\nfunction $f1ab8c75478c6f73$export$cf75428e0b9ed1ea({ children: children }) {\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            register: ()=>{}\n        }), []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {\n        value: context\n    }, children);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $8a9cb279dc87e130$export$905e7fc544a71f36 {\n    isDefaultPrevented() {\n        return this.nativeEvent.defaultPrevented;\n    }\n    preventDefault() {\n        this.defaultPrevented = true;\n        this.nativeEvent.preventDefault();\n    }\n    stopPropagation() {\n        this.nativeEvent.stopPropagation();\n        this.isPropagationStopped = ()=>true;\n    }\n    isPropagationStopped() {\n        return false;\n    }\n    persist() {}\n    constructor(type, nativeEvent){\n        this.nativeEvent = nativeEvent;\n        this.target = nativeEvent.target;\n        this.currentTarget = nativeEvent.currentTarget;\n        this.relatedTarget = nativeEvent.relatedTarget;\n        this.bubbles = nativeEvent.bubbles;\n        this.cancelable = nativeEvent.cancelable;\n        this.defaultPrevented = nativeEvent.defaultPrevented;\n        this.eventPhase = nativeEvent.eventPhase;\n        this.isTrusted = nativeEvent.isTrusted;\n        this.timeStamp = nativeEvent.timeStamp;\n        this.type = type;\n    }\n}\nfunction $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {\n    let stateRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocused: false,\n        observer: null\n    });\n    // Clean up MutationObserver on unmount. See below.\n    // eslint-disable-next-line arrow-body-style\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        const state = stateRef.current;\n        return ()=>{\n            if (state.observer) {\n                state.observer.disconnect();\n                state.observer = null;\n            }\n        };\n    }, []);\n    let dispatchBlur = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);\n    });\n    // This function is called during a React onFocus event.\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {\n            stateRef.current.isFocused = true;\n            let target = e.target;\n            let onBlurHandler = (e)=>{\n                stateRef.current.isFocused = false;\n                if (target.disabled) dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36(\"blur\", e));\n                // We no longer need the MutationObserver once the target is blurred.\n                if (stateRef.current.observer) {\n                    stateRef.current.observer.disconnect();\n                    stateRef.current.observer = null;\n                }\n            };\n            target.addEventListener(\"focusout\", onBlurHandler, {\n                once: true\n            });\n            stateRef.current.observer = new MutationObserver(()=>{\n                if (stateRef.current.isFocused && target.disabled) {\n                    var _stateRef_current_observer;\n                    (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();\n                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n                    target.dispatchEvent(new FocusEvent(\"blur\", {\n                        relatedTarget: relatedTargetEl\n                    }));\n                    target.dispatchEvent(new FocusEvent(\"focusout\", {\n                        bubbles: true,\n                        relatedTarget: relatedTargetEl\n                    }));\n                }\n            });\n            stateRef.current.observer.observe(target, {\n                attributes: true,\n                attributeFilter: [\n                    \"disabled\"\n                ]\n            });\n        }\n    }, [\n        dispatchBlur\n    ]);\n}\nfunction $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {\n    let { isDisabled: isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange: onFocusChange } = props;\n    const onBlur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (e.target === e.currentTarget) {\n            if (onBlurProp) onBlurProp(e);\n            if (onFocusChange) onFocusChange(false);\n            return true;\n        }\n    }, [\n        onBlurProp,\n        onFocusChange\n    ]);\n    const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);\n    const onFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Double check that document.activeElement actually matches e.target in case a previously chained\n        // focus handler already moved focus somewhere else.\n        if (e.target === e.currentTarget && document.activeElement === e.target) {\n            if (onFocusProp) onFocusProp(e);\n            if (onFocusChange) onFocusChange(true);\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusChange,\n        onFocusProp,\n        onSyntheticFocus\n    ]);\n    return {\n        focusProps: {\n            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,\n            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nlet $507fabe10e71c6fb$var$currentModality = null;\nlet $507fabe10e71c6fb$var$changeHandlers = new Set();\nlet $507fabe10e71c6fb$var$hasSetupGlobalListeners = false;\nlet $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\nlet $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n// Only Tab or Esc keys will make focus visible on text input elements\nconst $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n    Tab: true,\n    Escape: true\n};\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {\n    for (let handler of $507fabe10e71c6fb$var$changeHandlers)handler(modality, e);\n}\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */ function $507fabe10e71c6fb$var$isValidKey(e) {\n    // Control and Shift keys trigger when navigating back to the tab with keyboard.\n    return !(e.metaKey || !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isMac)() && e.altKey || e.ctrlKey || e.key === \"Control\" || e.key === \"Shift\" || e.key === \"Meta\");\n}\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e) {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    if ($507fabe10e71c6fb$var$isValidKey(e)) {\n        $507fabe10e71c6fb$var$currentModality = \"keyboard\";\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"keyboard\", e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e) {\n    $507fabe10e71c6fb$var$currentModality = \"pointer\";\n    if (e.type === \"mousedown\" || e.type === \"pointerdown\") {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"pointer\", e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handleClickEvent(e) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e)) {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$currentModality = \"virtual\";\n    }\n}\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e) {\n    // Firefox fires two extra focus events when the user first clicks into an iframe:\n    // first on the window, then on the document. We ignore these events so they don't\n    // cause keyboard focus rings to appear.\n    if (e.target === window || e.target === document) return;\n    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n    if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {\n        $507fabe10e71c6fb$var$currentModality = \"virtual\";\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"virtual\", e);\n    }\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n}\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n    // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n    // for example, since a subsequent focus event won't be fired.\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;\n}\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */ function $507fabe10e71c6fb$var$setupGlobalFocusEvents() {\n    if (true) return;\n    // Programmatic focus() calls shouldn't affect the current input modality.\n    // However, we need to detect other cases when a focus event occurs without\n    // a preceding user event (e.g. screen reader focus). Overriding the focus\n    // method on HTMLElement.prototype is a bit hacky, but works.\n    let focus = HTMLElement.prototype.focus;\n    HTMLElement.prototype.focus = function() {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        focus.apply(this, arguments);\n    };\n    document.addEventListener(\"keydown\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    document.addEventListener(\"keyup\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    document.addEventListener(\"click\", $507fabe10e71c6fb$var$handleClickEvent, true);\n    // Register focus events on the window so they are sure to happen\n    // before React's event listeners (registered on the document).\n    window.addEventListener(\"focus\", $507fabe10e71c6fb$var$handleFocusEvent, true);\n    window.addEventListener(\"blur\", $507fabe10e71c6fb$var$handleWindowBlur, false);\n    if (typeof PointerEvent !== \"undefined\") {\n        document.addEventListener(\"pointerdown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"pointermove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"pointerup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    } else {\n        document.addEventListener(\"mousedown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"mousemove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"mouseup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    }\n    $507fabe10e71c6fb$var$hasSetupGlobalListeners = true;\n}\nif (typeof document !== \"undefined\") {\n    if (document.readyState !== \"loading\") $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    else document.addEventListener(\"DOMContentLoaded\", $507fabe10e71c6fb$var$setupGlobalFocusEvents);\n}\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n    return $507fabe10e71c6fb$var$currentModality !== \"pointer\";\n}\nfunction $507fabe10e71c6fb$export$630ff653c5ada6a9() {\n    return $507fabe10e71c6fb$var$currentModality;\n}\nfunction $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {\n    $507fabe10e71c6fb$var$currentModality = modality;\n    $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);\n}\nfunction $507fabe10e71c6fb$export$98e20ec92f614cfe() {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    let [modality, setModality] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($507fabe10e71c6fb$var$currentModality);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let handler = ()=>{\n            setModality($507fabe10e71c6fb$var$currentModality);\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    }, []);\n    return (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_5__.useIsSSR)() ? null : modality;\n}\nconst $507fabe10e71c6fb$var$nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */ function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n    var _e_target;\n    isTextInput = isTextInput || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(e === null || e === void 0 ? void 0 : (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.type) || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLTextAreaElement || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLElement && (e === null || e === void 0 ? void 0 : e.target.isContentEditable);\n    return !(isTextInput && modality === \"keyboard\" && e instanceof KeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $507fabe10e71c6fb$export$ffd9e5021c1fb2d6(props = {}) {\n    let { isTextInput: isTextInput, autoFocus: autoFocus } = props;\n    let [isFocusVisibleState, setFocusVisible] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());\n    $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible)=>{\n        setFocusVisible(isFocusVisible);\n    }, [\n        isTextInput\n    ], {\n        isTextInput: isTextInput\n    });\n    return {\n        isFocusVisible: isFocusVisibleState\n    };\n}\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let handler = (modality, e)=>{\n            if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;\n            fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nfunction $9ab94262bd0047c7$export$420e68273165f4ec(props) {\n    let { isDisabled: isDisabled, onBlurWithin: onBlurWithin, onFocusWithin: onFocusWithin, onFocusWithinChange: onFocusWithinChange } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocusWithin: false\n    });\n    let onBlur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again\n        // when moving focus inside the element. Only trigger if the currentTarget doesn't\n        // include the relatedTarget (where focus is moving).\n        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {\n            state.current.isFocusWithin = false;\n            if (onBlurWithin) onBlurWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(false);\n        }\n    }, [\n        onBlurWithin,\n        onFocusWithinChange,\n        state\n    ]);\n    let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);\n    let onFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Double check that document.activeElement actually matches e.target in case a previously chained\n        // focus handler already moved focus somewhere else.\n        if (!state.current.isFocusWithin && document.activeElement === e.target) {\n            if (onFocusWithin) onFocusWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(true);\n            state.current.isFocusWithin = true;\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusWithin,\n        onFocusWithinChange,\n        onSyntheticFocus\n    ]);\n    if (isDisabled) return {\n        focusWithinProps: {\n            // These should not have been null, that would conflict in mergeProps\n            onFocus: undefined,\n            onBlur: undefined\n        }\n    };\n    return {\n        focusWithinProps: {\n            onFocus: onFocus,\n            onBlur: onBlur\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\nlet $6179b936705e76d3$var$hoverCount = 0;\nfunction $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {\n    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;\n    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n    // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n    // the distant future because a user previously touched the element.\n    setTimeout(()=>{\n        $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\n    }, 50);\n}\nfunction $6179b936705e76d3$var$handleGlobalPointerEvent(e) {\n    if (e.pointerType === \"touch\") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();\n}\nfunction $6179b936705e76d3$var$setupGlobalTouchEvents() {\n    if (typeof document === \"undefined\") return;\n    if (typeof PointerEvent !== \"undefined\") document.addEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n    else document.addEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n    $6179b936705e76d3$var$hoverCount++;\n    return ()=>{\n        $6179b936705e76d3$var$hoverCount--;\n        if ($6179b936705e76d3$var$hoverCount > 0) return;\n        if (typeof PointerEvent !== \"undefined\") document.removeEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n        else document.removeEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n    };\n}\nfunction $6179b936705e76d3$export$ae780daf29e6d456(props) {\n    let { onHoverStart: onHoverStart, onHoverChange: onHoverChange, onHoverEnd: onHoverEnd, isDisabled: isDisabled } = props;\n    let [isHovered, setHovered] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isHovered: false,\n        ignoreEmulatedMouseEvents: false,\n        pointerType: \"\",\n        target: null\n    }).current;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);\n    let { hoverProps: hoverProps, triggerHoverEnd: triggerHoverEnd } = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let triggerHoverStart = (event, pointerType)=>{\n            state.pointerType = pointerType;\n            if (isDisabled || pointerType === \"touch\" || state.isHovered || !event.currentTarget.contains(event.target)) return;\n            state.isHovered = true;\n            let target = event.currentTarget;\n            state.target = target;\n            if (onHoverStart) onHoverStart({\n                type: \"hoverstart\",\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(true);\n            setHovered(true);\n        };\n        let triggerHoverEnd = (event, pointerType)=>{\n            state.pointerType = \"\";\n            state.target = null;\n            if (pointerType === \"touch\" || !state.isHovered) return;\n            state.isHovered = false;\n            let target = event.currentTarget;\n            if (onHoverEnd) onHoverEnd({\n                type: \"hoverend\",\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(false);\n            setHovered(false);\n        };\n        let hoverProps = {};\n        if (typeof PointerEvent !== \"undefined\") {\n            hoverProps.onPointerEnter = (e)=>{\n                if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === \"mouse\") return;\n                triggerHoverStart(e, e.pointerType);\n            };\n            hoverProps.onPointerLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);\n            };\n        } else {\n            hoverProps.onTouchStart = ()=>{\n                state.ignoreEmulatedMouseEvents = true;\n            };\n            hoverProps.onMouseEnter = (e)=>{\n                if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, \"mouse\");\n                state.ignoreEmulatedMouseEvents = false;\n            };\n            hoverProps.onMouseLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, \"mouse\");\n            };\n        }\n        return {\n            hoverProps: hoverProps,\n            triggerHoverEnd: triggerHoverEnd\n        };\n    }, [\n        onHoverStart,\n        onHoverChange,\n        onHoverEnd,\n        isDisabled,\n        state\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Call the triggerHoverEnd as soon as isDisabled changes to true\n        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n        if (isDisabled) triggerHoverEnd({\n            currentTarget: state.target\n        }, state.pointerType);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled\n    ]);\n    return {\n        hoverProps: hoverProps,\n        isHovered: isHovered\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nfunction $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {\n    let { ref: ref, onInteractOutside: onInteractOutside, isDisabled: isDisabled, onInteractOutsideStart: onInteractOutsideStart } = props;\n    let stateRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isPointerDown: false,\n        ignoreEmulatedMouseEvents: false\n    });\n    let onPointerDown = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) {\n            if (onInteractOutsideStart) onInteractOutsideStart(e);\n            stateRef.current.isPointerDown = true;\n        }\n    });\n    let triggerInteractOutside = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (onInteractOutside) onInteractOutside(e);\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let state = stateRef.current;\n        if (isDisabled) return;\n        const element = ref.current;\n        const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(element);\n        // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n        if (typeof PointerEvent !== \"undefined\") {\n            let onPointerUp = (e)=>{\n                if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            // changing these to capture phase fixed combobox\n            documentObject.addEventListener(\"pointerdown\", onPointerDown, true);\n            documentObject.addEventListener(\"pointerup\", onPointerUp, true);\n            return ()=>{\n                documentObject.removeEventListener(\"pointerdown\", onPointerDown, true);\n                documentObject.removeEventListener(\"pointerup\", onPointerUp, true);\n            };\n        } else {\n            let onMouseUp = (e)=>{\n                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;\n                else if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            let onTouchEnd = (e)=>{\n                state.ignoreEmulatedMouseEvents = true;\n                if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            documentObject.addEventListener(\"mousedown\", onPointerDown, true);\n            documentObject.addEventListener(\"mouseup\", onMouseUp, true);\n            documentObject.addEventListener(\"touchstart\", onPointerDown, true);\n            documentObject.addEventListener(\"touchend\", onTouchEnd, true);\n            return ()=>{\n                documentObject.removeEventListener(\"mousedown\", onPointerDown, true);\n                documentObject.removeEventListener(\"mouseup\", onMouseUp, true);\n                documentObject.removeEventListener(\"touchstart\", onPointerDown, true);\n                documentObject.removeEventListener(\"touchend\", onTouchEnd, true);\n            };\n        }\n    }, [\n        ref,\n        isDisabled,\n        onPointerDown,\n        triggerInteractOutside\n    ]);\n}\nfunction $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {\n    if (event.button > 0) return false;\n    if (event.target) {\n        // if the event target is no longer in the document, ignore\n        const ownerDocument = event.target.ownerDocument;\n        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;\n        // If the target is within a top layer element (e.g. toasts), ignore.\n        if (event.target.closest(\"[data-react-aria-top-layer]\")) return false;\n    }\n    return ref.current && !ref.current.contains(event.target);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $93925083ecbb358c$export$48d1ea6320830260(handler) {\n    if (!handler) return undefined;\n    let shouldStopPropagation = true;\n    return (e)=>{\n        let event = {\n            ...e,\n            preventDefault () {\n                e.preventDefault();\n            },\n            isDefaultPrevented () {\n                return e.isDefaultPrevented();\n            },\n            stopPropagation () {\n                console.error(\"stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.\");\n            },\n            continuePropagation () {\n                shouldStopPropagation = false;\n            }\n        };\n        handler(event);\n        if (shouldStopPropagation) e.stopPropagation();\n    };\n}\nfunction $46d819fcbaf35654$export$8f71654801c2f7cd(props) {\n    return {\n        keyboardProps: props.isDisabled ? {} : {\n            onKeyDown: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyDown),\n            onKeyUp: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyUp)\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e8a7022cf87cba2a$export$36da96379f79f245(props) {\n    let { onMoveStart: onMoveStart, onMove: onMove, onMoveEnd: onMoveEnd } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        didMove: false,\n        lastPosition: null,\n        id: null\n    });\n    let { addGlobalListener: addGlobalListener, removeGlobalListener: removeGlobalListener } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let move = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{\n        if (deltaX === 0 && deltaY === 0) return;\n        if (!state.current.didMove) {\n            state.current.didMove = true;\n            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({\n                type: \"movestart\",\n                pointerType: pointerType,\n                shiftKey: originalEvent.shiftKey,\n                metaKey: originalEvent.metaKey,\n                ctrlKey: originalEvent.ctrlKey,\n                altKey: originalEvent.altKey\n            });\n        }\n        onMove === null || onMove === void 0 ? void 0 : onMove({\n            type: \"move\",\n            pointerType: pointerType,\n            deltaX: deltaX,\n            deltaY: deltaY,\n            shiftKey: originalEvent.shiftKey,\n            metaKey: originalEvent.metaKey,\n            ctrlKey: originalEvent.ctrlKey,\n            altKey: originalEvent.altKey\n        });\n    });\n    let end = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)();\n        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({\n            type: \"moveend\",\n            pointerType: pointerType,\n            shiftKey: originalEvent.shiftKey,\n            metaKey: originalEvent.metaKey,\n            ctrlKey: originalEvent.ctrlKey,\n            altKey: originalEvent.altKey\n        });\n    });\n    let moveProps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let moveProps = {};\n        let start = ()=>{\n            (0, $14c0b72509d70225$export$16a4697467175487)();\n            state.current.didMove = false;\n        };\n        if (typeof PointerEvent === \"undefined\") {\n            let onMouseMove = (e)=>{\n                if (e.button === 0) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    move(e, \"mouse\", e.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                }\n            };\n            let onMouseUp = (e)=>{\n                if (e.button === 0) {\n                    end(e, \"mouse\");\n                    removeGlobalListener(window, \"mousemove\", onMouseMove, false);\n                    removeGlobalListener(window, \"mouseup\", onMouseUp, false);\n                }\n            };\n            moveProps.onMouseDown = (e)=>{\n                if (e.button === 0) {\n                    start();\n                    e.stopPropagation();\n                    e.preventDefault();\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                    addGlobalListener(window, \"mousemove\", onMouseMove, false);\n                    addGlobalListener(window, \"mouseup\", onMouseUp, false);\n                }\n            };\n            let onTouchMove = (e)=>{\n                let touch = [\n                    ...e.changedTouches\n                ].findIndex(({ identifier: identifier })=>identifier === state.current.id);\n                if (touch >= 0) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    let { pageX: pageX, pageY: pageY } = e.changedTouches[touch];\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    move(e, \"touch\", pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: pageX,\n                        pageY: pageY\n                    };\n                }\n            };\n            let onTouchEnd = (e)=>{\n                let touch = [\n                    ...e.changedTouches\n                ].findIndex(({ identifier: identifier })=>identifier === state.current.id);\n                if (touch >= 0) {\n                    end(e, \"touch\");\n                    state.current.id = null;\n                    removeGlobalListener(window, \"touchmove\", onTouchMove);\n                    removeGlobalListener(window, \"touchend\", onTouchEnd);\n                    removeGlobalListener(window, \"touchcancel\", onTouchEnd);\n                }\n            };\n            moveProps.onTouchStart = (e)=>{\n                if (e.changedTouches.length === 0 || state.current.id != null) return;\n                let { pageX: pageX, pageY: pageY, identifier: identifier } = e.changedTouches[0];\n                start();\n                e.stopPropagation();\n                e.preventDefault();\n                state.current.lastPosition = {\n                    pageX: pageX,\n                    pageY: pageY\n                };\n                state.current.id = identifier;\n                addGlobalListener(window, \"touchmove\", onTouchMove, false);\n                addGlobalListener(window, \"touchend\", onTouchEnd, false);\n                addGlobalListener(window, \"touchcancel\", onTouchEnd, false);\n            };\n        } else {\n            let onPointerMove = (e)=>{\n                if (e.pointerId === state.current.id) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    let pointerType = e.pointerType || \"mouse\";\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    // Problems with PointerEvent#movementX/movementY:\n                    // 1. it is always 0 on macOS Safari.\n                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS\n                    move(e, pointerType, e.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                }\n            };\n            let onPointerUp = (e)=>{\n                if (e.pointerId === state.current.id) {\n                    let pointerType = e.pointerType || \"mouse\";\n                    end(e, pointerType);\n                    state.current.id = null;\n                    removeGlobalListener(window, \"pointermove\", onPointerMove, false);\n                    removeGlobalListener(window, \"pointerup\", onPointerUp, false);\n                    removeGlobalListener(window, \"pointercancel\", onPointerUp, false);\n                }\n            };\n            moveProps.onPointerDown = (e)=>{\n                if (e.button === 0 && state.current.id == null) {\n                    start();\n                    e.stopPropagation();\n                    e.preventDefault();\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                    state.current.id = e.pointerId;\n                    addGlobalListener(window, \"pointermove\", onPointerMove, false);\n                    addGlobalListener(window, \"pointerup\", onPointerUp, false);\n                    addGlobalListener(window, \"pointercancel\", onPointerUp, false);\n                }\n            };\n        }\n        let triggerKeyboardMove = (e, deltaX, deltaY)=>{\n            start();\n            move(e, \"keyboard\", deltaX, deltaY);\n            end(e, \"keyboard\");\n        };\n        moveProps.onKeyDown = (e)=>{\n            switch(e.key){\n                case \"Left\":\n                case \"ArrowLeft\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, -1, 0);\n                    break;\n                case \"Right\":\n                case \"ArrowRight\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 1, 0);\n                    break;\n                case \"Up\":\n                case \"ArrowUp\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 0, -1);\n                    break;\n                case \"Down\":\n                case \"ArrowDown\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 0, 1);\n                    break;\n            }\n        };\n        return moveProps;\n    }, [\n        state,\n        addGlobalListener,\n        removeGlobalListener,\n        move,\n        end\n    ]);\n    return {\n        moveProps: moveProps\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $7d0a636d7a4dcefd$export$2123ff2b87c81ca(props, ref) {\n    let { onScroll: onScroll, isDisabled: isDisabled } = props;\n    let onScrollHandler = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // If the ctrlKey is pressed, this is a zoom event, do nothing.\n        if (e.ctrlKey) return;\n        // stop scrolling the page\n        e.preventDefault();\n        e.stopPropagation();\n        if (onScroll) onScroll({\n            deltaX: e.deltaX,\n            deltaY: e.deltaY\n        });\n    }, [\n        onScroll\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEvent)(ref, \"wheel\", isDisabled ? undefined : onScrollHandler);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $8a26561d2877236e$var$DEFAULT_THRESHOLD = 500;\nfunction $8a26561d2877236e$export$c24ed0104d07eab9(props) {\n    let { isDisabled: isDisabled, onLongPressStart: onLongPressStart, onLongPressEnd: onLongPressEnd, onLongPress: onLongPress, threshold: threshold = $8a26561d2877236e$var$DEFAULT_THRESHOLD, accessibilityDescription: accessibilityDescription } = props;\n    const timeRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let { addGlobalListener: addGlobalListener, removeGlobalListener: removeGlobalListener } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let { pressProps: pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({\n        isDisabled: isDisabled,\n        onPressStart (e) {\n            e.continuePropagation();\n            if (e.pointerType === \"mouse\" || e.pointerType === \"touch\") {\n                if (onLongPressStart) onLongPressStart({\n                    ...e,\n                    type: \"longpressstart\"\n                });\n                timeRef.current = setTimeout(()=>{\n                    // Prevent other usePress handlers from also handling this event.\n                    e.target.dispatchEvent(new PointerEvent(\"pointercancel\", {\n                        bubbles: true\n                    }));\n                    if (onLongPress) onLongPress({\n                        ...e,\n                        type: \"longpress\"\n                    });\n                    timeRef.current = undefined;\n                }, threshold);\n                // Prevent context menu, which may be opened on long press on touch devices\n                if (e.pointerType === \"touch\") {\n                    let onContextMenu = (e)=>{\n                        e.preventDefault();\n                    };\n                    addGlobalListener(e.target, \"contextmenu\", onContextMenu, {\n                        once: true\n                    });\n                    addGlobalListener(window, \"pointerup\", ()=>{\n                        // If no contextmenu event is fired quickly after pointerup, remove the handler\n                        // so future context menu events outside a long press are not prevented.\n                        setTimeout(()=>{\n                            removeGlobalListener(e.target, \"contextmenu\", onContextMenu);\n                        }, 30);\n                    }, {\n                        once: true\n                    });\n                }\n            }\n        },\n        onPressEnd (e) {\n            if (timeRef.current) clearTimeout(timeRef.current);\n            if (onLongPressEnd && (e.pointerType === \"mouse\" || e.pointerType === \"touch\")) onLongPressEnd({\n                ...e,\n                type: \"longpressend\"\n            });\n        }\n    });\n    let descriptionProps = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : undefined);\n    return {\n        longPressProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(pressProps, descriptionProps)\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNHJCO0FBQ3JlO0FBQ2pKO0FBQ0U7QUFDRDtBQUNYO0FBRTVEOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0Q7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLGtFQUFrRTtBQUN0RSwyREFBMkQ7QUFDM0QseURBQXlEO0FBQ3pELGtIQUFrSDtBQUlsSDs7Ozs7Ozs7OztDQVVDLEdBQ0QsMEdBQTBHO0FBQzFHLDRIQUE0SDtBQUM1SCxJQUFJcUQsOEJBQThCO0FBQ2xDLElBQUlDLHdDQUF3QztBQUM1QyxJQUFJQywyQ0FBMkMsSUFBSUM7QUFDbkQsU0FBU0MsMENBQTBDQyxNQUFNO0lBQ3JELElBQUksQ0FBQyxHQUFHakMsb0RBQVcsS0FBTTtRQUNyQixJQUFJNEIsZ0NBQWdDLFdBQVc7WUFDM0MsaURBQWlEO1lBQ2pELE1BQU1NLGlCQUFpQixDQUFDLEdBQUdoRCwrREFBc0IsRUFBRytDO1lBQ3BESix3Q0FBd0NLLGVBQWVDLGVBQWUsQ0FBQ0MsS0FBSyxDQUFDQyxnQkFBZ0I7WUFDN0ZILGVBQWVDLGVBQWUsQ0FBQ0MsS0FBSyxDQUFDQyxnQkFBZ0IsR0FBRztRQUM1RDtRQUNBVCw4QkFBOEI7SUFDbEMsT0FBTyxJQUFJSyxrQkFBa0JLLGVBQWVMLGtCQUFrQk0sWUFBWTtRQUN0RSxzRkFBc0Y7UUFDdEYsa0RBQWtEO1FBQ2xEVCx5Q0FBeUNVLEdBQUcsQ0FBQ1AsUUFBUUEsT0FBT0csS0FBSyxDQUFDSyxVQUFVO1FBQzVFUixPQUFPRyxLQUFLLENBQUNLLFVBQVUsR0FBRztJQUM5QjtBQUNKO0FBQ0EsU0FBU0MsMENBQTBDVCxNQUFNO0lBQ3JELElBQUksQ0FBQyxHQUFHakMsb0RBQVcsS0FBTTtRQUNyQiwwREFBMEQ7UUFDMUQsc0VBQXNFO1FBQ3RFLElBQUk0Qixn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LHFCQUFxQnRPLEVBQUV6RSxNQUFNLEVBQUUsZUFBZXlVO3dCQUNsRCxHQUFHO29CQUNQLEdBQUc7d0JBQ0NoSSxNQUFNO29CQUNWO2dCQUNKO1lBQ0o7UUFDSjtRQUNBMUosWUFBWTBCLENBQUM7WUFDVCxJQUFJK1AsUUFBUXJRLE9BQU8sRUFBRXVRLGFBQWFGLFFBQVFyUSxPQUFPO1lBQ2pELElBQUlpUSxrQkFBbUIzUCxDQUFBQSxFQUFFekMsV0FBVyxLQUFLLFdBQVd5QyxFQUFFekMsV0FBVyxLQUFLLE9BQU0sR0FBSW9TLGVBQWU7Z0JBQzNGLEdBQUczUCxDQUFDO2dCQUNKMUMsTUFBTTtZQUNWO1FBQ0o7SUFDSjtJQUNBLElBQUk0UyxtQkFBbUIsQ0FBQyxHQUFHcFcsNkRBQW9CLEVBQUc4VixlQUFlLENBQUNwUixhQUFhc1IsMkJBQTJCbE87SUFDMUcsT0FBTztRQUNIdU8sZ0JBQWdCLENBQUMsR0FBR25ZLHlEQUFnQixFQUFHbUksWUFBWStQO0lBQ3ZEO0FBQ0o7QUFLeWxDLENBQ3psQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXJ6b25lLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ludGVyYWN0aW9ucy9kaXN0L2ltcG9ydC5tanM/NTM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU9iamVjdFJlZiBhcyAkYng3U0wkdXNlT2JqZWN0UmVmLCBtZXJnZVByb3BzIGFzICRieDdTTCRtZXJnZVByb3BzLCB1c2VTeW5jUmVmIGFzICRieDdTTCR1c2VTeW5jUmVmLCB1c2VHbG9iYWxMaXN0ZW5lcnMgYXMgJGJ4N1NMJHVzZUdsb2JhbExpc3RlbmVycywgdXNlRWZmZWN0RXZlbnQgYXMgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50LCBnZXRPd25lckRvY3VtZW50IGFzICRieDdTTCRnZXRPd25lckRvY3VtZW50LCBpc01hYyBhcyAkYng3U0wkaXNNYWMsIG9wZW5MaW5rIGFzICRieDdTTCRvcGVuTGluaywgaXNWaXJ0dWFsQ2xpY2sgYXMgJGJ4N1NMJGlzVmlydHVhbENsaWNrLCBmb2N1c1dpdGhvdXRTY3JvbGxpbmcgYXMgJGJ4N1NMJGZvY3VzV2l0aG91dFNjcm9sbGluZywgaXNWaXJ0dWFsUG9pbnRlckV2ZW50IGFzICRieDdTTCRpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIGdldE93bmVyV2luZG93IGFzICRieDdTTCRnZXRPd25lcldpbmRvdywgaXNJT1MgYXMgJGJ4N1NMJGlzSU9TLCBydW5BZnRlclRyYW5zaXRpb24gYXMgJGJ4N1NMJHJ1bkFmdGVyVHJhbnNpdGlvbiwgdXNlTGF5b3V0RWZmZWN0IGFzICRieDdTTCR1c2VMYXlvdXRFZmZlY3QsIHVzZUV2ZW50IGFzICRieDdTTCR1c2VFdmVudCwgdXNlRGVzY3JpcHRpb24gYXMgJGJ4N1NMJHVzZURlc2NyaXB0aW9ufSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcbmltcG9ydCAkYng3U0wkcmVhY3QsIHt1c2VDb250ZXh0IGFzICRieDdTTCR1c2VDb250ZXh0LCB1c2VTdGF0ZSBhcyAkYng3U0wkdXNlU3RhdGUsIHVzZVJlZiBhcyAkYng3U0wkdXNlUmVmLCB1c2VNZW1vIGFzICRieDdTTCR1c2VNZW1vLCB1c2VFZmZlY3QgYXMgJGJ4N1NMJHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgYXMgJGJ4N1NMJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XyBhcyAkYng3U0wkX30gZnJvbSBcIkBzd2MvaGVscGVycy9fL19jbGFzc19wcml2YXRlX2ZpZWxkX2dldFwiO1xuaW1wb3J0IHtfIGFzICRieDdTTCRfMX0gZnJvbSBcIkBzd2MvaGVscGVycy9fL19jbGFzc19wcml2YXRlX2ZpZWxkX2luaXRcIjtcbmltcG9ydCB7XyBhcyAkYng3U0wkXzJ9IGZyb20gXCJAc3djL2hlbHBlcnMvXy9fY2xhc3NfcHJpdmF0ZV9maWVsZF9zZXRcIjtcbmltcG9ydCB7dXNlSXNTU1IgYXMgJGJ4N1NMJHVzZUlzU1NSfSBmcm9tIFwiQHJlYWN0LWFyaWEvc3NyXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8vIE5vdGUgdGhhdCBzdGF0ZSBvbmx5IG1hdHRlcnMgaGVyZSBmb3IgaU9TLiBOb24taU9TIGdldHMgdXNlci1zZWxlY3Q6IG5vbmUgYXBwbGllZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbi8vIHJhdGhlciB0aGFuIGF0IHRoZSBkb2N1bWVudCBsZXZlbCBzbyB3ZSBqdXN0IG5lZWQgdG8gYXBwbHkvcmVtb3ZlIHVzZXItc2VsZWN0OiBub25lIGZvciBlYWNoIHByZXNzZWQgZWxlbWVudCBpbmRpdmlkdWFsbHlcbmxldCAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPSBcImRlZmF1bHRcIjtcbmxldCAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc2F2ZWRVc2VyU2VsZWN0ID0gXCJcIjtcbmxldCAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkbW9kaWZpZWRFbGVtZW50TWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCQxNmE0Njk3NDY3MTc1NDg3KHRhcmdldCkge1xuICAgIGlmICgoMCwgJGJ4N1NMJGlzSU9TKSgpKSB7XG4gICAgICAgIGlmICgkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudE9iamVjdCA9ICgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkodGFyZ2V0KTtcbiAgICAgICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzYXZlZFVzZXJTZWxlY3QgPSBkb2N1bWVudE9iamVjdC5kb2N1bWVudEVsZW1lbnQuc3R5bGUud2Via2l0VXNlclNlbGVjdDtcbiAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LmRvY3VtZW50RWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgJDE0YzBiNzI1MDlkNzAyMjUkdmFyJHN0YXRlID0gXCJkaXNhYmxlZFwiO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAvLyBJZiBub3QgaU9TLCBzdG9yZSB0aGUgdGFyZ2V0J3Mgb3JpZ2luYWwgdXNlci1zZWxlY3QgYW5kIGNoYW5nZSB0byB1c2VyLXNlbGVjdDogbm9uZVxuICAgICAgICAvLyBJZ25vcmUgc3RhdGUgc2luY2UgaXQgZG9lc24ndCBhcHBseSBmb3Igbm9uIGlPU1xuICAgICAgICAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkbW9kaWZpZWRFbGVtZW50TWFwLnNldCh0YXJnZXQsIHRhcmdldC5zdHlsZS51c2VyU2VsZWN0KTtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgICB9XG59XG5mdW5jdGlvbiAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkYjBkNmZhMWFiMzJlMzI5NSh0YXJnZXQpIHtcbiAgICBpZiAoKDAsICRieDdTTCRpc0lPUykoKSkge1xuICAgICAgICAvLyBJZiB0aGUgc3RhdGUgaXMgYWxyZWFkeSBkZWZhdWx0LCB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgIC8vIElmIGl0IGlzIHJlc3RvcmluZywgdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gcXVldWUgYSBzZWNvbmQgcmVzdG9yZS5cbiAgICAgICAgaWYgKCQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSAhPT0gXCJkaXNhYmxlZFwiKSByZXR1cm47XG4gICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSA9IFwicmVzdG9yaW5nXCI7XG4gICAgICAgIC8vIFRoZXJlIGFwcGVhcnMgdG8gYmUgYSBkZWxheSBvbiBpT1Mgd2hlcmUgc2VsZWN0aW9uIHN0aWxsIG1pZ2h0IG9jY3VyXG4gICAgICAgIC8vIGFmdGVyIHBvaW50ZXIgdXAsIHNvIHdhaXQgYSBiaXQgYmVmb3JlIHJlbW92aW5nIHVzZXItc2VsZWN0LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAvLyBXYWl0IGZvciBhbnkgQ1NTIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlIHNvIHdlIGRvbid0IHJlY29tcHV0ZSBzdHlsZVxuICAgICAgICAgICAgLy8gZm9yIHRoZSB3aG9sZSBwYWdlIGluIHRoZSBtaWRkbGUgb2YgdGhlIGFuaW1hdGlvbiBhbmQgY2F1c2UgamFuay5cbiAgICAgICAgICAgICgwLCAkYng3U0wkcnVuQWZ0ZXJUcmFuc2l0aW9uKSgoKT0+e1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIGlmICgkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPT09IFwicmVzdG9yaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudE9iamVjdCA9ICgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50T2JqZWN0LmRvY3VtZW50RWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID09PSBcIm5vbmVcIikgZG9jdW1lbnRPYmplY3QuZG9jdW1lbnRFbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc2F2ZWRVc2VyU2VsZWN0IHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzYXZlZFVzZXJTZWxlY3QgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPSBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIC8vIElmIG5vdCBpT1MsIHJlc3RvcmUgdGhlIHRhcmdldCdzIG9yaWdpbmFsIHVzZXItc2VsZWN0IGlmIGFueVxuICAgIC8vIElnbm9yZSBzdGF0ZSBzaW5jZSBpdCBkb2Vzbid0IGFwcGx5IGZvciBub24gaU9TXG4gICAge1xuICAgICAgICBpZiAodGFyZ2V0ICYmICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRtb2RpZmllZEVsZW1lbnRNYXAuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRPbGRVc2VyU2VsZWN0ID0gJDE0YzBiNzI1MDlkNzAyMjUkdmFyJG1vZGlmaWVkRWxlbWVudE1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuc3R5bGUudXNlclNlbGVjdCA9PT0gXCJub25lXCIgJiYgdGFyZ2V0T2xkVXNlclNlbGVjdCkgdGFyZ2V0LnN0eWxlLnVzZXJTZWxlY3QgPSB0YXJnZXRPbGRVc2VyU2VsZWN0O1xuICAgICAgICAgICAgaWYgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSA9PT0gXCJcIikgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICAgICAgJDE0YzBiNzI1MDlkNzAyMjUkdmFyJG1vZGlmaWVkRWxlbWVudE1hcC5kZWxldGUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNvbnN0ICRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1ID0gKDAsICRieDdTTCRyZWFjdCkuY3JlYXRlQ29udGV4dCh7XG4gICAgcmVnaXN0ZXI6ICgpPT57fVxufSk7XG4kYWUxZWViYThiOWVhZmQwOCRleHBvcnQkNTE2NWVjY2IzNWFhYWRiNS5kaXNwbGF5TmFtZSA9IFwiUHJlc3NSZXNwb25kZXJDb250ZXh0XCI7XG5cblxuXG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkdXNlUHJlc3NSZXNwb25kZXJDb250ZXh0KHByb3BzKSB7XG4gICAgLy8gQ29uc3VtZSBjb250ZXh0IGZyb20gPFByZXNzUmVzcG9uZGVyPiBhbmQgbWVyZ2Ugd2l0aCBwcm9wcy5cbiAgICBsZXQgY29udGV4dCA9ICgwLCAkYng3U0wkdXNlQ29udGV4dCkoKDAsICRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1KSk7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHsgcmVnaXN0ZXI6IHJlZ2lzdGVyLCAuLi5jb250ZXh0UHJvcHMgfSA9IGNvbnRleHQ7XG4gICAgICAgIHByb3BzID0gKDAsICRieDdTTCRtZXJnZVByb3BzKShjb250ZXh0UHJvcHMsIHByb3BzKTtcbiAgICAgICAgcmVnaXN0ZXIoKTtcbiAgICB9XG4gICAgKDAsICRieDdTTCR1c2VTeW5jUmVmKShjb250ZXh0LCBwcm9wcy5yZWYpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbnZhciAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkX3Nob3VsZFN0b3BQcm9wYWdhdGlvbiA9IC8qI19fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzICRmNmMzMWNjZTJhZGY2NTRmJHZhciRQcmVzc0V2ZW50IHtcbiAgICBjb250aW51ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICAoMCwgJGJ4N1NMJF8yKSh0aGlzLCAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkX3Nob3VsZFN0b3BQcm9wYWdhdGlvbiwgZmFsc2UpO1xuICAgIH1cbiAgICBnZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gKDAsICRieDdTTCRfKSh0aGlzLCAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkX3Nob3VsZFN0b3BQcm9wYWdhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBvaW50ZXJUeXBlLCBvcmlnaW5hbEV2ZW50KXtcbiAgICAgICAgKDAsICRieDdTTCRfMSkodGhpcywgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJF9zaG91bGRTdG9wUHJvcGFnYXRpb24sIHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgKDAsICRieDdTTCRfMikodGhpcywgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJF9zaG91bGRTdG9wUHJvcGFnYXRpb24sIHRydWUpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gb3JpZ2luYWxFdmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gb3JpZ2luYWxFdmVudC5zaGlmdEtleTtcbiAgICAgICAgdGhpcy5tZXRhS2V5ID0gb3JpZ2luYWxFdmVudC5tZXRhS2V5O1xuICAgICAgICB0aGlzLmN0cmxLZXkgPSBvcmlnaW5hbEV2ZW50LmN0cmxLZXk7XG4gICAgICAgIHRoaXMuYWx0S2V5ID0gb3JpZ2luYWxFdmVudC5hbHRLZXk7XG4gICAgfVxufVxuY29uc3QgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJExJTktfQ0xJQ0tFRCA9IFN5bWJvbChcImxpbmtDbGlja2VkXCIpO1xuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkZXhwb3J0JDQ1NzEyZWNlZGE2ZmFkMjEocHJvcHMpIHtcbiAgICBsZXQgeyBvblByZXNzOiBvblByZXNzLCBvblByZXNzQ2hhbmdlOiBvblByZXNzQ2hhbmdlLCBvblByZXNzU3RhcnQ6IG9uUHJlc3NTdGFydCwgb25QcmVzc0VuZDogb25QcmVzc0VuZCwgb25QcmVzc1VwOiBvblByZXNzVXAsIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsIGlzUHJlc3NlZDogaXNQcmVzc2VkUHJvcCwgcHJldmVudEZvY3VzT25QcmVzczogcHJldmVudEZvY3VzT25QcmVzcywgc2hvdWxkQ2FuY2VsT25Qb2ludGVyRXhpdDogc2hvdWxkQ2FuY2VsT25Qb2ludGVyRXhpdCwgYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzczogYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcywgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHJlZjogXywgLi4uZG9tUHJvcHMgfSA9ICRmNmMzMWNjZTJhZGY2NTRmJHZhciR1c2VQcmVzc1Jlc3BvbmRlckNvbnRleHQocHJvcHMpO1xuICAgIGxldCBbaXNQcmVzc2VkLCBzZXRQcmVzc2VkXSA9ICgwLCAkYng3U0wkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgcmVmID0gKDAsICRieDdTTCR1c2VSZWYpKHtcbiAgICAgICAgaXNQcmVzc2VkOiBmYWxzZSxcbiAgICAgICAgaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50czogZmFsc2UsXG4gICAgICAgIGlnbm9yZUNsaWNrQWZ0ZXJQcmVzczogZmFsc2UsXG4gICAgICAgIGRpZEZpcmVQcmVzc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgaXNUcmlnZ2VyaW5nRXZlbnQ6IGZhbHNlLFxuICAgICAgICBhY3RpdmVQb2ludGVySWQ6IG51bGwsXG4gICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgaXNPdmVyVGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgcG9pbnRlclR5cGU6IG51bGxcbiAgICB9KTtcbiAgICBsZXQgeyBhZGRHbG9iYWxMaXN0ZW5lcjogYWRkR2xvYmFsTGlzdGVuZXIsIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyczogcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzIH0gPSAoMCwgJGJ4N1NMJHVzZUdsb2JhbExpc3RlbmVycykoKTtcbiAgICBsZXQgdHJpZ2dlclByZXNzU3RhcnQgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgob3JpZ2luYWxFdmVudCwgcG9pbnRlclR5cGUpPT57XG4gICAgICAgIGxldCBzdGF0ZSA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCB8fCBzdGF0ZS5kaWRGaXJlUHJlc3NTdGFydCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgPSB0cnVlO1xuICAgICAgICBpZiAob25QcmVzc1N0YXJ0KSB7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJFByZXNzRXZlbnQoXCJwcmVzc3N0YXJ0XCIsIHBvaW50ZXJUeXBlLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIG9uUHJlc3NTdGFydChldmVudCk7XG4gICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSBldmVudC5zaG91bGRTdG9wUHJvcGFnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUHJlc3NDaGFuZ2UpIG9uUHJlc3NDaGFuZ2UodHJ1ZSk7XG4gICAgICAgIHN0YXRlLmlzVHJpZ2dlcmluZ0V2ZW50ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmRpZEZpcmVQcmVzc1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2V0UHJlc3NlZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHNob3VsZFN0b3BQcm9wYWdhdGlvbjtcbiAgICB9KTtcbiAgICBsZXQgdHJpZ2dlclByZXNzRW5kID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKG9yaWdpbmFsRXZlbnQsIHBvaW50ZXJUeXBlLCB3YXNQcmVzc2VkID0gdHJ1ZSk9PntcbiAgICAgICAgbGV0IHN0YXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghc3RhdGUuZGlkRmlyZVByZXNzU3RhcnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RhdGUuaWdub3JlQ2xpY2tBZnRlclByZXNzID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuZGlkRmlyZVByZXNzU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgPSB0cnVlO1xuICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9uUHJlc3NFbmQpIHtcbiAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkUHJlc3NFdmVudChcInByZXNzZW5kXCIsIHBvaW50ZXJUeXBlLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIG9uUHJlc3NFbmQoZXZlbnQpO1xuICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gZXZlbnQuc2hvdWxkU3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblByZXNzQ2hhbmdlKSBvblByZXNzQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgICAgIGlmIChvblByZXNzICYmIHdhc1ByZXNzZWQgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkUHJlc3NFdmVudChcInByZXNzXCIsIHBvaW50ZXJUeXBlLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIG9uUHJlc3MoZXZlbnQpO1xuICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uICYmIChzaG91bGRTdG9wUHJvcGFnYXRpb24gPSBldmVudC5zaG91bGRTdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmlzVHJpZ2dlcmluZ0V2ZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzaG91bGRTdG9wUHJvcGFnYXRpb247XG4gICAgfSk7XG4gICAgbGV0IHRyaWdnZXJQcmVzc1VwID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKG9yaWdpbmFsRXZlbnQsIHBvaW50ZXJUeXBlKT0+e1xuICAgICAgICBsZXQgc3RhdGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG9uUHJlc3NVcCkge1xuICAgICAgICAgICAgc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRQcmVzc0V2ZW50KFwicHJlc3N1cFwiLCBwb2ludGVyVHlwZSwgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICBvblByZXNzVXAoZXZlbnQpO1xuICAgICAgICAgICAgc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5zaG91bGRTdG9wUHJvcGFnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgbGV0IGNhbmNlbCA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChlKT0+e1xuICAgICAgICBsZXQgc3RhdGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHN0YXRlLmlzUHJlc3NlZCAmJiBzdGF0ZS50YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkgdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5wb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmICghYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcykgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1KShzdGF0ZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGNhbmNlbE9uUG9pbnRlckV4aXQgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgoZSk9PntcbiAgICAgICAgaWYgKHNob3VsZENhbmNlbE9uUG9pbnRlckV4aXQpIGNhbmNlbChlKTtcbiAgICB9KTtcbiAgICBsZXQgcHJlc3NQcm9wcyA9ICgwLCAkYng3U0wkdXNlTWVtbykoKCk9PntcbiAgICAgICAgbGV0IHN0YXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGxldCBwcmVzc1Byb3BzID0ge1xuICAgICAgICAgICAgb25LZXlEb3duIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkS2V5Ym9hcmRFdmVudChlLm5hdGl2ZUV2ZW50LCBlLmN1cnJlbnRUYXJnZXQpICYmIGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9tZXRhS2V5RXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0S2V5Ym9hcmQoZS50YXJnZXQsIGUua2V5KSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwZWF0aW5nLCBpdCBtYXkgaGF2ZSBzdGFydGVkIG9uIGEgZGlmZmVyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgd2hpY2ggZm9jdXMgbW92ZWQgdG8gdGhlIGN1cnJlbnQgZWxlbWVudC4gSWdub3JlIHRoZXNlIGV2ZW50cyBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBoYW5kbGUgdGhlIGZpcnN0IGtleSBkb3duIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc1ByZXNzZWQgJiYgIWUucmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzU3RhcnQoZSwgXCJrZXlib2FyZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvY3VzIG1heSBtb3ZlIGJlZm9yZSB0aGUga2V5IHVwIGV2ZW50LCBzbyByZWdpc3RlciB0aGUgZXZlbnQgb24gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBzYW1lIGVsZW1lbnQgd2hlcmUgdGhlIGtleSBkb3duIGV2ZW50IG9jY3VycmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIoKDAsICRieDdTTCRnZXRPd25lckRvY3VtZW50KShlLmN1cnJlbnRUYXJnZXQpLCBcImtleXVwXCIsIG9uS2V5VXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBrZXlkb3duIGV2ZW50cyB0aGF0IG9jY3VyIHdoaWxlIHRoZSBNZXRhIChlLmcuIENvbW1hbmQpIGtleSBpcyBoZWxkLlxuICAgICAgICAgICAgICAgICAgICAvLyBtYWNPUyBoYXMgYSBidWcgd2hlcmUga2V5dXAgZXZlbnRzIGFyZSBub3QgZmlyZWQgd2hpbGUgdGhlIE1ldGEga2V5IGlzIGRvd24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIE1ldGEga2V5IGl0c2VsZiBpcyByZWxlYXNlZCB3ZSB3aWxsIGdldCBhbiBldmVudCBmb3IgdGhhdCwgYW5kIHdlJ2xsIGFjdCBhcyBpZlxuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgb2YgdGhlc2Ugb3RoZXIga2V5cyB3ZXJlIHJlbGVhc2VkIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEzOTM1MjRcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTU1MjkxXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyOTk1NTNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubWV0YUtleSAmJiAoMCwgJGJ4N1NMJGlzTWFjKSgpKSAoX3N0YXRlX21ldGFLZXlFdmVudHMgPSBzdGF0ZS5tZXRhS2V5RXZlbnRzKSA9PT0gbnVsbCB8fCBfc3RhdGVfbWV0YUtleUV2ZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX21ldGFLZXlFdmVudHMuc2V0KGUua2V5LCBlLm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcIk1ldGFcIikgc3RhdGUubWV0YUtleUV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbktleVVwIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkS2V5Ym9hcmRFdmVudChlLm5hdGl2ZUV2ZW50LCBlLmN1cnJlbnRUYXJnZXQpICYmICFlLnJlcGVhdCAmJiBlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpICYmIHN0YXRlLnRhcmdldCkgdHJpZ2dlclByZXNzVXAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIFwia2V5Ym9hcmRcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbGljayAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlICYmICFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGUgJiYgZS5idXR0b24gPT09IDAgJiYgIXN0YXRlLmlzVHJpZ2dlcmluZ0V2ZW50ICYmICEoMCwgJGJ4N1NMJG9wZW5MaW5rKS5pc09wZW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRyaWdnZXJlZCBmcm9tIGEgc2NyZWVuIHJlYWRlciBvciBieSB1c2luZyBlbGVtZW50LmNsaWNrKCksXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgYXMgaWYgaXQgd2VyZSBhIGtleWJvYXJkIGNsaWNrLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlnbm9yZUNsaWNrQWZ0ZXJQcmVzcyAmJiAhc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyAmJiAhc3RhdGUuaXNQcmVzc2VkICYmIChzdGF0ZS5wb2ludGVyVHlwZSA9PT0gXCJ2aXJ0dWFsXCIgfHwgKDAsICRieDdTTCRpc1ZpcnR1YWxDbGljaykoZS5uYXRpdmVFdmVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGVsZW1lbnQgcmVjZWl2ZXMgZm9jdXMgKFZvaWNlT3ZlciBvbiBpT1MgZG9lcyBub3QgZG8gdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNEaXNhYmxlZCAmJiAhcHJldmVudEZvY3VzT25QcmVzcykgKDAsICRieDdTTCRmb2N1c1dpdGhvdXRTY3JvbGxpbmcpKGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcFByZXNzU3RhcnQgPSB0cmlnZ2VyUHJlc3NTdGFydChlLCBcInZpcnR1YWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcFByZXNzVXAgPSB0cmlnZ2VyUHJlc3NVcChlLCBcInZpcnR1YWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcFByZXNzRW5kID0gdHJpZ2dlclByZXNzRW5kKGUsIFwidmlydHVhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHN0b3BQcmVzc1N0YXJ0ICYmIHN0b3BQcmVzc1VwICYmIHN0b3BQcmVzc0VuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlnbm9yZUNsaWNrQWZ0ZXJQcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG9uS2V5VXAgPSAoZSk9PntcbiAgICAgICAgICAgIHZhciBfc3RhdGVfbWV0YUtleUV2ZW50cztcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1ByZXNzZWQgJiYgc3RhdGUudGFyZ2V0ICYmICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkS2V5Ym9hcmRFdmVudChlLCBzdGF0ZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9tZXRhS2V5RXZlbnRzMTtcbiAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0S2V5Ym9hcmQoZS50YXJnZXQsIGUua2V5KSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBcImtleWJvYXJkXCIsIHN0YXRlLnRhcmdldC5jb250YWlucyh0YXJnZXQpKTtcbiAgICAgICAgICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbGluayB3YXMgdHJpZ2dlcmVkIHdpdGggYSBrZXkgb3RoZXIgdGhhbiBFbnRlciwgb3BlbiB0aGUgVVJMIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsaW5rIGhhcyBhIHJvbGUgb3ZlcnJpZGUsIGFuZCB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgLy8gb25seSBhcHBsaWVzIHdoZW4gdXNpbmcgdGhlIEVudGVyIGtleS5cbiAgICAgICAgICAgICAgICBpZiAoZS5rZXkgIT09IFwiRW50ZXJcIiAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNIVE1MQW5jaG9yTGluayhzdGF0ZS50YXJnZXQpICYmIHN0YXRlLnRhcmdldC5jb250YWlucyh0YXJnZXQpICYmICFlWyRmNmMzMWNjZTJhZGY2NTRmJHZhciRMSU5LX0NMSUNLRURdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGEgaGlkZGVuIHByb3BlcnR5IG9uIHRoZSBldmVudCBzbyB3ZSBvbmx5IHRyaWdnZXIgbGluayBjbGljayBvbmNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB1c2VQcmVzcyBpbnN0YW5jZXMgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGVbJGY2YzMxY2NlMmFkZjY1NGYkdmFyJExJTktfQ0xJQ0tFRF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAoMCwgJGJ4N1NMJG9wZW5MaW5rKShzdGF0ZS50YXJnZXQsIGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgKF9zdGF0ZV9tZXRhS2V5RXZlbnRzMSA9IHN0YXRlLm1ldGFLZXlFdmVudHMpID09PSBudWxsIHx8IF9zdGF0ZV9tZXRhS2V5RXZlbnRzMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX21ldGFLZXlFdmVudHMxLmRlbGV0ZShlLmtleSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcIk1ldGFcIiAmJiAoKF9zdGF0ZV9tZXRhS2V5RXZlbnRzID0gc3RhdGUubWV0YUtleUV2ZW50cykgPT09IG51bGwgfHwgX3N0YXRlX21ldGFLZXlFdmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9tZXRhS2V5RXZlbnRzLnNpemUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV90YXJnZXQ7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVjb3JkZWQga2V5ZG93biBldmVudHMgdGhhdCBvY2N1cnJlZCB3aGlsZSB0aGUgTWV0YSBrZXkgd2FzIHByZXNzZWQsXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRob3NlIGhhdmVuJ3QgcmVjZWl2ZWQga2V5dXAgZXZlbnRzIGFscmVhZHksIGZpcmUga2V5dXAgZXZlbnRzIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICAvLyBTZWUgY29tbWVudCBhYm92ZSBmb3IgbW9yZSBpbmZvIGFib3V0IHRoZSBtYWNPUyBidWcgY2F1c2luZyB0aGlzLlxuICAgICAgICAgICAgICAgIGxldCBldmVudHMgPSBzdGF0ZS5tZXRhS2V5RXZlbnRzO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1ldGFLZXlFdmVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgb2YgZXZlbnRzLnZhbHVlcygpKShfc3RhdGVfdGFyZ2V0ID0gc3RhdGUudGFyZ2V0KSA9PT0gbnVsbCB8fCBfc3RhdGVfdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCBldmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vblBvaW50ZXJEb3duID0gKGUpPT57XG4gICAgICAgICAgICAgICAgLy8gT25seSBoYW5kbGUgbGVmdCBjbGlja3MsIGFuZCBpZ25vcmUgZXZlbnRzIHRoYXQgYnViYmxlZCB0aHJvdWdoIHBvcnRhbHMuXG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwIHx8ICFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gaU9TIHNhZmFyaSBmaXJlcyBwb2ludGVyIGV2ZW50cyBmcm9tIFZvaWNlT3ZlciB3aXRoIGluY29ycmVjdCBjb29yZGluYXRlcy90YXJnZXQuXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFuZCBsZXQgdGhlIG9uQ2xpY2sgaGFuZGxlciB0YWtlIGNhcmUgb2YgaXQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjIyNjI3XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIyMzIwMlxuICAgICAgICAgICAgICAgIGlmICgoMCwgJGJ4N1NMJGlzVmlydHVhbFBvaW50ZXJFdmVudCkoZS5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBcInZpcnR1YWxcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEdWUgdG8gYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMsIGVzcGVjaWFsbHkgb24gbW9iaWxlIGJyb3dzZXJzLCB3ZSBwcmV2ZW50XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBvbiBwb2ludGVyIGRvd24gYW5kIGhhbmRsZSBmb2N1c2luZyB0aGUgcHJlc3NhYmxlIGVsZW1lbnQgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkc2hvdWxkUHJldmVudERlZmF1bHQoZS5jdXJyZW50VGFyZ2V0KSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXJUeXBlID0gZS5wb2ludGVyVHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQb2ludGVySWQgPSBlLnBvaW50ZXJJZDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgIXByZXZlbnRGb2N1c09uUHJlc3MpICgwLCAkYng3U0wkZm9jdXNXaXRob3V0U2Nyb2xsaW5nKShlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3MpICgwLCAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkMTZhNDY5NzQ2NzE3NTQ4Nykoc3RhdGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzU3RhcnQoZSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcigoMCwgJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQpKGUuY3VycmVudFRhcmdldCksIFwicG9pbnRlcm1vdmVcIiwgb25Qb2ludGVyTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcigoMCwgJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQpKGUuY3VycmVudFRhcmdldCksIFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKCgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkoZS5jdXJyZW50VGFyZ2V0KSwgXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlckNhbmNlbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Nb3VzZURvd24gPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIGFuZCBGaXJlZm94IG9uIHRvdWNoIFdpbmRvd3MgZGV2aWNlcyByZXF1aXJlIG1vdXNlIGRvd24gZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGNhbmNlbGVkIGluIGFkZGl0aW9uIHRvIHBvaW50ZXIgZXZlbnRzLCBvciBhbiBleHRyYSBhc3luY2hyb25vdXNcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9jdXMgZXZlbnQgd2lsbCBiZSBmaXJlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRzaG91bGRQcmV2ZW50RGVmYXVsdChlLmN1cnJlbnRUYXJnZXQpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Qb2ludGVyVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICAvLyBpT1MgZmlyZXMgcG9pbnRlcnVwIHdpdGggemVybyB3aWR0aCBhbmQgaGVpZ2h0LCBzbyBjaGVjayB0aGUgcG9pbnRlclR5cGUgcmVjb3JkZWQgZHVyaW5nIHBvaW50ZXJkb3duLlxuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSB8fCBzdGF0ZS5wb2ludGVyVHlwZSA9PT0gXCJ2aXJ0dWFsXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGhhbmRsZSBsZWZ0IGNsaWNrc1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBvbiBpT1Mgc29tZXRpbWVzIGZpcmVzIHBvaW50ZXJ1cCBldmVudHMsIGV2ZW5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSB0b3VjaCBpc24ndCBvdmVyIHRoZSB0YXJnZXQsIHNvIGRvdWJsZSBjaGVjay5cbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDAgJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldChlLCBlLmN1cnJlbnRUYXJnZXQpKSB0cmlnZ2VyUHJlc3NVcChlLCBzdGF0ZS5wb2ludGVyVHlwZSB8fCBlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTYWZhcmkgb24gaU9TIDwgMTMuMiBkb2VzIG5vdCBpbXBsZW1lbnQgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBldmVudHMgY29ycmVjdGx5LlxuICAgICAgICAgICAgLy8gVXNlIHBvaW50ZXIgbW92ZSBldmVudHMgaW5zdGVhZCB0byBpbXBsZW1lbnQgb3VyIG93biBoaXQgdGVzdGluZy5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk5ODAzXG4gICAgICAgICAgICBsZXQgb25Qb2ludGVyTW92ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLnBvaW50ZXJJZCAhPT0gc3RhdGUuYWN0aXZlUG9pbnRlcklkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnRhcmdldCAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0KGUsIHN0YXRlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJQcmVzc1N0YXJ0KCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnRhcmdldCAmJiBzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxPblBvaW50ZXJFeGl0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Qb2ludGVyVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5wb2ludGVySWQgPT09IHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCAmJiBzdGF0ZS5pc1ByZXNzZWQgJiYgZS5idXR0b24gPT09IDAgJiYgc3RhdGUudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0KGUsIHN0YXRlLnRhcmdldCkgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkgdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB0cmlnZ2VyUHJlc3NFbmQoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIHN0YXRlLnBvaW50ZXJUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUG9pbnRlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzKSAoMCwgJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JGIwZDZmYTFhYjMyZTMyOTUpKHN0YXRlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvblBvaW50ZXJDYW5jZWwgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBjYW5jZWwoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vbkRyYWdTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBkb2VzIG5vdCBjYWxsIG9uUG9pbnRlckNhbmNlbCB3aGVuIGEgZHJhZyBzdGFydHMsIHdoZXJlYXMgQ2hyb21lIGFuZCBGaXJlZm94IGRvLlxuICAgICAgICAgICAgICAgIGNhbmNlbChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uTW91c2VEb3duID0gKGUpPT57XG4gICAgICAgICAgICAgICAgLy8gT25seSBoYW5kbGUgbGVmdCBjbGlja3NcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gIT09IDAgfHwgIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBEdWUgdG8gYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMsIGVzcGVjaWFsbHkgb24gbW9iaWxlIGJyb3dzZXJzLCB3ZSBwcmV2ZW50XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBvbiBtb3VzZSBkb3duIGFuZCBoYW5kbGUgZm9jdXNpbmcgdGhlIHByZXNzYWJsZSBlbGVtZW50IG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0KGUuY3VycmVudFRhcmdldCkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSAoMCwgJGJ4N1NMJGlzVmlydHVhbENsaWNrKShlLm5hdGl2ZUV2ZW50KSA/IFwidmlydHVhbFwiIDogXCJtb3VzZVwiO1xuICAgICAgICAgICAgICAgIGlmICghaXNEaXNhYmxlZCAmJiAhcHJldmVudEZvY3VzT25QcmVzcykgKDAsICRieDdTTCRmb2N1c1dpdGhvdXRTY3JvbGxpbmcpKGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc1N0YXJ0KGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKCgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkoZS5jdXJyZW50VGFyZ2V0KSwgXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Nb3VzZUVudGVyID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzUHJlc3NlZCAmJiAhc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc1N0YXJ0KGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uTW91c2VMZWF2ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc1ByZXNzZWQgJiYgIXN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzRW5kKGUsIHN0YXRlLnBvaW50ZXJUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbE9uUG9pbnRlckV4aXQoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vbk1vdXNlVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgZS5idXR0b24gPT09IDApIHRyaWdnZXJQcmVzc1VwKGUsIHN0YXRlLnBvaW50ZXJUeXBlIHx8IFwibW91c2VcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uTW91c2VVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgaGFuZGxlIGxlZnQgY2xpY2tzXG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS50YXJnZXQgJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldChlLCBzdGF0ZS50YXJnZXQpICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHRyaWdnZXJQcmVzc0VuZCgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQoc3RhdGUudGFyZ2V0LCBlKSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLnRhcmdldCAmJiBzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkgdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Ub3VjaFN0YXJ0ID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoID0gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFRvdWNoRnJvbUV2ZW50KGUubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmICghdG91Y2gpIHJldHVybjtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQb2ludGVySWQgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBcInRvdWNoXCI7XG4gICAgICAgICAgICAgICAgLy8gRHVlIHRvIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzLCBlc3BlY2lhbGx5IG9uIG1vYmlsZSBicm93c2Vycywgd2UgcHJldmVudCBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gb24gdGhlIGVtdWxhdGVkIG1vdXNlIGV2ZW50IGFuZCBoYW5kbGUgZm9jdXNpbmcgdGhlIHByZXNzYWJsZSBlbGVtZW50IG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgIXByZXZlbnRGb2N1c09uUHJlc3MpICgwLCAkYng3U0wkZm9jdXNXaXRob3V0U2Nyb2xsaW5nKShlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcykgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCQxNmE0Njk3NDY3MTc1NDg3KShzdGF0ZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NTdGFydChlLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcigoMCwgJGJ4N1NMJGdldE93bmVyV2luZG93KShlLmN1cnJlbnRUYXJnZXQpLCBcInNjcm9sbFwiLCBvblNjcm9sbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vblRvdWNoTW92ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoID0gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFRvdWNoQnlJZChlLm5hdGl2ZUV2ZW50LCBzdGF0ZS5hY3RpdmVQb2ludGVySWQpO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0b3VjaCAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0KHRvdWNoLCBlLmN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNPdmVyVGFyZ2V0ICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NTdGFydChlLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NFbmQoZSwgc3RhdGUucG9pbnRlclR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsT25Qb2ludGVyRXhpdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uVG91Y2hFbmQgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0b3VjaCA9ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRUb3VjaEJ5SWQoZS5uYXRpdmVFdmVudCwgc3RhdGUuYWN0aXZlUG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG91Y2ggJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldCh0b3VjaCwgZS5jdXJyZW50VGFyZ2V0KSAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJQcmVzc1VwKGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzRW5kKGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NFbmQoZSwgc3RhdGUucG9pbnRlclR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnRhcmdldCAmJiAhYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcykgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1KShzdGF0ZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Ub3VjaENhbmNlbCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzUHJlc3NlZCkgY2FuY2VsKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvblNjcm9sbCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc1ByZXNzZWQgJiYgZS50YXJnZXQuY29udGFpbnMoc3RhdGUudGFyZ2V0KSkgY2FuY2VsKHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogc3RhdGUudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWx0S2V5OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25EcmFnU3RhcnQgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYW5jZWwoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVzc1Byb3BzO1xuICAgIH0sIFtcbiAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIsXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHByZXZlbnRGb2N1c09uUHJlc3MsXG4gICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycyxcbiAgICAgICAgYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcyxcbiAgICAgICAgY2FuY2VsLFxuICAgICAgICBjYW5jZWxPblBvaW50ZXJFeGl0LFxuICAgICAgICB0cmlnZ2VyUHJlc3NFbmQsXG4gICAgICAgIHRyaWdnZXJQcmVzc1N0YXJ0LFxuICAgICAgICB0cmlnZ2VyUHJlc3NVcFxuICAgIF0pO1xuICAgIC8vIFJlbW92ZSB1c2VyLXNlbGVjdDogbm9uZSBpbiBjYXNlIGNvbXBvbmVudCB1bm1vdW50cyBpbW1lZGlhdGVseSBhZnRlciBwcmVzc1N0YXJ0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJGJ4N1NMJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB2YXIgX3JlZl9jdXJyZW50X3RhcmdldDtcbiAgICAgICAgICAgIGlmICghYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcykgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICAgICAgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1KSgoX3JlZl9jdXJyZW50X3RhcmdldCA9IHJlZi5jdXJyZW50LnRhcmdldCkgIT09IG51bGwgJiYgX3JlZl9jdXJyZW50X3RhcmdldCAhPT0gdm9pZCAwID8gX3JlZl9jdXJyZW50X3RhcmdldCA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQcmVzc2VkOiBpc1ByZXNzZWRQcm9wIHx8IGlzUHJlc3NlZCxcbiAgICAgICAgcHJlc3NQcm9wczogKDAsICRieDdTTCRtZXJnZVByb3BzKShkb21Qcm9wcywgcHJlc3NQcm9wcylcbiAgICB9O1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzSFRNTEFuY2hvckxpbmsodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC50YWdOYW1lID09PSBcIkFcIiAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKFwiaHJlZlwiKTtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkS2V5Ym9hcmRFdmVudChldmVudCwgY3VycmVudFRhcmdldCkge1xuICAgIGNvbnN0IHsga2V5OiBrZXksIGNvZGU6IGNvZGUgfSA9IGV2ZW50O1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjdXJyZW50VGFyZ2V0O1xuICAgIGNvbnN0IHJvbGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInJvbGVcIik7XG4gICAgLy8gQWNjZXNzaWJpbGl0eSBmb3Iga2V5Ym9hcmRzLiBTcGFjZSBhbmQgRW50ZXIgb25seS5cbiAgICAvLyBcIlNwYWNlYmFyXCIgaXMgZm9yIElFIDExXG4gICAgcmV0dXJuIChrZXkgPT09IFwiRW50ZXJcIiB8fCBrZXkgPT09IFwiIFwiIHx8IGtleSA9PT0gXCJTcGFjZWJhclwiIHx8IGNvZGUgPT09IFwiU3BhY2VcIikgJiYgIShlbGVtZW50IGluc3RhbmNlb2YgKDAsICRieDdTTCRnZXRPd25lcldpbmRvdykoZWxlbWVudCkuSFRNTElucHV0RWxlbWVudCAmJiAhJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRJbnB1dEtleShlbGVtZW50LCBrZXkpIHx8IGVsZW1lbnQgaW5zdGFuY2VvZiAoMCwgJGJ4N1NMJGdldE93bmVyV2luZG93KShlbGVtZW50KS5IVE1MVGV4dEFyZWFFbGVtZW50IHx8IGVsZW1lbnQuaXNDb250ZW50RWRpdGFibGUpICYmIC8vIExpbmtzIHNob3VsZCBvbmx5IHRyaWdnZXIgd2l0aCBFbnRlciBrZXlcbiAgICAhKChyb2xlID09PSBcImxpbmtcIiB8fCAhcm9sZSAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNIVE1MQW5jaG9yTGluayhlbGVtZW50KSkgJiYga2V5ICE9PSBcIkVudGVyXCIpO1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFRvdWNoRnJvbUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyB0YXJnZXRUb3VjaGVzOiB0YXJnZXRUb3VjaGVzIH0gPSBldmVudDtcbiAgICBpZiAodGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAwKSByZXR1cm4gdGFyZ2V0VG91Y2hlc1swXTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRUb3VjaEJ5SWQoZXZlbnQsIHBvaW50ZXJJZCkge1xuICAgIGNvbnN0IGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgdG91Y2ggPSBjaGFuZ2VkVG91Y2hlc1tpXTtcbiAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHBvaW50ZXJJZCkgcmV0dXJuIHRvdWNoO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudCh0YXJnZXQsIGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50VGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAgICAgICAgYWx0S2V5OiBlLmFsdEtleVxuICAgIH07XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0UG9pbnRDbGllbnRSZWN0KHBvaW50KSB7XG4gICAgbGV0IG9mZnNldFggPSAwO1xuICAgIGxldCBvZmZzZXRZID0gMDtcbiAgICBpZiAocG9pbnQud2lkdGggIT09IHVuZGVmaW5lZCkgb2Zmc2V0WCA9IHBvaW50LndpZHRoIC8gMjtcbiAgICBlbHNlIGlmIChwb2ludC5yYWRpdXNYICE9PSB1bmRlZmluZWQpIG9mZnNldFggPSBwb2ludC5yYWRpdXNYO1xuICAgIGlmIChwb2ludC5oZWlnaHQgIT09IHVuZGVmaW5lZCkgb2Zmc2V0WSA9IHBvaW50LmhlaWdodCAvIDI7XG4gICAgZWxzZSBpZiAocG9pbnQucmFkaXVzWSAhPT0gdW5kZWZpbmVkKSBvZmZzZXRZID0gcG9pbnQucmFkaXVzWTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHBvaW50LmNsaWVudFkgLSBvZmZzZXRZLFxuICAgICAgICByaWdodDogcG9pbnQuY2xpZW50WCArIG9mZnNldFgsXG4gICAgICAgIGJvdHRvbTogcG9pbnQuY2xpZW50WSArIG9mZnNldFksXG4gICAgICAgIGxlZnQ6IHBvaW50LmNsaWVudFggLSBvZmZzZXRYXG4gICAgfTtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRhcmVSZWN0YW5nbGVzT3ZlcmxhcHBpbmcoYSwgYikge1xuICAgIC8vIGNoZWNrIGlmIHRoZXkgY2Fubm90IG92ZXJsYXAgb24geCBheGlzXG4gICAgaWYgKGEubGVmdCA+IGIucmlnaHQgfHwgYi5sZWZ0ID4gYS5yaWdodCkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGNoZWNrIGlmIHRoZXkgY2Fubm90IG92ZXJsYXAgb24geSBheGlzXG4gICAgaWYgKGEudG9wID4gYi5ib3R0b20gfHwgYi50b3AgPiBhLmJvdHRvbSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldChwb2ludCwgdGFyZ2V0KSB7XG4gICAgbGV0IHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHBvaW50UmVjdCA9ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRQb2ludENsaWVudFJlY3QocG9pbnQpO1xuICAgIHJldHVybiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkYXJlUmVjdGFuZ2xlc092ZXJsYXBwaW5nKHJlY3QsIHBvaW50UmVjdCk7XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkc2hvdWxkUHJldmVudERlZmF1bHQodGFyZ2V0KSB7XG4gICAgLy8gV2UgY2Fubm90IHByZXZlbnQgZGVmYXVsdCBpZiB0aGUgdGFyZ2V0IGlzIGEgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgcmV0dXJuICEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8ICF0YXJnZXQuaGFzQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0S2V5Ym9hcmQodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkgcmV0dXJuICEkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNWYWxpZElucHV0S2V5KHRhcmdldCwga2V5KTtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpIHJldHVybiB0YXJnZXQudHlwZSAhPT0gXCJzdWJtaXRcIiAmJiB0YXJnZXQudHlwZSAhPT0gXCJyZXNldFwiO1xuICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNIVE1MQW5jaG9yTGluayh0YXJnZXQpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkbm9uVGV4dElucHV0VHlwZXMgPSBuZXcgU2V0KFtcbiAgICBcImNoZWNrYm94XCIsXG4gICAgXCJyYWRpb1wiLFxuICAgIFwicmFuZ2VcIixcbiAgICBcImNvbG9yXCIsXG4gICAgXCJmaWxlXCIsXG4gICAgXCJpbWFnZVwiLFxuICAgIFwiYnV0dG9uXCIsXG4gICAgXCJzdWJtaXRcIixcbiAgICBcInJlc2V0XCJcbl0pO1xuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRJbnB1dEtleSh0YXJnZXQsIGtleSkge1xuICAgIC8vIE9ubHkgc3BhY2Ugc2hvdWxkIHRvZ2dsZSBjaGVja2JveGVzIGFuZCByYWRpb3MsIG5vdCBlbnRlci5cbiAgICByZXR1cm4gdGFyZ2V0LnR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCB0YXJnZXQudHlwZSA9PT0gXCJyYWRpb1wiID8ga2V5ID09PSBcIiBcIiA6ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRub25UZXh0SW5wdXRUeXBlcy5oYXModGFyZ2V0LnR5cGUpO1xufVxuXG5cblxuY29uc3QgJDNiMTE3ZTQzZGMwY2E5NWQkZXhwb3J0JDI3YzcwMWVkOWU0NDllOTkgPSAvKiNfX1BVUkVfXyovICgwLCAkYng3U0wkcmVhY3QpLmZvcndhcmRSZWYoKHsgY2hpbGRyZW46IGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpPT57XG4gICAgcmVmID0gKDAsICRieDdTTCR1c2VPYmplY3RSZWYpKHJlZik7XG4gICAgbGV0IHsgcHJlc3NQcm9wczogcHJlc3NQcm9wcyB9ID0gKDAsICRmNmMzMWNjZTJhZGY2NTRmJGV4cG9ydCQ0NTcxMmVjZWRhNmZhZDIxKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWY6IHJlZlxuICAgIH0pO1xuICAgIGxldCBjaGlsZCA9ICgwLCAkYng3U0wkcmVhY3QpLkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkYng3U0wkcmVhY3QpLmNsb25lRWxlbWVudChjaGlsZCwgLy8gQHRzLWlnbm9yZVxuICAgIHtcbiAgICAgICAgcmVmOiByZWYsXG4gICAgICAgIC4uLigwLCAkYng3U0wkbWVyZ2VQcm9wcykoY2hpbGQucHJvcHMsIHByZXNzUHJvcHMpXG4gICAgfSk7XG59KTtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuY29uc3QgJGYxYWI4Yzc1NDc4YzZmNzMkZXhwb3J0JDMzNTE4NzFlZTRiMjg4YjggPSAvKiNfX1BVUkVfXyovICgwLCAkYng3U0wkcmVhY3QpLmZvcndhcmRSZWYoKHsgY2hpbGRyZW46IGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpPT57XG4gICAgbGV0IGlzUmVnaXN0ZXJlZCA9ICgwLCAkYng3U0wkdXNlUmVmKShmYWxzZSk7XG4gICAgbGV0IHByZXZDb250ZXh0ID0gKDAsICRieDdTTCR1c2VDb250ZXh0KSgoMCwgJGFlMWVlYmE4YjllYWZkMDgkZXhwb3J0JDUxNjVlY2NiMzVhYWFkYjUpKTtcbiAgICByZWYgPSAoMCwgJGJ4N1NMJHVzZU9iamVjdFJlZikocmVmIHx8IChwcmV2Q29udGV4dCA9PT0gbnVsbCB8fCBwcmV2Q29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldkNvbnRleHQucmVmKSk7XG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJGJ4N1NMJG1lcmdlUHJvcHMpKHByZXZDb250ZXh0IHx8IHt9LCB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgcmVnaXN0ZXIgKCkge1xuICAgICAgICAgICAgaXNSZWdpc3RlcmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByZXZDb250ZXh0KSBwcmV2Q29udGV4dC5yZWdpc3RlcigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgKDAsICRieDdTTCR1c2VTeW5jUmVmKShwcmV2Q29udGV4dCwgcmVmKTtcbiAgICAoMCwgJGJ4N1NMJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKCFpc1JlZ2lzdGVyZWQuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSBQcmVzc1Jlc3BvbmRlciB3YXMgcmVuZGVyZWQgd2l0aG91dCBhIHByZXNzYWJsZSBjaGlsZC4gRWl0aGVyIGNhbGwgdGhlIHVzZVByZXNzIGhvb2ssIG9yIHdyYXAgeW91ciBET00gbm9kZSB3aXRoIDxQcmVzc2FibGU+IGNvbXBvbmVudC5cIik7XG4gICAgICAgICAgICBpc1JlZ2lzdGVyZWQuY3VycmVudCA9IHRydWU7IC8vIG9ubHkgd2FybiBvbmNlIGluIHN0cmljdCBtb2RlLlxuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkYng3U0wkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoKDAsICRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1KS5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dFxuICAgIH0sIGNoaWxkcmVuKTtcbn0pO1xuZnVuY3Rpb24gJGYxYWI4Yzc1NDc4YzZmNzMkZXhwb3J0JGNmNzU0MjhlMGI5ZWQxZWEoeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkge1xuICAgIGxldCBjb250ZXh0ID0gKDAsICRieDdTTCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHJlZ2lzdGVyOiAoKT0+e31cbiAgICAgICAgfSksIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJGJ4N1NMJHJlYWN0KS5jcmVhdGVFbGVtZW50KCgwLCAkYWUxZWViYThiOWVhZmQwOCRleHBvcnQkNTE2NWVjY2IzNWFhYWRiNSkuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHRcbiAgICB9LCBjaGlsZHJlbik7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIHJlYWN0LlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGZvciB0aGUgZm9sbG93aW5nIGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL2NjN2MxYWVjZTQ2YTZiNjliNDE5NThkNzMxZTBmZDI3Yzk0YmZjNmMvcGFja2FnZXMvcmVhY3QtaW50ZXJhY3Rpb25zXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY2xhc3MgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDkwNWU3ZmM1NDRhNzFmMzYge1xuICAgIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9XG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICB0aGlzLm5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gKCk9PnRydWU7XG4gICAgfVxuICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBlcnNpc3QoKSB7fVxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50KXtcbiAgICAgICAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldDtcbiAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbmF0aXZlRXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgdGhpcy5idWJibGVzID0gbmF0aXZlRXZlbnQuYnViYmxlcztcbiAgICAgICAgdGhpcy5jYW5jZWxhYmxlID0gbmF0aXZlRXZlbnQuY2FuY2VsYWJsZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgdGhpcy5ldmVudFBoYXNlID0gbmF0aXZlRXZlbnQuZXZlbnRQaGFzZTtcbiAgICAgICAgdGhpcy5pc1RydXN0ZWQgPSBuYXRpdmVFdmVudC5pc1RydXN0ZWQ7XG4gICAgICAgIHRoaXMudGltZVN0YW1wID0gbmF0aXZlRXZlbnQudGltZVN0YW1wO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbn1cbmZ1bmN0aW9uICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjKG9uQmx1cikge1xuICAgIGxldCBzdGF0ZVJlZiA9ICgwLCAkYng3U0wkdXNlUmVmKSh7XG4gICAgICAgIGlzRm9jdXNlZDogZmFsc2UsXG4gICAgICAgIG9ic2VydmVyOiBudWxsXG4gICAgfSk7XG4gICAgLy8gQ2xlYW4gdXAgTXV0YXRpb25PYnNlcnZlciBvbiB1bm1vdW50LiBTZWUgYmVsb3cuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJGJ4N1NMJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmIChzdGF0ZS5vYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGxldCBkaXNwYXRjaEJsdXIgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgoZSk9PntcbiAgICAgICAgb25CbHVyID09PSBudWxsIHx8IG9uQmx1ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25CbHVyKGUpO1xuICAgIH0pO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGR1cmluZyBhIFJlYWN0IG9uRm9jdXMgZXZlbnQuXG4gICAgcmV0dXJuICgwLCAkYng3U0wkdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICAvLyBSZWFjdCBkb2VzIG5vdCBmaXJlIG9uQmx1ciB3aGVuIGFuIGVsZW1lbnQgaXMgZGlzYWJsZWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvOTE0MlxuICAgICAgICAvLyBNb3N0IGJyb3dzZXJzIGZpcmUgYSBuYXRpdmUgZm9jdXNvdXQgZXZlbnQgaW4gdGhpcyBjYXNlLCBleGNlcHQgZm9yIEZpcmVmb3guIEluIHRoYXQgY2FzZSwgd2UgdXNlIGFcbiAgICAgICAgLy8gTXV0YXRpb25PYnNlcnZlciB0byB3YXRjaCBmb3IgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSwgYW5kIGRpc3BhdGNoIHRoZXNlIGV2ZW50cyBvdXJzZWx2ZXMuXG4gICAgICAgIC8vIEZvciBicm93c2VycyB0aGF0IGRvLCBmb2N1c291dCBmaXJlcyBiZWZvcmUgdGhlIE11dGF0aW9uT2JzZXJ2ZXIsIHNvIG9uQmx1ciBzaG91bGQgbm90IGZpcmUgdHdpY2UuXG4gICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50IHx8IGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkge1xuICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgbGV0IG9uQmx1ckhhbmRsZXIgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50LmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuZGlzYWJsZWQpIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBkaXNwYXRjaCBhIChmYWtlKSBSZWFjdCBzeW50aGV0aWMgZXZlbnQuXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hCbHVyKG5ldyAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkOTA1ZTdmYzU0NGE3MWYzNihcImJsdXJcIiwgZSkpO1xuICAgICAgICAgICAgICAgIC8vIFdlIG5vIGxvbmdlciBuZWVkIHRoZSBNdXRhdGlvbk9ic2VydmVyIG9uY2UgdGhlIHRhcmdldCBpcyBibHVycmVkLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBvbkJsdXJIYW5kbGVyLCB7XG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVSZWYuY3VycmVudC5pc0ZvY3VzZWQgJiYgdGFyZ2V0LmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVSZWZfY3VycmVudF9vYnNlcnZlcjtcbiAgICAgICAgICAgICAgICAgICAgKF9zdGF0ZVJlZl9jdXJyZW50X29ic2VydmVyID0gc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlcikgPT09IG51bGwgfHwgX3N0YXRlUmVmX2N1cnJlbnRfb2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZVJlZl9jdXJyZW50X29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlbGF0ZWRUYXJnZXRFbCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA/IG51bGwgOiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRm9jdXNFdmVudChcImJsdXJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldEVsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEZvY3VzRXZlbnQoXCJmb2N1c291dFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldEVsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1xuICAgICAgICAgICAgICAgICAgICBcImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hCbHVyXG4gICAgXSk7XG59XG5cblxuZnVuY3Rpb24gJGExZWE1OWQ2ODI3MGYwZGQkZXhwb3J0JGY4MTY4ZDhkZDhmZDY2ZTYocHJvcHMpIHtcbiAgICBsZXQgeyBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLCBvbkZvY3VzOiBvbkZvY3VzUHJvcCwgb25CbHVyOiBvbkJsdXJQcm9wLCBvbkZvY3VzQ2hhbmdlOiBvbkZvY3VzQ2hhbmdlIH0gPSBwcm9wcztcbiAgICBjb25zdCBvbkJsdXIgPSAoMCwgJGJ4N1NMJHVzZUNhbGxiYWNrKSgoZSk9PntcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChvbkJsdXJQcm9wKSBvbkJsdXJQcm9wKGUpO1xuICAgICAgICAgICAgaWYgKG9uRm9jdXNDaGFuZ2UpIG9uRm9jdXNDaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uQmx1clByb3AsXG4gICAgICAgIG9uRm9jdXNDaGFuZ2VcbiAgICBdKTtcbiAgICBjb25zdCBvblN5bnRoZXRpY0ZvY3VzID0gKDAsICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjKShvbkJsdXIpO1xuICAgIGNvbnN0IG9uRm9jdXMgPSAoMCwgJGJ4N1NMJHVzZUNhbGxiYWNrKSgoZSk9PntcbiAgICAgICAgLy8gRG91YmxlIGNoZWNrIHRoYXQgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhY3R1YWxseSBtYXRjaGVzIGUudGFyZ2V0IGluIGNhc2UgYSBwcmV2aW91c2x5IGNoYWluZWRcbiAgICAgICAgLy8gZm9jdXMgaGFuZGxlciBhbHJlYWR5IG1vdmVkIGZvY3VzIHNvbWV3aGVyZSBlbHNlLlxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlLnRhcmdldCkge1xuICAgICAgICAgICAgaWYgKG9uRm9jdXNQcm9wKSBvbkZvY3VzUHJvcChlKTtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzQ2hhbmdlKSBvbkZvY3VzQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgb25TeW50aGV0aWNGb2N1cyhlKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25Gb2N1c0NoYW5nZSxcbiAgICAgICAgb25Gb2N1c1Byb3AsXG4gICAgICAgIG9uU3ludGhldGljRm9jdXNcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb2N1c1Byb3BzOiB7XG4gICAgICAgICAgICBvbkZvY3VzOiAhaXNEaXNhYmxlZCAmJiAob25Gb2N1c1Byb3AgfHwgb25Gb2N1c0NoYW5nZSB8fCBvbkJsdXJQcm9wKSA/IG9uRm9jdXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvbkJsdXI6ICFpc0Rpc2FibGVkICYmIChvbkJsdXJQcm9wIHx8IG9uRm9jdXNDaGFuZ2UpID8gb25CbHVyIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSByZWFjdC5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBmb3IgdGhlIGZvbGxvd2luZyBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBOT1RJQ0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9jYzdjMWFlY2U0NmE2YjY5YjQxOTU4ZDczMWUwZmQyN2M5NGJmYzZjL3BhY2thZ2VzL3JlYWN0LWludGVyYWN0aW9uc1xuXG5cblxubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBudWxsO1xubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycyA9IG5ldyBTZXQoKTtcbmxldCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzU2V0dXBHbG9iYWxMaXN0ZW5lcnMgPSBmYWxzZTtcbmxldCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IGZhbHNlO1xubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNCbHVycmVkV2luZG93UmVjZW50bHkgPSBmYWxzZTtcbi8vIE9ubHkgVGFiIG9yIEVzYyBrZXlzIHdpbGwgbWFrZSBmb2N1cyB2aXNpYmxlIG9uIHRleHQgaW5wdXQgZWxlbWVudHNcbmNvbnN0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRGT0NVU19WSVNJQkxFX0lOUFVUX0tFWVMgPSB7XG4gICAgVGFiOiB0cnVlLFxuICAgIEVzY2FwZTogdHJ1ZVxufTtcbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMobW9kYWxpdHksIGUpIHtcbiAgICBmb3IgKGxldCBoYW5kbGVyIG9mICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycyloYW5kbGVyKG1vZGFsaXR5LCBlKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhIEtleWJvYXJkRXZlbnQgaXMgdW5tb2RpZmllZCBhbmQgY291bGQgbWFrZSBrZXlib2FyZCBmb2N1cyBzdHlsZXMgdmlzaWJsZS5cbiAqLyBmdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNWYWxpZEtleShlKSB7XG4gICAgLy8gQ29udHJvbCBhbmQgU2hpZnQga2V5cyB0cmlnZ2VyIHdoZW4gbmF2aWdhdGluZyBiYWNrIHRvIHRoZSB0YWIgd2l0aCBrZXlib2FyZC5cbiAgICByZXR1cm4gIShlLm1ldGFLZXkgfHwgISgwLCAkYng3U0wkaXNNYWMpKCkgJiYgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUua2V5ID09PSBcIkNvbnRyb2xcIiB8fCBlLmtleSA9PT0gXCJTaGlmdFwiIHx8IGUua2V5ID09PSBcIk1ldGFcIik7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlS2V5Ym9hcmRFdmVudChlKSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSB0cnVlO1xuICAgIGlmICgkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNWYWxpZEtleShlKSkge1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ID0gXCJrZXlib2FyZFwiO1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdHJpZ2dlckNoYW5nZUhhbmRsZXJzKFwia2V5Ym9hcmRcIiwgZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudChlKSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IFwicG9pbnRlclwiO1xuICAgIGlmIChlLnR5cGUgPT09IFwibW91c2Vkb3duXCIgfHwgZS50eXBlID09PSBcInBvaW50ZXJkb3duXCIpIHtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSB0cnVlO1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdHJpZ2dlckNoYW5nZUhhbmRsZXJzKFwicG9pbnRlclwiLCBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlQ2xpY2tFdmVudChlKSB7XG4gICAgaWYgKCgwLCAkYng3U0wkaXNWaXJ0dWFsQ2xpY2spKGUpKSB7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gdHJ1ZTtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IFwidmlydHVhbFwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVGb2N1c0V2ZW50KGUpIHtcbiAgICAvLyBGaXJlZm94IGZpcmVzIHR3byBleHRyYSBmb2N1cyBldmVudHMgd2hlbiB0aGUgdXNlciBmaXJzdCBjbGlja3MgaW50byBhbiBpZnJhbWU6XG4gICAgLy8gZmlyc3Qgb24gdGhlIHdpbmRvdywgdGhlbiBvbiB0aGUgZG9jdW1lbnQuIFdlIGlnbm9yZSB0aGVzZSBldmVudHMgc28gdGhleSBkb24ndFxuICAgIC8vIGNhdXNlIGtleWJvYXJkIGZvY3VzIHJpbmdzIHRvIGFwcGVhci5cbiAgICBpZiAoZS50YXJnZXQgPT09IHdpbmRvdyB8fCBlLnRhcmdldCA9PT0gZG9jdW1lbnQpIHJldHVybjtcbiAgICAvLyBJZiBhIGZvY3VzIGV2ZW50IG9jY3VycyB3aXRob3V0IGEgcHJlY2VkaW5nIGtleWJvYXJkIG9yIHBvaW50ZXIgZXZlbnQsIHN3aXRjaCB0byB2aXJ0dWFsIG1vZGFsaXR5LlxuICAgIC8vIFRoaXMgb2NjdXJzLCBmb3IgZXhhbXBsZSwgd2hlbiBuYXZpZ2F0aW5nIGEgZm9ybSB3aXRoIHRoZSBuZXh0L3ByZXZpb3VzIGJ1dHRvbnMgb24gaU9TLlxuICAgIGlmICghJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgJiYgISQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNCbHVycmVkV2luZG93UmVjZW50bHkpIHtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IFwidmlydHVhbFwiO1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdHJpZ2dlckNoYW5nZUhhbmRsZXJzKFwidmlydHVhbFwiLCBlKTtcbiAgICB9XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSBmYWxzZTtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzQmx1cnJlZFdpbmRvd1JlY2VudGx5ID0gZmFsc2U7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlV2luZG93Qmx1cigpIHtcbiAgICAvLyBXaGVuIHRoZSB3aW5kb3cgaXMgYmx1cnJlZCwgcmVzZXQgc3RhdGUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gdGFiYmluZyBvdXQgb2YgdGhlIHdpbmRvdyxcbiAgICAvLyBmb3IgZXhhbXBsZSwgc2luY2UgYSBzdWJzZXF1ZW50IGZvY3VzIGV2ZW50IHdvbid0IGJlIGZpcmVkLlxuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gZmFsc2U7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0JsdXJyZWRXaW5kb3dSZWNlbnRseSA9IHRydWU7XG59XG4vKipcbiAqIFNldHVwIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMgdG8gY29udHJvbCB3aGVuIGtleWJvYXJkIGZvY3VzIHN0eWxlIHNob3VsZCBiZSB2aXNpYmxlLlxuICovIGZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNTZXR1cEdsb2JhbExpc3RlbmVycykgcmV0dXJuO1xuICAgIC8vIFByb2dyYW1tYXRpYyBmb2N1cygpIGNhbGxzIHNob3VsZG4ndCBhZmZlY3QgdGhlIGN1cnJlbnQgaW5wdXQgbW9kYWxpdHkuXG4gICAgLy8gSG93ZXZlciwgd2UgbmVlZCB0byBkZXRlY3Qgb3RoZXIgY2FzZXMgd2hlbiBhIGZvY3VzIGV2ZW50IG9jY3VycyB3aXRob3V0XG4gICAgLy8gYSBwcmVjZWRpbmcgdXNlciBldmVudCAoZS5nLiBzY3JlZW4gcmVhZGVyIGZvY3VzKS4gT3ZlcnJpZGluZyB0aGUgZm9jdXNcbiAgICAvLyBtZXRob2Qgb24gSFRNTEVsZW1lbnQucHJvdG90eXBlIGlzIGEgYml0IGhhY2t5LCBidXQgd29ya3MuXG4gICAgbGV0IGZvY3VzID0gSFRNTEVsZW1lbnQucHJvdG90eXBlLmZvY3VzO1xuICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IHRydWU7XG4gICAgICAgIGZvY3VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlS2V5Ym9hcmRFdmVudCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVLZXlib2FyZEV2ZW50LCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUNsaWNrRXZlbnQsIHRydWUpO1xuICAgIC8vIFJlZ2lzdGVyIGZvY3VzIGV2ZW50cyBvbiB0aGUgd2luZG93IHNvIHRoZXkgYXJlIHN1cmUgdG8gaGFwcGVuXG4gICAgLy8gYmVmb3JlIFJlYWN0J3MgZXZlbnQgbGlzdGVuZXJzIChyZWdpc3RlcmVkIG9uIHRoZSBkb2N1bWVudCkuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlRm9jdXNFdmVudCwgdHJ1ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVXaW5kb3dCbHVyLCBmYWxzZSk7XG4gICAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNTZXR1cEdsb2JhbExpc3RlbmVycyA9IHRydWU7XG59XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiKSAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkc2V0dXBHbG9iYWxGb2N1c0V2ZW50cygpO1xuICAgIGVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMpO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGI5YjNkZmRkYWIxN2RiMjcoKSB7XG4gICAgcmV0dXJuICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgIT09IFwicG9pbnRlclwiO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDYzMGZmNjUzYzVhZGE2YTkoKSB7XG4gICAgcmV0dXJuICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHk7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkODM5N2RkZmM1MDRmZGI5YShtb2RhbGl0eSkge1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBtb2RhbGl0eTtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdHJpZ2dlckNoYW5nZUhhbmRsZXJzKG1vZGFsaXR5LCBudWxsKTtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ5OGUyMGVjOTJmNjE0Y2ZlKCkge1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzKCk7XG4gICAgbGV0IFttb2RhbGl0eSwgc2V0TW9kYWxpdHldID0gKDAsICRieDdTTCR1c2VTdGF0ZSkoJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSk7XG4gICAgKDAsICRieDdTTCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBoYW5kbGVyID0gKCk9PntcbiAgICAgICAgICAgIHNldE1vZGFsaXR5KCQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkpO1xuICAgICAgICB9O1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY2hhbmdlSGFuZGxlcnMuYWRkKGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycy5kZWxldGUoaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoMCwgJGJ4N1NMJHVzZUlzU1NSKSgpID8gbnVsbCA6IG1vZGFsaXR5O1xufVxuY29uc3QgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJG5vblRleHRJbnB1dFR5cGVzID0gbmV3IFNldChbXG4gICAgXCJjaGVja2JveFwiLFxuICAgIFwicmFkaW9cIixcbiAgICBcInJhbmdlXCIsXG4gICAgXCJjb2xvclwiLFxuICAgIFwiZmlsZVwiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwic3VibWl0XCIsXG4gICAgXCJyZXNldFwiXG5dKTtcbi8qKlxuICogSWYgdGhpcyBpcyBhdHRhY2hlZCB0byB0ZXh0IGlucHV0IGNvbXBvbmVudCwgcmV0dXJuIGlmIHRoZSBldmVudCBpcyBhIGZvY3VzIGV2ZW50IChUYWIvRXNjYXBlIGtleXMgcHJlc3NlZCkgc28gdGhhdFxuICogZm9jdXMgdmlzaWJsZSBzdHlsZSBjYW4gYmUgcHJvcGVybHkgc2V0LlxuICovIGZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRpc0tleWJvYXJkRm9jdXNFdmVudChpc1RleHRJbnB1dCwgbW9kYWxpdHksIGUpIHtcbiAgICB2YXIgX2VfdGFyZ2V0O1xuICAgIGlzVGV4dElucHV0ID0gaXNUZXh0SW5wdXQgfHwgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50YXJnZXQpIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiAhJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJG5vblRleHRJbnB1dFR5cGVzLmhhcyhlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZV90YXJnZXQgPSBlLnRhcmdldCkgPT09IG51bGwgfHwgX2VfdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZV90YXJnZXQudHlwZSkgfHwgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50YXJnZXQpIGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCB8fCAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRhcmdldCkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSk7XG4gICAgcmV0dXJuICEoaXNUZXh0SW5wdXQgJiYgbW9kYWxpdHkgPT09IFwia2V5Ym9hcmRcIiAmJiBlIGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCAmJiAhJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJEZPQ1VTX1ZJU0lCTEVfSU5QVVRfS0VZU1tlLmtleV0pO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGZmZDllNTAyMWMxZmIyZDYocHJvcHMgPSB7fSkge1xuICAgIGxldCB7IGlzVGV4dElucHV0OiBpc1RleHRJbnB1dCwgYXV0b0ZvY3VzOiBhdXRvRm9jdXMgfSA9IHByb3BzO1xuICAgIGxldCBbaXNGb2N1c1Zpc2libGVTdGF0ZSwgc2V0Rm9jdXNWaXNpYmxlXSA9ICgwLCAkYng3U0wkdXNlU3RhdGUpKGF1dG9Gb2N1cyB8fCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkYjliM2RmZGRhYjE3ZGIyNygpKTtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZWM3MWI0YjgzYWMwOGVjMygoaXNGb2N1c1Zpc2libGUpPT57XG4gICAgICAgIHNldEZvY3VzVmlzaWJsZShpc0ZvY3VzVmlzaWJsZSk7XG4gICAgfSwgW1xuICAgICAgICBpc1RleHRJbnB1dFxuICAgIF0sIHtcbiAgICAgICAgaXNUZXh0SW5wdXQ6IGlzVGV4dElucHV0XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNGb2N1c1Zpc2libGU6IGlzRm9jdXNWaXNpYmxlU3RhdGVcbiAgICB9O1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGVjNzFiNGI4M2FjMDhlYzMoZm4sIGRlcHMsIG9wdHMpIHtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkc2V0dXBHbG9iYWxGb2N1c0V2ZW50cygpO1xuICAgICgwLCAkYng3U0wkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgaGFuZGxlciA9IChtb2RhbGl0eSwgZSk9PntcbiAgICAgICAgICAgIGlmICghJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGlzS2V5Ym9hcmRGb2N1c0V2ZW50KCEhKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5pc1RleHRJbnB1dCksIG1vZGFsaXR5LCBlKSkgcmV0dXJuO1xuICAgICAgICAgICAgZm4oJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGI5YjNkZmRkYWIxN2RiMjcoKSk7XG4gICAgICAgIH07XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycy5hZGQoaGFuZGxlcik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzLmRlbGV0ZShoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgZGVwcyk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIHJlYWN0LlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGZvciB0aGUgZm9sbG93aW5nIGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL2NjN2MxYWVjZTQ2YTZiNjliNDE5NThkNzMxZTBmZDI3Yzk0YmZjNmMvcGFja2FnZXMvcmVhY3QtaW50ZXJhY3Rpb25zXG5cblxuZnVuY3Rpb24gJDlhYjk0MjYyYmQwMDQ3YzckZXhwb3J0JDQyMGU2ODI3MzE2NWY0ZWMocHJvcHMpIHtcbiAgICBsZXQgeyBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLCBvbkJsdXJXaXRoaW46IG9uQmx1cldpdGhpbiwgb25Gb2N1c1dpdGhpbjogb25Gb2N1c1dpdGhpbiwgb25Gb2N1c1dpdGhpbkNoYW5nZTogb25Gb2N1c1dpdGhpbkNoYW5nZSB9ID0gcHJvcHM7XG4gICAgbGV0IHN0YXRlID0gKDAsICRieDdTTCR1c2VSZWYpKHtcbiAgICAgICAgaXNGb2N1c1dpdGhpbjogZmFsc2VcbiAgICB9KTtcbiAgICBsZXQgb25CbHVyID0gKDAsICRieDdTTCR1c2VDYWxsYmFjaykoKGUpPT57XG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBvbkJsdXJXaXRoaW4gYW5kIHRoZW4gaW1tZWRpYXRlbHkgb25Gb2N1c1dpdGhpbiBhZ2FpblxuICAgICAgICAvLyB3aGVuIG1vdmluZyBmb2N1cyBpbnNpZGUgdGhlIGVsZW1lbnQuIE9ubHkgdHJpZ2dlciBpZiB0aGUgY3VycmVudFRhcmdldCBkb2Vzbid0XG4gICAgICAgIC8vIGluY2x1ZGUgdGhlIHJlbGF0ZWRUYXJnZXQgKHdoZXJlIGZvY3VzIGlzIG1vdmluZykuXG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50LmlzRm9jdXNXaXRoaW4gJiYgIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlzRm9jdXNXaXRoaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChvbkJsdXJXaXRoaW4pIG9uQmx1cldpdGhpbihlKTtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzV2l0aGluQ2hhbmdlKSBvbkZvY3VzV2l0aGluQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25CbHVyV2l0aGluLFxuICAgICAgICBvbkZvY3VzV2l0aGluQ2hhbmdlLFxuICAgICAgICBzdGF0ZVxuICAgIF0pO1xuICAgIGxldCBvblN5bnRoZXRpY0ZvY3VzID0gKDAsICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjKShvbkJsdXIpO1xuICAgIGxldCBvbkZvY3VzID0gKDAsICRieDdTTCR1c2VDYWxsYmFjaykoKGUpPT57XG4gICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYWN0dWFsbHkgbWF0Y2hlcyBlLnRhcmdldCBpbiBjYXNlIGEgcHJldmlvdXNseSBjaGFpbmVkXG4gICAgICAgIC8vIGZvY3VzIGhhbmRsZXIgYWxyZWFkeSBtb3ZlZCBmb2N1cyBzb21ld2hlcmUgZWxzZS5cbiAgICAgICAgaWYgKCFzdGF0ZS5jdXJyZW50LmlzRm9jdXNXaXRoaW4gJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZS50YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzV2l0aGluKSBvbkZvY3VzV2l0aGluKGUpO1xuICAgICAgICAgICAgaWYgKG9uRm9jdXNXaXRoaW5DaGFuZ2UpIG9uRm9jdXNXaXRoaW5DaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlzRm9jdXNXaXRoaW4gPSB0cnVlO1xuICAgICAgICAgICAgb25TeW50aGV0aWNGb2N1cyhlKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25Gb2N1c1dpdGhpbixcbiAgICAgICAgb25Gb2N1c1dpdGhpbkNoYW5nZSxcbiAgICAgICAgb25TeW50aGV0aWNGb2N1c1xuICAgIF0pO1xuICAgIGlmIChpc0Rpc2FibGVkKSByZXR1cm4ge1xuICAgICAgICBmb2N1c1dpdGhpblByb3BzOiB7XG4gICAgICAgICAgICAvLyBUaGVzZSBzaG91bGQgbm90IGhhdmUgYmVlbiBudWxsLCB0aGF0IHdvdWxkIGNvbmZsaWN0IGluIG1lcmdlUHJvcHNcbiAgICAgICAgICAgIG9uRm9jdXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uQmx1cjogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvY3VzV2l0aGluUHJvcHM6IHtcbiAgICAgICAgICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgICAgICAgICBvbkJsdXI6IG9uQmx1clxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuLy8gaU9TIGZpcmVzIG9uUG9pbnRlckVudGVyIHR3aWNlOiBvbmNlIHdpdGggcG9pbnRlclR5cGU9XCJ0b3VjaFwiIGFuZCBhZ2FpbiB3aXRoIHBvaW50ZXJUeXBlPVwibW91c2VcIi5cbi8vIFdlIHdhbnQgdG8gaWdub3JlIHRoZXNlIGVtdWxhdGVkIGV2ZW50cyBzbyB0aGV5IGRvIG5vdCB0cmlnZ2VyIGhvdmVyIGJlaGF2aW9yLlxuLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMTQ2MDkuXG5sZXQgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSBmYWxzZTtcbmxldCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudCA9IDA7XG5mdW5jdGlvbiAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0R2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cygpIHtcbiAgICAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgLy8gQ2xlYXIgZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyBhZnRlciBhIHNob3J0IHRpbWVvdXQuIGlPUyBmaXJlcyBvblBvaW50ZXJFbnRlclxuICAgIC8vIHdpdGggcG9pbnRlclR5cGU9XCJtb3VzZVwiIGltbWVkaWF0ZWx5IGFmdGVyIG9uUG9pbnRlclVwIGFuZCBiZWZvcmUgb25Gb2N1cy4gT24gb3RoZXJcbiAgICAvLyBkZXZpY2VzIHRoYXQgZG9uJ3QgaGF2ZSB0aGlzIHF1aXJrLCB3ZSBkb24ndCB3YW50IHRvIGlnbm9yZSBhIG1vdXNlIGhvdmVyIHNvbWV0aW1lIGluXG4gICAgLy8gdGhlIGRpc3RhbnQgZnV0dXJlIGJlY2F1c2UgYSB1c2VyIHByZXZpb3VzbHkgdG91Y2hlZCB0aGUgZWxlbWVudC5cbiAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhhbmRsZUdsb2JhbFBvaW50ZXJFdmVudChlKSB7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldEdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMoKTtcbn1cbmZ1bmN0aW9uICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXR1cEdsb2JhbFRvdWNoRXZlbnRzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaGFuZGxlR2xvYmFsUG9pbnRlckV2ZW50KTtcbiAgICBlbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0R2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyk7XG4gICAgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhvdmVyQ291bnQrKztcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhvdmVyQ291bnQtLTtcbiAgICAgICAgaWYgKCQ2MTc5YjkzNjcwNWU3NmQzJHZhciRob3ZlckNvdW50ID4gMCkgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaGFuZGxlR2xvYmFsUG9pbnRlckV2ZW50KTtcbiAgICAgICAgZWxzZSBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldEdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMpO1xuICAgIH07XG59XG5mdW5jdGlvbiAkNjE3OWI5MzY3MDVlNzZkMyRleHBvcnQkYWU3ODBkYWYyOWU2ZDQ1Nihwcm9wcykge1xuICAgIGxldCB7IG9uSG92ZXJTdGFydDogb25Ib3ZlclN0YXJ0LCBvbkhvdmVyQ2hhbmdlOiBvbkhvdmVyQ2hhbmdlLCBvbkhvdmVyRW5kOiBvbkhvdmVyRW5kLCBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkIH0gPSBwcm9wcztcbiAgICBsZXQgW2lzSG92ZXJlZCwgc2V0SG92ZXJlZF0gPSAoMCwgJGJ4N1NMJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IHN0YXRlID0gKDAsICRieDdTTCR1c2VSZWYpKHtcbiAgICAgICAgaXNIb3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50czogZmFsc2UsXG4gICAgICAgIHBvaW50ZXJUeXBlOiBcIlwiLFxuICAgICAgICB0YXJnZXQ6IG51bGxcbiAgICB9KS5jdXJyZW50O1xuICAgICgwLCAkYng3U0wkdXNlRWZmZWN0KSgkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0dXBHbG9iYWxUb3VjaEV2ZW50cywgW10pO1xuICAgIGxldCB7IGhvdmVyUHJvcHM6IGhvdmVyUHJvcHMsIHRyaWdnZXJIb3ZlckVuZDogdHJpZ2dlckhvdmVyRW5kIH0gPSAoMCwgJGJ4N1NMJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIGxldCB0cmlnZ2VySG92ZXJTdGFydCA9IChldmVudCwgcG9pbnRlclR5cGUpPT57XG4gICAgICAgICAgICBzdGF0ZS5wb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgcG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCBzdGF0ZS5pc0hvdmVyZWQgfHwgIWV2ZW50LmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgc3RhdGUuaXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgc3RhdGUudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKG9uSG92ZXJTdGFydCkgb25Ib3ZlclN0YXJ0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImhvdmVyc3RhcnRcIixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9uSG92ZXJDaGFuZ2UpIG9uSG92ZXJDaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgICBzZXRIb3ZlcmVkKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgdHJpZ2dlckhvdmVyRW5kID0gKGV2ZW50LCBwb2ludGVyVHlwZSk9PntcbiAgICAgICAgICAgIHN0YXRlLnBvaW50ZXJUeXBlID0gXCJcIjtcbiAgICAgICAgICAgIHN0YXRlLnRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCAhc3RhdGUuaXNIb3ZlcmVkKSByZXR1cm47XG4gICAgICAgICAgICBzdGF0ZS5pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgaWYgKG9uSG92ZXJFbmQpIG9uSG92ZXJFbmQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaG92ZXJlbmRcIixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9uSG92ZXJDaGFuZ2UpIG9uSG92ZXJDaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgc2V0SG92ZXJlZChmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBob3ZlclByb3BzID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBob3ZlclByb3BzLm9uUG9pbnRlckVudGVyID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzICYmIGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJIb3ZlclN0YXJ0KGUsIGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhvdmVyUHJvcHMub25Qb2ludGVyTGVhdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgdHJpZ2dlckhvdmVyRW5kKGUsIGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvdmVyUHJvcHMub25Ub3VjaFN0YXJ0ID0gKCk9PntcbiAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBob3ZlclByb3BzLm9uTW91c2VFbnRlciA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyAmJiAhJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMpIHRyaWdnZXJIb3ZlclN0YXJ0KGUsIFwibW91c2VcIik7XG4gICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhvdmVyUHJvcHMub25Nb3VzZUxlYXZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Rpc2FibGVkICYmIGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHRyaWdnZXJIb3ZlckVuZChlLCBcIm1vdXNlXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG92ZXJQcm9wczogaG92ZXJQcm9wcyxcbiAgICAgICAgICAgIHRyaWdnZXJIb3ZlckVuZDogdHJpZ2dlckhvdmVyRW5kXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBvbkhvdmVyU3RhcnQsXG4gICAgICAgIG9uSG92ZXJDaGFuZ2UsXG4gICAgICAgIG9uSG92ZXJFbmQsXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHN0YXRlXG4gICAgXSk7XG4gICAgKDAsICRieDdTTCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIC8vIENhbGwgdGhlIHRyaWdnZXJIb3ZlckVuZCBhcyBzb29uIGFzIGlzRGlzYWJsZWQgY2hhbmdlcyB0byB0cnVlXG4gICAgICAgIC8vIFNhZmUgdG8gY2FsbCB0cmlnZ2VySG92ZXJFbmQsIGl0IHdpbGwgZWFybHkgcmV0dXJuIGlmIHdlIGFyZW4ndCBjdXJyZW50bHkgaG92ZXJpbmdcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHRyaWdnZXJIb3ZlckVuZCh7XG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBzdGF0ZS50YXJnZXRcbiAgICAgICAgfSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXG4gICAgICAgIGlzRGlzYWJsZWRcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBob3ZlclByb3BzOiBob3ZlclByb3BzLFxuICAgICAgICBpc0hvdmVyZWQ6IGlzSG92ZXJlZFxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIHJlYWN0LlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGZvciB0aGUgZm9sbG93aW5nIGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL2NjN2MxYWVjZTQ2YTZiNjliNDE5NThkNzMxZTBmZDI3Yzk0YmZjNmMvcGFja2FnZXMvcmVhY3QtaW50ZXJhY3Rpb25zXG5cblxuZnVuY3Rpb24gJGUwYjZlMGI2OGVjN2Y1MGYkZXhwb3J0JDg3MmI2NjBhYzVhMWZmOTgocHJvcHMpIHtcbiAgICBsZXQgeyByZWY6IHJlZiwgb25JbnRlcmFjdE91dHNpZGU6IG9uSW50ZXJhY3RPdXRzaWRlLCBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLCBvbkludGVyYWN0T3V0c2lkZVN0YXJ0OiBvbkludGVyYWN0T3V0c2lkZVN0YXJ0IH0gPSBwcm9wcztcbiAgICBsZXQgc3RhdGVSZWYgPSAoMCwgJGJ4N1NMJHVzZVJlZikoe1xuICAgICAgICBpc1BvaW50ZXJEb3duOiBmYWxzZSxcbiAgICAgICAgaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50czogZmFsc2VcbiAgICB9KTtcbiAgICBsZXQgb25Qb2ludGVyRG93biA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChlKT0+e1xuICAgICAgICBpZiAob25JbnRlcmFjdE91dHNpZGUgJiYgJGUwYjZlMGI2OGVjN2Y1MGYkdmFyJGlzVmFsaWRFdmVudChlLCByZWYpKSB7XG4gICAgICAgICAgICBpZiAob25JbnRlcmFjdE91dHNpZGVTdGFydCkgb25JbnRlcmFjdE91dHNpZGVTdGFydChlKTtcbiAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQuaXNQb2ludGVyRG93biA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgdHJpZ2dlckludGVyYWN0T3V0c2lkZSA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChlKT0+e1xuICAgICAgICBpZiAob25JbnRlcmFjdE91dHNpZGUpIG9uSW50ZXJhY3RPdXRzaWRlKGUpO1xuICAgIH0pO1xuICAgICgwLCAkYng3U0wkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgc3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50T2JqZWN0ID0gKDAsICRieDdTTCRnZXRPd25lckRvY3VtZW50KShlbGVtZW50KTtcbiAgICAgICAgLy8gVXNlIHBvaW50ZXIgZXZlbnRzIGlmIGF2YWlsYWJsZS4gT3RoZXJ3aXNlLCBmYWxsIGJhY2sgdG8gbW91c2UgYW5kIHRvdWNoIGV2ZW50cy5cbiAgICAgICAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBvblBvaW50ZXJVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc1BvaW50ZXJEb3duICYmICRlMGI2ZTBiNjhlYzdmNTBmJHZhciRpc1ZhbGlkRXZlbnQoZSwgcmVmKSkgdHJpZ2dlckludGVyYWN0T3V0c2lkZShlKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY2hhbmdpbmcgdGhlc2UgdG8gY2FwdHVyZSBwaGFzZSBmaXhlZCBjb21ib2JveFxuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG9uTW91c2VVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKSBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUuaXNQb2ludGVyRG93biAmJiAkZTBiNmUwYjY4ZWM3ZjUwZiR2YXIkaXNWYWxpZEV2ZW50KGUsIHJlZikpIHRyaWdnZXJJbnRlcmFjdE91dHNpZGUoZSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvblRvdWNoRW5kID0gKGUpPT57XG4gICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzUG9pbnRlckRvd24gJiYgJGUwYjZlMGI2OGVjN2Y1MGYkdmFyJGlzVmFsaWRFdmVudChlLCByZWYpKSB0cmlnZ2VySW50ZXJhY3RPdXRzaWRlKGUpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb2N1bWVudE9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCB0cnVlKTtcbiAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHJlZixcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgb25Qb2ludGVyRG93bixcbiAgICAgICAgdHJpZ2dlckludGVyYWN0T3V0c2lkZVxuICAgIF0pO1xufVxuZnVuY3Rpb24gJGUwYjZlMGI2OGVjN2Y1MGYkdmFyJGlzVmFsaWRFdmVudChldmVudCwgcmVmKSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiA+IDApIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgIC8vIGlmIHRoZSBldmVudCB0YXJnZXQgaXMgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCwgaWdub3JlXG4gICAgICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgICAgaWYgKCFvd25lckRvY3VtZW50IHx8ICFvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgd2l0aGluIGEgdG9wIGxheWVyIGVsZW1lbnQgKGUuZy4gdG9hc3RzKSwgaWdub3JlLlxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LmNsb3Nlc3QoXCJbZGF0YS1yZWFjdC1hcmlhLXRvcC1sYXllcl1cIikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50ICYmICFyZWYuY3VycmVudC5jb250YWlucyhldmVudC50YXJnZXQpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDkzOTI1MDgzZWNiYjM1OGMkZXhwb3J0JDQ4ZDFlYTYzMjA4MzAyNjAoaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlcikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICByZXR1cm4gKGUpPT57XG4gICAgICAgIGxldCBldmVudCA9IHtcbiAgICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCAoKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZCAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwic3RvcFByb3BhZ2F0aW9uIGlzIG5vdyB0aGUgZGVmYXVsdCBiZWhhdmlvciBmb3IgZXZlbnRzIGluIFJlYWN0IFNwZWN0cnVtLiBZb3UgY2FuIHVzZSBjb250aW51ZVByb3BhZ2F0aW9uKCkgdG8gcmV2ZXJ0IHRoaXMgYmVoYXZpb3IuXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRpbnVlUHJvcGFnYXRpb24gKCkge1xuICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBoYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xufVxuXG5cbmZ1bmN0aW9uICQ0NmQ4MTlmY2JhZjM1NjU0JGV4cG9ydCQ4ZjcxNjU0ODAxYzJmN2NkKHByb3BzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5Ym9hcmRQcm9wczogcHJvcHMuaXNEaXNhYmxlZCA/IHt9IDoge1xuICAgICAgICAgICAgb25LZXlEb3duOiAoMCwgJDkzOTI1MDgzZWNiYjM1OGMkZXhwb3J0JDQ4ZDFlYTYzMjA4MzAyNjApKHByb3BzLm9uS2V5RG93biksXG4gICAgICAgICAgICBvbktleVVwOiAoMCwgJDkzOTI1MDgzZWNiYjM1OGMkZXhwb3J0JDQ4ZDFlYTYzMjA4MzAyNjApKHByb3BzLm9uS2V5VXApXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkZThhNzAyMmNmODdjYmEyYSRleHBvcnQkMzZkYTk2Mzc5Zjc5ZjI0NShwcm9wcykge1xuICAgIGxldCB7IG9uTW92ZVN0YXJ0OiBvbk1vdmVTdGFydCwgb25Nb3ZlOiBvbk1vdmUsIG9uTW92ZUVuZDogb25Nb3ZlRW5kIH0gPSBwcm9wcztcbiAgICBsZXQgc3RhdGUgPSAoMCwgJGJ4N1NMJHVzZVJlZikoe1xuICAgICAgICBkaWRNb3ZlOiBmYWxzZSxcbiAgICAgICAgbGFzdFBvc2l0aW9uOiBudWxsLFxuICAgICAgICBpZDogbnVsbFxuICAgIH0pO1xuICAgIGxldCB7IGFkZEdsb2JhbExpc3RlbmVyOiBhZGRHbG9iYWxMaXN0ZW5lciwgcmVtb3ZlR2xvYmFsTGlzdGVuZXI6IHJlbW92ZUdsb2JhbExpc3RlbmVyIH0gPSAoMCwgJGJ4N1NMJHVzZUdsb2JhbExpc3RlbmVycykoKTtcbiAgICBsZXQgbW92ZSA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChvcmlnaW5hbEV2ZW50LCBwb2ludGVyVHlwZSwgZGVsdGFYLCBkZWx0YVkpPT57XG4gICAgICAgIGlmIChkZWx0YVggPT09IDAgJiYgZGVsdGFZID09PSAwKSByZXR1cm47XG4gICAgICAgIGlmICghc3RhdGUuY3VycmVudC5kaWRNb3ZlKSB7XG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmRpZE1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgb25Nb3ZlU3RhcnQgPT09IG51bGwgfHwgb25Nb3ZlU3RhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTW92ZVN0YXJ0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm1vdmVzdGFydFwiLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgICBzaGlmdEtleTogb3JpZ2luYWxFdmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICBtZXRhS2V5OiBvcmlnaW5hbEV2ZW50Lm1ldGFLZXksXG4gICAgICAgICAgICAgICAgY3RybEtleTogb3JpZ2luYWxFdmVudC5jdHJsS2V5LFxuICAgICAgICAgICAgICAgIGFsdEtleTogb3JpZ2luYWxFdmVudC5hbHRLZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG9uTW92ZSA9PT0gbnVsbCB8fCBvbk1vdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTW92ZSh7XG4gICAgICAgICAgICB0eXBlOiBcIm1vdmVcIixcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIGRlbHRhWDogZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZOiBkZWx0YVksXG4gICAgICAgICAgICBzaGlmdEtleTogb3JpZ2luYWxFdmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1ldGFLZXk6IG9yaWdpbmFsRXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgIGN0cmxLZXk6IG9yaWdpbmFsRXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgIGFsdEtleTogb3JpZ2luYWxFdmVudC5hbHRLZXlcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IGVuZCA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChvcmlnaW5hbEV2ZW50LCBwb2ludGVyVHlwZSk9PntcbiAgICAgICAgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1KSgpO1xuICAgICAgICBpZiAoc3RhdGUuY3VycmVudC5kaWRNb3ZlKSBvbk1vdmVFbmQgPT09IG51bGwgfHwgb25Nb3ZlRW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk1vdmVFbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJtb3ZlZW5kXCIsXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBzaGlmdEtleTogb3JpZ2luYWxFdmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1ldGFLZXk6IG9yaWdpbmFsRXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgIGN0cmxLZXk6IG9yaWdpbmFsRXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgIGFsdEtleTogb3JpZ2luYWxFdmVudC5hbHRLZXlcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IG1vdmVQcm9wcyA9ICgwLCAkYng3U0wkdXNlTWVtbykoKCk9PntcbiAgICAgICAgbGV0IG1vdmVQcm9wcyA9IHt9O1xuICAgICAgICBsZXQgc3RhcnQgPSAoKT0+e1xuICAgICAgICAgICAgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCQxNmE0Njk3NDY3MTc1NDg3KSgpO1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudC5kaWRNb3ZlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgb25Nb3VzZU1vdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlKGUsIFwibW91c2VcIiwgZS5wYWdlWCAtICgoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYID0gKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiA9IHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbi5wYWdlWCkgIT09IG51bGwgJiYgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYICE9PSB2b2lkIDAgPyBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggOiAwKSwgZS5wYWdlWSAtICgoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZID0gKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEgPSBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbikgPT09IG51bGwgfHwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMS5wYWdlWSkgIT09IG51bGwgJiYgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZICE9PSB2b2lkIDAgPyBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVkgOiAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWTogZS5wYWdlWVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Nb3VzZVVwID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZChlLCBcIm1vdXNlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtb3ZlUHJvcHMub25Nb3VzZURvd24gPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVk6IGUucGFnZVlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uVG91Y2hNb3ZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5lLmNoYW5nZWRUb3VjaGVzXG4gICAgICAgICAgICAgICAgXS5maW5kSW5kZXgoKHsgaWRlbnRpZmllcjogaWRlbnRpZmllciB9KT0+aWRlbnRpZmllciA9PT0gc3RhdGUuY3VycmVudC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcGFnZVg6IHBhZ2VYLCBwYWdlWTogcGFnZVkgfSA9IGUuY2hhbmdlZFRvdWNoZXNbdG91Y2hdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYLCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVk7XG4gICAgICAgICAgICAgICAgICAgIG1vdmUoZSwgXCJ0b3VjaFwiLCBwYWdlWCAtICgoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYID0gKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiA9IHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbi5wYWdlWCkgIT09IG51bGwgJiYgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYICE9PSB2b2lkIDAgPyBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggOiAwKSwgcGFnZVkgLSAoKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSA9IChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xID0gc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24pID09PSBudWxsIHx8IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEucGFnZVkpICE9PSBudWxsICYmIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSAhPT0gdm9pZCAwID8gX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBwYWdlWVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Ub3VjaEVuZCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGxldCB0b3VjaCA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uZS5jaGFuZ2VkVG91Y2hlc1xuICAgICAgICAgICAgICAgIF0uZmluZEluZGV4KCh7IGlkZW50aWZpZXI6IGlkZW50aWZpZXIgfSk9PmlkZW50aWZpZXIgPT09IHN0YXRlLmN1cnJlbnQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0b3VjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZChlLCBcInRvdWNoXCIpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInRvdWNobW92ZVwiLCBvblRvdWNoTW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInRvdWNoY2FuY2VsXCIsIG9uVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtb3ZlUHJvcHMub25Ub3VjaFN0YXJ0ID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSAwIHx8IHN0YXRlLmN1cnJlbnQuaWQgIT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCB7IHBhZ2VYOiBwYWdlWCwgcGFnZVk6IHBhZ2VZLCBpZGVudGlmaWVyOiBpZGVudGlmaWVyIH0gPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6IHBhZ2VZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlkID0gaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwidG91Y2htb3ZlXCIsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwidG91Y2hjYW5jZWxcIiwgb25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBvblBvaW50ZXJNb3ZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUucG9pbnRlcklkID09PSBzdGF0ZS5jdXJyZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24sIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyVHlwZSA9IGUucG9pbnRlclR5cGUgfHwgXCJtb3VzZVwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYLCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2JsZW1zIHdpdGggUG9pbnRlckV2ZW50I21vdmVtZW50WC9tb3ZlbWVudFk6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIGl0IGlzIGFsd2F5cyAwIG9uIG1hY09TIFNhZmFyaS5cbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gT24gQ2hyb21lIEFuZHJvaWQsIGl0J3Mgc2NhbGVkIGJ5IGRldmljZVBpeGVsUmF0aW8sIGJ1dCBub3Qgb24gQ2hyb21lIG1hY09TXG4gICAgICAgICAgICAgICAgICAgIG1vdmUoZSwgcG9pbnRlclR5cGUsIGUucGFnZVggLSAoKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCA9IChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24gPSBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbikgPT09IG51bGwgfHwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24ucGFnZVgpICE9PSBudWxsICYmIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCAhPT0gdm9pZCAwID8gX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYIDogMCksIGUucGFnZVkgLSAoKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSA9IChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xID0gc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24pID09PSBudWxsIHx8IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEucGFnZVkpICE9PSBudWxsICYmIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSAhPT0gdm9pZCAwID8gX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVk6IGUucGFnZVlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uUG9pbnRlclVwID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUucG9pbnRlcklkID09PSBzdGF0ZS5jdXJyZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyVHlwZSA9IGUucG9pbnRlclR5cGUgfHwgXCJtb3VzZVwiO1xuICAgICAgICAgICAgICAgICAgICBlbmQoZSwgcG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcmNhbmNlbFwiLCBvblBvaW50ZXJVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtb3ZlUHJvcHMub25Qb2ludGVyRG93biA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCAmJiBzdGF0ZS5jdXJyZW50LmlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVk6IGUucGFnZVlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5pZCA9IGUucG9pbnRlcklkO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcm1vdmVcIiwgb25Qb2ludGVyTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlclVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHJpZ2dlcktleWJvYXJkTW92ZSA9IChlLCBkZWx0YVgsIGRlbHRhWSk9PntcbiAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgICBtb3ZlKGUsIFwia2V5Ym9hcmRcIiwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICAgICAgZW5kKGUsIFwia2V5Ym9hcmRcIik7XG4gICAgICAgIH07XG4gICAgICAgIG1vdmVQcm9wcy5vbktleURvd24gPSAoZSk9PntcbiAgICAgICAgICAgIHN3aXRjaChlLmtleSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkxlZnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcktleWJvYXJkTW92ZShlLCAtMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJSaWdodFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcktleWJvYXJkTW92ZShlLCAxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlVwXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyS2V5Ym9hcmRNb3ZlKGUsIDAsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkRvd25cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcktleWJvYXJkTW92ZShlLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtb3ZlUHJvcHM7XG4gICAgfSwgW1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyLFxuICAgICAgICBtb3ZlLFxuICAgICAgICBlbmRcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtb3ZlUHJvcHM6IG1vdmVQcm9wc1xuICAgIH07XG59XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ3ZDBhNjM2ZDdhNGRjZWZkJGV4cG9ydCQyMTIzZmYyYjg3YzgxY2EocHJvcHMsIHJlZikge1xuICAgIGxldCB7IG9uU2Nyb2xsOiBvblNjcm9sbCwgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCB9ID0gcHJvcHM7XG4gICAgbGV0IG9uU2Nyb2xsSGFuZGxlciA9ICgwLCAkYng3U0wkdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICAvLyBJZiB0aGUgY3RybEtleSBpcyBwcmVzc2VkLCB0aGlzIGlzIGEgem9vbSBldmVudCwgZG8gbm90aGluZy5cbiAgICAgICAgaWYgKGUuY3RybEtleSkgcmV0dXJuO1xuICAgICAgICAvLyBzdG9wIHNjcm9sbGluZyB0aGUgcGFnZVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmIChvblNjcm9sbCkgb25TY3JvbGwoe1xuICAgICAgICAgICAgZGVsdGFYOiBlLmRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWTogZS5kZWx0YVlcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBvblNjcm9sbFxuICAgIF0pO1xuICAgICgwLCAkYng3U0wkdXNlRXZlbnQpKHJlZiwgXCJ3aGVlbFwiLCBpc0Rpc2FibGVkID8gdW5kZWZpbmVkIDogb25TY3JvbGxIYW5kbGVyKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuY29uc3QgJDhhMjY1NjFkMjg3NzIzNmUkdmFyJERFRkFVTFRfVEhSRVNIT0xEID0gNTAwO1xuZnVuY3Rpb24gJDhhMjY1NjFkMjg3NzIzNmUkZXhwb3J0JGMyNGVkMDEwNGQwN2VhYjkocHJvcHMpIHtcbiAgICBsZXQgeyBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLCBvbkxvbmdQcmVzc1N0YXJ0OiBvbkxvbmdQcmVzc1N0YXJ0LCBvbkxvbmdQcmVzc0VuZDogb25Mb25nUHJlc3NFbmQsIG9uTG9uZ1ByZXNzOiBvbkxvbmdQcmVzcywgdGhyZXNob2xkOiB0aHJlc2hvbGQgPSAkOGEyNjU2MWQyODc3MjM2ZSR2YXIkREVGQVVMVF9USFJFU0hPTEQsIGFjY2Vzc2liaWxpdHlEZXNjcmlwdGlvbjogYWNjZXNzaWJpbGl0eURlc2NyaXB0aW9uIH0gPSBwcm9wcztcbiAgICBjb25zdCB0aW1lUmVmID0gKDAsICRieDdTTCR1c2VSZWYpKCk7XG4gICAgbGV0IHsgYWRkR2xvYmFsTGlzdGVuZXI6IGFkZEdsb2JhbExpc3RlbmVyLCByZW1vdmVHbG9iYWxMaXN0ZW5lcjogcmVtb3ZlR2xvYmFsTGlzdGVuZXIgfSA9ICgwLCAkYng3U0wkdXNlR2xvYmFsTGlzdGVuZXJzKSgpO1xuICAgIGxldCB7IHByZXNzUHJvcHM6IHByZXNzUHJvcHMgfSA9ICgwLCAkZjZjMzFjY2UyYWRmNjU0ZiRleHBvcnQkNDU3MTJlY2VkYTZmYWQyMSkoe1xuICAgICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgICBvblByZXNzU3RhcnQgKGUpIHtcbiAgICAgICAgICAgIGUuY29udGludWVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAob25Mb25nUHJlc3NTdGFydCkgb25Mb25nUHJlc3NTdGFydCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibG9uZ3ByZXNzc3RhcnRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRpbWVSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBvdGhlciB1c2VQcmVzcyBoYW5kbGVycyBmcm9tIGFsc28gaGFuZGxpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgUG9pbnRlckV2ZW50KFwicG9pbnRlcmNhbmNlbFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uTG9uZ1ByZXNzKSBvbkxvbmdQcmVzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJsb25ncHJlc3NcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGltZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0sIHRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBjb250ZXh0IG1lbnUsIHdoaWNoIG1heSBiZSBvcGVuZWQgb24gbG9uZyBwcmVzcyBvbiB0b3VjaCBkZXZpY2VzXG4gICAgICAgICAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25Db250ZXh0TWVudSA9IChlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcihlLnRhcmdldCwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcnVwXCIsICgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBjb250ZXh0bWVudSBldmVudCBpcyBmaXJlZCBxdWlja2x5IGFmdGVyIHBvaW50ZXJ1cCwgcmVtb3ZlIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBmdXR1cmUgY29udGV4dCBtZW51IGV2ZW50cyBvdXRzaWRlIGEgbG9uZyBwcmVzcyBhcmUgbm90IHByZXZlbnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcihlLnRhcmdldCwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMwKTtcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJlc3NFbmQgKGUpIHtcbiAgICAgICAgICAgIGlmICh0aW1lUmVmLmN1cnJlbnQpIGNsZWFyVGltZW91dCh0aW1lUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKG9uTG9uZ1ByZXNzRW5kICYmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSkgb25Mb25nUHJlc3NFbmQoe1xuICAgICAgICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJsb25ncHJlc3NlbmRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgZGVzY3JpcHRpb25Qcm9wcyA9ICgwLCAkYng3U0wkdXNlRGVzY3JpcHRpb24pKG9uTG9uZ1ByZXNzICYmICFpc0Rpc2FibGVkID8gYWNjZXNzaWJpbGl0eURlc2NyaXB0aW9uIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb25nUHJlc3NQcm9wczogKDAsICRieDdTTCRtZXJnZVByb3BzKShwcmVzc1Byb3BzLCBkZXNjcmlwdGlvblByb3BzKVxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDNiMTE3ZTQzZGMwY2E5NWQkZXhwb3J0JDI3YzcwMWVkOWU0NDllOTkgYXMgUHJlc3NhYmxlLCAkZjFhYjhjNzU0NzhjNmY3MyRleHBvcnQkMzM1MTg3MWVlNGIyODhiOCBhcyBQcmVzc1Jlc3BvbmRlciwgJGYxYWI4Yzc1NDc4YzZmNzMkZXhwb3J0JGNmNzU0MjhlMGI5ZWQxZWEgYXMgQ2xlYXJQcmVzc1Jlc3BvbmRlciwgJGExZWE1OWQ2ODI3MGYwZGQkZXhwb3J0JGY4MTY4ZDhkZDhmZDY2ZTYgYXMgdXNlRm9jdXMsICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRiOWIzZGZkZGFiMTdkYjI3IGFzIGlzRm9jdXNWaXNpYmxlLCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkNjMwZmY2NTNjNWFkYTZhOSBhcyBnZXRJbnRlcmFjdGlvbk1vZGFsaXR5LCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkODM5N2RkZmM1MDRmZGI5YSBhcyBzZXRJbnRlcmFjdGlvbk1vZGFsaXR5LCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkOThlMjBlYzkyZjYxNGNmZSBhcyB1c2VJbnRlcmFjdGlvbk1vZGFsaXR5LCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZmZkOWU1MDIxYzFmYjJkNiBhcyB1c2VGb2N1c1Zpc2libGUsICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRlYzcxYjRiODNhYzA4ZWMzIGFzIHVzZUZvY3VzVmlzaWJsZUxpc3RlbmVyLCAkOWFiOTQyNjJiZDAwNDdjNyRleHBvcnQkNDIwZTY4MjczMTY1ZjRlYyBhcyB1c2VGb2N1c1dpdGhpbiwgJDYxNzliOTM2NzA1ZTc2ZDMkZXhwb3J0JGFlNzgwZGFmMjllNmQ0NTYgYXMgdXNlSG92ZXIsICRlMGI2ZTBiNjhlYzdmNTBmJGV4cG9ydCQ4NzJiNjYwYWM1YTFmZjk4IGFzIHVzZUludGVyYWN0T3V0c2lkZSwgJDQ2ZDgxOWZjYmFmMzU2NTQkZXhwb3J0JDhmNzE2NTQ4MDFjMmY3Y2QgYXMgdXNlS2V5Ym9hcmQsICRlOGE3MDIyY2Y4N2NiYTJhJGV4cG9ydCQzNmRhOTYzNzlmNzlmMjQ1IGFzIHVzZU1vdmUsICRmNmMzMWNjZTJhZGY2NTRmJGV4cG9ydCQ0NTcxMmVjZWRhNmZhZDIxIGFzIHVzZVByZXNzLCAkN2QwYTYzNmQ3YTRkY2VmZCRleHBvcnQkMjEyM2ZmMmI4N2M4MWNhIGFzIHVzZVNjcm9sbFdoZWVsLCAkOGEyNjU2MWQyODc3MjM2ZSRleHBvcnQkYzI0ZWQwMTA0ZDA3ZWFiOSBhcyB1c2VMb25nUHJlc3N9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZU9iamVjdFJlZiIsIiRieDdTTCR1c2VPYmplY3RSZWYiLCJtZXJnZVByb3BzIiwiJGJ4N1NMJG1lcmdlUHJvcHMiLCJ1c2VTeW5jUmVmIiwiJGJ4N1NMJHVzZVN5bmNSZWYiLCJ1c2VHbG9iYWxMaXN0ZW5lcnMiLCIkYng3U0wkdXNlR2xvYmFsTGlzdGVuZXJzIiwidXNlRWZmZWN0RXZlbnQiLCIkYng3U0wkdXNlRWZmZWN0RXZlbnQiLCJnZXRPd25lckRvY3VtZW50IiwiJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQiLCJpc01hYyIsIiRieDdTTCRpc01hYyIsIm9wZW5MaW5rIiwiJGJ4N1NMJG9wZW5MaW5rIiwiaXNWaXJ0dWFsQ2xpY2siLCIkYng3U0wkaXNWaXJ0dWFsQ2xpY2siLCJmb2N1c1dpdGhvdXRTY3JvbGxpbmciLCIkYng3U0wkZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwiaXNWaXJ0dWFsUG9pbnRlckV2ZW50IiwiJGJ4N1NMJGlzVmlydHVhbFBvaW50ZXJFdmVudCIsImdldE93bmVyV2luZG93IiwiJGJ4N1NMJGdldE93bmVyV2luZG93IiwiaXNJT1MiLCIkYng3U0wkaXNJT1MiLCJydW5BZnRlclRyYW5zaXRpb24iLCIkYng3U0wkcnVuQWZ0ZXJUcmFuc2l0aW9uIiwidXNlTGF5b3V0RWZmZWN0IiwiJGJ4N1NMJHVzZUxheW91dEVmZmVjdCIsInVzZUV2ZW50IiwiJGJ4N1NMJHVzZUV2ZW50IiwidXNlRGVzY3JpcHRpb24iLCIkYng3U0wkdXNlRGVzY3JpcHRpb24iLCIkYng3U0wkcmVhY3QiLCJ1c2VDb250ZXh0IiwiJGJ4N1NMJHVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsIiRieDdTTCR1c2VTdGF0ZSIsInVzZVJlZiIsIiRieDdTTCR1c2VSZWYiLCJ1c2VNZW1vIiwiJGJ4N1NMJHVzZU1lbW8iLCJ1c2VFZmZlY3QiLCIkYng3U0wkdXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCIkYng3U0wkdXNlQ2FsbGJhY2siLCJfIiwiJGJ4N1NMJF8iLCIkYng3U0wkXzEiLCIkYng3U0wkXzIiLCJ1c2VJc1NTUiIsIiRieDdTTCR1c2VJc1NTUiIsIiQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSIsIiQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzYXZlZFVzZXJTZWxlY3QiLCIkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkbW9kaWZpZWRFbGVtZW50TWFwIiwiV2Vha01hcCIsIiQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCQxNmE0Njk3NDY3MTc1NDg3IiwidGFyZ2V0IiwiZG9jdW1lbnRPYmplY3QiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIndlYmtpdFVzZXJTZWxlY3QiLCJIVE1MRWxlbWVudCIsIlNWR0VsZW1lbnQiLCJzZXQiLCJ1c2VyU2VsZWN0IiwiJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JGIwZDZmYTFhYjMyZTMyOTUiLCJzZXRUaW1lb3V0IiwiaGFzIiwidGFyZ2V0T2xkVXNlclNlbGVjdCIsImdldCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImRlbGV0ZSIsIiRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1IiwiY3JlYXRlQ29udGV4dCIsInJlZ2lzdGVyIiwiZGlzcGxheU5hbWUiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkdXNlUHJlc3NSZXNwb25kZXJDb250ZXh0IiwicHJvcHMiLCJjb250ZXh0IiwiY29udGV4dFByb3BzIiwicmVmIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJF9zaG91bGRTdG9wUHJvcGFnYXRpb24iLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkUHJlc3NFdmVudCIsImNvbnRpbnVlUHJvcGFnYXRpb24iLCJzaG91bGRTdG9wUHJvcGFnYXRpb24iLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJwb2ludGVyVHlwZSIsIm9yaWdpbmFsRXZlbnQiLCJ3cml0YWJsZSIsInZhbHVlIiwiY3VycmVudFRhcmdldCIsInNoaWZ0S2V5IiwibWV0YUtleSIsImN0cmxLZXkiLCJhbHRLZXkiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkTElOS19DTElDS0VEIiwiU3ltYm9sIiwiJGY2YzMxY2NlMmFkZjY1NGYkZXhwb3J0JDQ1NzEyZWNlZGE2ZmFkMjEiLCJvblByZXNzIiwib25QcmVzc0NoYW5nZSIsIm9uUHJlc3NTdGFydCIsIm9uUHJlc3NFbmQiLCJvblByZXNzVXAiLCJpc0Rpc2FibGVkIiwiaXNQcmVzc2VkIiwiaXNQcmVzc2VkUHJvcCIsInByZXZlbnRGb2N1c09uUHJlc3MiLCJzaG91bGRDYW5jZWxPblBvaW50ZXJFeGl0IiwiYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcyIsImRvbVByb3BzIiwic2V0UHJlc3NlZCIsImlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMiLCJpZ25vcmVDbGlja0FmdGVyUHJlc3MiLCJkaWRGaXJlUHJlc3NTdGFydCIsImlzVHJpZ2dlcmluZ0V2ZW50IiwiYWN0aXZlUG9pbnRlcklkIiwiaXNPdmVyVGFyZ2V0IiwiYWRkR2xvYmFsTGlzdGVuZXIiLCJyZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMiLCJ0cmlnZ2VyUHJlc3NTdGFydCIsInN0YXRlIiwiY3VycmVudCIsImV2ZW50IiwidHJpZ2dlclByZXNzRW5kIiwid2FzUHJlc3NlZCIsInRyaWdnZXJQcmVzc1VwIiwiY2FuY2VsIiwiZSIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudCIsImNhbmNlbE9uUG9pbnRlckV4aXQiLCJwcmVzc1Byb3BzIiwib25LZXlEb3duIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRLZXlib2FyZEV2ZW50IiwibmF0aXZlRXZlbnQiLCJjb250YWlucyIsIl9zdGF0ZV9tZXRhS2V5RXZlbnRzIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0S2V5Ym9hcmQiLCJrZXkiLCJwcmV2ZW50RGVmYXVsdCIsInJlcGVhdCIsIm9uS2V5VXAiLCJzdG9wUHJvcGFnYXRpb24iLCJtZXRhS2V5RXZlbnRzIiwiTWFwIiwib25DbGljayIsImJ1dHRvbiIsImlzT3BlbmluZyIsInN0b3BQcmVzc1N0YXJ0Iiwic3RvcFByZXNzVXAiLCJzdG9wUHJlc3NFbmQiLCJfc3RhdGVfbWV0YUtleUV2ZW50czEiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNIVE1MQW5jaG9yTGluayIsInNpemUiLCJfc3RhdGVfdGFyZ2V0IiwiZXZlbnRzIiwidW5kZWZpbmVkIiwidmFsdWVzIiwiZGlzcGF0Y2hFdmVudCIsIktleWJvYXJkRXZlbnQiLCJQb2ludGVyRXZlbnQiLCJvblBvaW50ZXJEb3duIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0IiwicG9pbnRlcklkIiwib25Qb2ludGVyTW92ZSIsIm9uUG9pbnRlclVwIiwib25Qb2ludGVyQ2FuY2VsIiwib25Nb3VzZURvd24iLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0Iiwib25EcmFnU3RhcnQiLCJvbk1vdXNlVXAiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJvblRvdWNoU3RhcnQiLCJ0b3VjaCIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRUb3VjaEZyb21FdmVudCIsImlkZW50aWZpZXIiLCJvblNjcm9sbCIsIm9uVG91Y2hNb3ZlIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFRvdWNoQnlJZCIsIm9uVG91Y2hFbmQiLCJvblRvdWNoQ2FuY2VsIiwiX3JlZl9jdXJyZW50X3RhcmdldCIsInRhZ05hbWUiLCJoYXNBdHRyaWJ1dGUiLCJjb2RlIiwiZWxlbWVudCIsInJvbGUiLCJIVE1MSW5wdXRFbGVtZW50IiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRJbnB1dEtleSIsIkhUTUxUZXh0QXJlYUVsZW1lbnQiLCJpc0NvbnRlbnRFZGl0YWJsZSIsInRhcmdldFRvdWNoZXMiLCJsZW5ndGgiLCJjaGFuZ2VkVG91Y2hlcyIsImkiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0UG9pbnRDbGllbnRSZWN0IiwicG9pbnQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIndpZHRoIiwicmFkaXVzWCIsImhlaWdodCIsInJhZGl1c1kiLCJ0b3AiLCJjbGllbnRZIiwicmlnaHQiLCJjbGllbnRYIiwiYm90dG9tIiwibGVmdCIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRhcmVSZWN0YW5nbGVzT3ZlcmxhcHBpbmciLCJhIiwiYiIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwb2ludFJlY3QiLCJIVE1MQnV0dG9uRWxlbWVudCIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRub25UZXh0SW5wdXRUeXBlcyIsIlNldCIsIiQzYjExN2U0M2RjMGNhOTVkJGV4cG9ydCQyN2M3MDFlZDllNDQ5ZTk5IiwiZm9yd2FyZFJlZiIsImNoaWxkcmVuIiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJjbG9uZUVsZW1lbnQiLCIkZjFhYjhjNzU0NzhjNmY3MyRleHBvcnQkMzM1MTg3MWVlNGIyODhiOCIsImlzUmVnaXN0ZXJlZCIsInByZXZDb250ZXh0IiwiY29uc29sZSIsIndhcm4iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCIkZjFhYjhjNzU0NzhjNmY3MyRleHBvcnQkY2Y3NTQyOGUwYjllZDFlYSIsIiQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ5MDVlN2ZjNTQ0YTcxZjM2IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwicGVyc2lzdCIsInJlbGF0ZWRUYXJnZXQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImV2ZW50UGhhc2UiLCJpc1RydXN0ZWQiLCJ0aW1lU3RhbXAiLCIkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkNzE1YzY4MmQwOWQ2MzljYyIsIm9uQmx1ciIsInN0YXRlUmVmIiwiaXNGb2N1c2VkIiwib2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiZGlzcGF0Y2hCbHVyIiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJvbkJsdXJIYW5kbGVyIiwiZGlzYWJsZWQiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJfc3RhdGVSZWZfY3VycmVudF9vYnNlcnZlciIsInJlbGF0ZWRUYXJnZXRFbCIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsIkZvY3VzRXZlbnQiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZUZpbHRlciIsIiRhMWVhNTlkNjgyNzBmMGRkJGV4cG9ydCRmODE2OGQ4ZGQ4ZmQ2NmU2Iiwib25Gb2N1cyIsIm9uRm9jdXNQcm9wIiwib25CbHVyUHJvcCIsIm9uRm9jdXNDaGFuZ2UiLCJvblN5bnRoZXRpY0ZvY3VzIiwiZm9jdXNQcm9wcyIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY2hhbmdlSGFuZGxlcnMiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzU2V0dXBHbG9iYWxMaXN0ZW5lcnMiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNCbHVycmVkV2luZG93UmVjZW50bHkiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkRk9DVVNfVklTSUJMRV9JTlBVVF9LRVlTIiwiVGFiIiwiRXNjYXBlIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHRyaWdnZXJDaGFuZ2VIYW5kbGVycyIsIm1vZGFsaXR5IiwiaGFuZGxlciIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRpc1ZhbGlkS2V5IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUtleWJvYXJkRXZlbnQiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUNsaWNrRXZlbnQiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlRm9jdXNFdmVudCIsIndpbmRvdyIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVXaW5kb3dCbHVyIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMiLCJmb2N1cyIsInByb3RvdHlwZSIsImFwcGx5IiwiYXJndW1lbnRzIiwicmVhZHlTdGF0ZSIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRiOWIzZGZkZGFiMTdkYjI3IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDYzMGZmNjUzYzVhZGE2YTkiLCIkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkODM5N2RkZmM1MDRmZGI5YSIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ5OGUyMGVjOTJmNjE0Y2ZlIiwic2V0TW9kYWxpdHkiLCJhZGQiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkbm9uVGV4dElucHV0VHlwZXMiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNLZXlib2FyZEZvY3VzRXZlbnQiLCJpc1RleHRJbnB1dCIsIl9lX3RhcmdldCIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRmZmQ5ZTUwMjFjMWZiMmQ2IiwiYXV0b0ZvY3VzIiwiaXNGb2N1c1Zpc2libGVTdGF0ZSIsInNldEZvY3VzVmlzaWJsZSIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRlYzcxYjRiODNhYzA4ZWMzIiwiaXNGb2N1c1Zpc2libGUiLCJmbiIsImRlcHMiLCJvcHRzIiwiJDlhYjk0MjYyYmQwMDQ3YzckZXhwb3J0JDQyMGU2ODI3MzE2NWY0ZWMiLCJvbkJsdXJXaXRoaW4iLCJvbkZvY3VzV2l0aGluIiwib25Gb2N1c1dpdGhpbkNoYW5nZSIsImlzRm9jdXNXaXRoaW4iLCJmb2N1c1dpdGhpblByb3BzIiwiJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMiLCIkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudCIsIiQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzIiwiJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhhbmRsZUdsb2JhbFBvaW50ZXJFdmVudCIsIiQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXR1cEdsb2JhbFRvdWNoRXZlbnRzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIiQ2MTc5YjkzNjcwNWU3NmQzJGV4cG9ydCRhZTc4MGRhZjI5ZTZkNDU2Iiwib25Ib3ZlclN0YXJ0Iiwib25Ib3ZlckNoYW5nZSIsIm9uSG92ZXJFbmQiLCJpc0hvdmVyZWQiLCJzZXRIb3ZlcmVkIiwiaG92ZXJQcm9wcyIsInRyaWdnZXJIb3ZlckVuZCIsInRyaWdnZXJIb3ZlclN0YXJ0Iiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsIiRlMGI2ZTBiNjhlYzdmNTBmJGV4cG9ydCQ4NzJiNjYwYWM1YTFmZjk4Iiwib25JbnRlcmFjdE91dHNpZGUiLCJvbkludGVyYWN0T3V0c2lkZVN0YXJ0IiwiaXNQb2ludGVyRG93biIsIiRlMGI2ZTBiNjhlYzdmNTBmJHZhciRpc1ZhbGlkRXZlbnQiLCJ0cmlnZ2VySW50ZXJhY3RPdXRzaWRlIiwib3duZXJEb2N1bWVudCIsImNsb3Nlc3QiLCIkOTM5MjUwODNlY2JiMzU4YyRleHBvcnQkNDhkMWVhNjMyMDgzMDI2MCIsImVycm9yIiwiJDQ2ZDgxOWZjYmFmMzU2NTQkZXhwb3J0JDhmNzE2NTQ4MDFjMmY3Y2QiLCJrZXlib2FyZFByb3BzIiwiJGU4YTcwMjJjZjg3Y2JhMmEkZXhwb3J0JDM2ZGE5NjM3OWY3OWYyNDUiLCJvbk1vdmVTdGFydCIsIm9uTW92ZSIsIm9uTW92ZUVuZCIsImRpZE1vdmUiLCJsYXN0UG9zaXRpb24iLCJpZCIsInJlbW92ZUdsb2JhbExpc3RlbmVyIiwibW92ZSIsImRlbHRhWCIsImRlbHRhWSIsImVuZCIsIm1vdmVQcm9wcyIsInN0YXJ0Iiwib25Nb3VzZU1vdmUiLCJfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24iLCJfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xIiwiX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYIiwiX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZIiwicGFnZVgiLCJwYWdlWSIsImZpbmRJbmRleCIsInRyaWdnZXJLZXlib2FyZE1vdmUiLCIkN2QwYTYzNmQ3YTRkY2VmZCRleHBvcnQkMjEyM2ZmMmI4N2M4MWNhIiwib25TY3JvbGxIYW5kbGVyIiwiJDhhMjY1NjFkMjg3NzIzNmUkdmFyJERFRkFVTFRfVEhSRVNIT0xEIiwiJDhhMjY1NjFkMjg3NzIzNmUkZXhwb3J0JGMyNGVkMDEwNGQwN2VhYjkiLCJvbkxvbmdQcmVzc1N0YXJ0Iiwib25Mb25nUHJlc3NFbmQiLCJvbkxvbmdQcmVzcyIsInRocmVzaG9sZCIsImFjY2Vzc2liaWxpdHlEZXNjcmlwdGlvbiIsInRpbWVSZWYiLCJvbkNvbnRleHRNZW51IiwiY2xlYXJUaW1lb3V0IiwiZGVzY3JpcHRpb25Qcm9wcyIsImxvbmdQcmVzc1Byb3BzIiwiUHJlc3NhYmxlIiwiUHJlc3NSZXNwb25kZXIiLCJDbGVhclByZXNzUmVzcG9uZGVyIiwidXNlRm9jdXMiLCJnZXRJbnRlcmFjdGlvbk1vZGFsaXR5Iiwic2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSIsInVzZUludGVyYWN0aW9uTW9kYWxpdHkiLCJ1c2VGb2N1c1Zpc2libGUiLCJ1c2VGb2N1c1Zpc2libGVMaXN0ZW5lciIsInVzZUZvY3VzV2l0aGluIiwidXNlSG92ZXIiLCJ1c2VJbnRlcmFjdE91dHNpZGUiLCJ1c2VLZXlib2FyZCIsInVzZU1vdmUiLCJ1c2VQcmVzcyIsInVzZVNjcm9sbFdoZWVsIiwidXNlTG9uZ1ByZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/interactions/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/import.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/import.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RouterProvider: () => (/* binding */ $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb),\n/* harmony export */   chain: () => (/* binding */ $ff5963eb1fccf552$export$e08e3b67e392101e),\n/* harmony export */   clamp: () => (/* reexport safe */ _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.clamp),\n/* harmony export */   filterDOMProps: () => (/* binding */ $65484d02dcb7eb3e$export$457c3d6518dd4c6f),\n/* harmony export */   focusWithoutScrolling: () => (/* binding */ $7215afc6de606d6b$export$de79e2c695e052f3),\n/* harmony export */   getOffset: () => (/* binding */ $ab71dadb03a6fb2e$export$622cea445a1c5b7d),\n/* harmony export */   getOwnerDocument: () => (/* binding */ $431fbd86ca7dc216$export$b204af158042fbac),\n/* harmony export */   getOwnerWindow: () => (/* binding */ $431fbd86ca7dc216$export$f21a1ffae260145a),\n/* harmony export */   getScrollParent: () => (/* binding */ $62d8ded9296f3872$export$cfa2225e87938781),\n/* harmony export */   getSyntheticLinkProps: () => (/* binding */ $ea8dcbcb9ea1b556$export$51437d503373d223),\n/* harmony export */   isAndroid: () => (/* binding */ $c87311424ea30a05$export$a11b0059900ceec8),\n/* harmony export */   isAppleDevice: () => (/* binding */ $c87311424ea30a05$export$e1865c3bedcd822b),\n/* harmony export */   isChrome: () => (/* binding */ $c87311424ea30a05$export$6446a186d09e379e),\n/* harmony export */   isIOS: () => (/* binding */ $c87311424ea30a05$export$fedb369cb70207f1),\n/* harmony export */   isIPad: () => (/* binding */ $c87311424ea30a05$export$7bef049ce92e4224),\n/* harmony export */   isIPhone: () => (/* binding */ $c87311424ea30a05$export$186c6964ca17d99),\n/* harmony export */   isMac: () => (/* binding */ $c87311424ea30a05$export$9ac100e40613ea10),\n/* harmony export */   isScrollable: () => (/* binding */ $62d8ded9296f3872$export$2bb74740c4e19def),\n/* harmony export */   isVirtualClick: () => (/* binding */ $6a7db85432448f7f$export$60278871457622de),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ $6a7db85432448f7f$export$29bf1b5f2c56cf63),\n/* harmony export */   isWebKit: () => (/* binding */ $c87311424ea30a05$export$78551043582a6a98),\n/* harmony export */   mergeIds: () => (/* binding */ $bdb11010cef70236$export$cd8c9cb68f842629),\n/* harmony export */   mergeProps: () => (/* binding */ $3ef42575df84b30b$export$9d1611c77c2fe928),\n/* harmony export */   mergeRefs: () => (/* binding */ $5dc95899b306f630$export$c9058316764c140e),\n/* harmony export */   openLink: () => (/* binding */ $ea8dcbcb9ea1b556$export$95185d699e05d4d7),\n/* harmony export */   runAfterTransition: () => (/* binding */ $bbed8b41f857bcc0$export$24490316f764c430),\n/* harmony export */   scrollIntoView: () => (/* binding */ $2f04cbc44ee30ce0$export$53a0910f038337bd),\n/* harmony export */   scrollIntoViewport: () => (/* binding */ $2f04cbc44ee30ce0$export$c826860796309d1b),\n/* harmony export */   shouldClientNavigate: () => (/* binding */ $ea8dcbcb9ea1b556$export$efa8c9099e530235),\n/* harmony export */   snapValueToStep: () => (/* reexport safe */ _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.snapValueToStep),\n/* harmony export */   useDeepMemo: () => (/* binding */ $5a387cc49350e6db$export$722debc0e56fea39),\n/* harmony export */   useDescription: () => (/* binding */ $ef06256079686ba0$export$f8aeda7b10753fa1),\n/* harmony export */   useDrag1D: () => (/* binding */ $9cc09df9fd7676be$export$7bbed75feba39706),\n/* harmony export */   useEffectEvent: () => (/* binding */ $8ae05eaa5c114e9c$export$7f54fc3180508a52),\n/* harmony export */   useEvent: () => (/* binding */ $e9faafb641e167db$export$90fc3a17d93f704c),\n/* harmony export */   useFormReset: () => (/* binding */ $99facab73266f662$export$5add1d006293d136),\n/* harmony export */   useGlobalListeners: () => (/* binding */ $03deb23ff14920c4$export$4eaf04e54aa8eed6),\n/* harmony export */   useId: () => (/* binding */ $bdb11010cef70236$export$f680877a34711e37),\n/* harmony export */   useLabels: () => (/* binding */ $313b98861ee5dd6c$export$d6875122194c7b44),\n/* harmony export */   useLayoutEffect: () => (/* binding */ $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c),\n/* harmony export */   useObjectRef: () => (/* binding */ $df56164dff5785e2$export$4338b53315abf666),\n/* harmony export */   useResizeObserver: () => (/* binding */ $9daab02d461809db$export$683480f191c0e3ea),\n/* harmony export */   useRouter: () => (/* binding */ $ea8dcbcb9ea1b556$export$9a302a45f65d0572),\n/* harmony export */   useSlotId: () => (/* binding */ $bdb11010cef70236$export$b4cc09c592e8fdb8),\n/* harmony export */   useSyncRef: () => (/* binding */ $e7801be82b4b2a53$export$4debdb1a3f0fa79e),\n/* harmony export */   useUpdateEffect: () => (/* binding */ $4f58c5f72bcf79f7$export$496315a1608d9602),\n/* harmony export */   useValueEffect: () => (/* binding */ $1dbecbe27a04f9af$export$14d238f342723f25),\n/* harmony export */   useViewportSize: () => (/* binding */ $5df64b3807dc15ee$export$d699905dd57c73ca)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-aria/interactions/node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/./node_modules/@react-aria/ssr/dist/import.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/@react-aria/interactions/node_modules/clsx/dist/clsx.m.js\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== \"undefined\" ? (0, react__WEBPACK_IMPORTED_MODULE_0__).useLayoutEffect : ()=>{};\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {\n    const ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        ref.current = fn;\n    }, [\n        fn\n    ]);\n    // @ts-ignore\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        const f = ref.current;\n        return f(...args);\n    }, []);\n}\nfunction $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {\n    let [value1, setValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue);\n    let effect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Store the function in a ref so we can always access the current version\n    // which has the proper `value` in scope.\n    let nextRef = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{\n        // Run the generator to the next yield.\n        let newValue = effect.current.next();\n        // If the generator is done, reset the effect.\n        if (newValue.done) {\n            effect.current = null;\n            return;\n        }\n        // If the value is the same as the current value,\n        // then continue to the next yield. Otherwise,\n        // set the value in state and wait for the next layout effect.\n        if (value1 === newValue.value) nextRef();\n        else setValue(newValue.value);\n    });\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        // If there is an effect currently running, continue to the next yield.\n        if (effect.current) nextRef();\n    });\n    let queue = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((fn)=>{\n        effect.current = fn(value1);\n        nextRef();\n    });\n    return [\n        value1,\n        queue\n    ];\n}\n// copied from SSRProvider.tsx to reduce exports, if needed again, consider sharing\nlet $bdb11010cef70236$var$canUseDOM = Boolean( false && 0);\nlet $bdb11010cef70236$var$idsUpdaterMap = new Map();\nfunction $bdb11010cef70236$export$f680877a34711e37(defaultId) {\n    let [value1, setValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultId);\n    let nextId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let res = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__.useSSRSafeId)(value1);\n    let updateValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((val)=>{\n        nextId.current = val;\n    }, []);\n    if ($bdb11010cef70236$var$canUseDOM) $bdb11010cef70236$var$idsUpdaterMap.set(res, updateValue);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        let r = res;\n        return ()=>{\n            $bdb11010cef70236$var$idsUpdaterMap.delete(r);\n        };\n    }, [\n        res\n    ]);\n    // This cannot cause an infinite loop because the ref is updated first.\n    // eslint-disable-next-line\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let newId = nextId.current;\n        if (newId) {\n            nextId.current = null;\n            setValue(newId);\n        }\n    });\n    return res;\n}\nfunction $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {\n    if (idA === idB) return idA;\n    let setIdA = $bdb11010cef70236$var$idsUpdaterMap.get(idA);\n    if (setIdA) {\n        setIdA(idB);\n        return idB;\n    }\n    let setIdB = $bdb11010cef70236$var$idsUpdaterMap.get(idB);\n    if (setIdB) {\n        setIdB(idA);\n        return idA;\n    }\n    return idB;\n}\nfunction $bdb11010cef70236$export$b4cc09c592e8fdb8(depArray = []) {\n    let id = $bdb11010cef70236$export$f680877a34711e37();\n    let [resolvedId, setResolvedId] = (0, $1dbecbe27a04f9af$export$14d238f342723f25)(id);\n    let updateId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResolvedId(function*() {\n            yield id;\n            yield document.getElementById(id) ? id : undefined;\n        });\n    }, [\n        id,\n        setResolvedId\n    ]);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updateId, [\n        id,\n        updateId,\n        ...depArray\n    ]);\n    return resolvedId;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Calls all functions in the order they were chained with the same arguments.\n */ function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks) {\n    return (...args)=>{\n        for (let callback of callbacks)if (typeof callback === \"function\") callback(...args);\n    };\n}\nconst $431fbd86ca7dc216$export$b204af158042fbac = (el)=>{\n    var _el_ownerDocument;\n    return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;\n};\nconst $431fbd86ca7dc216$export$f21a1ffae260145a = (el)=>{\n    if (el && \"window\" in el && el.window === el) return el;\n    const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);\n    return doc.defaultView || window;\n};\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $3ef42575df84b30b$export$9d1611c77c2fe928(...args) {\n    // Start with a base clone of the first argument. This is a lot faster than starting\n    // with an empty object and adding properties as we go.\n    let result = {\n        ...args[0]\n    };\n    for(let i = 1; i < args.length; i++){\n        let props = args[i];\n        for(let key in props){\n            let a = result[key];\n            let b = props[key];\n            // Chain events\n            if (typeof a === \"function\" && typeof b === \"function\" && // This is a lot faster than a regex.\n            key[0] === \"o\" && key[1] === \"n\" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a, b);\n            else if ((key === \"className\" || key === \"UNSAFE_className\") && typeof a === \"string\" && typeof b === \"string\") result[key] = (0, clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a, b);\n            else if (key === \"id\" && a && b) result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a, b);\n            else result[key] = b !== undefined ? b : a;\n        }\n    }\n    return result;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $5dc95899b306f630$export$c9058316764c140e(...refs) {\n    if (refs.length === 1) return refs[0];\n    return (value1)=>{\n        for (let ref of refs){\n            if (typeof ref === \"function\") ref(value1);\n            else if (ref != null) ref.current = value1;\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $65484d02dcb7eb3e$var$DOMPropNames = new Set([\n    \"id\"\n]);\nconst $65484d02dcb7eb3e$var$labelablePropNames = new Set([\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-describedby\",\n    \"aria-details\"\n]);\n// See LinkDOMProps in dom.d.ts.\nconst $65484d02dcb7eb3e$var$linkPropNames = new Set([\n    \"href\",\n    \"target\",\n    \"rel\",\n    \"download\",\n    \"ping\",\n    \"referrerPolicy\"\n]);\nconst $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;\nfunction $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {}) {\n    let { labelable: labelable, isLink: isLink, propNames: propNames } = opts;\n    let filteredProps = {};\n    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || isLink && $65484d02dcb7eb3e$var$linkPropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop))) filteredProps[prop] = props[prop];\n    return filteredProps;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $7215afc6de606d6b$export$de79e2c695e052f3(element) {\n    if ($7215afc6de606d6b$var$supportsPreventScroll()) element.focus({\n        preventScroll: true\n    });\n    else {\n        let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);\n        element.focus();\n        $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);\n    }\n}\nlet $7215afc6de606d6b$var$supportsPreventScrollCached = null;\nfunction $7215afc6de606d6b$var$supportsPreventScroll() {\n    if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {\n        $7215afc6de606d6b$var$supportsPreventScrollCached = false;\n        try {\n            var focusElem = document.createElement(\"div\");\n            focusElem.focus({\n                get preventScroll () {\n                    $7215afc6de606d6b$var$supportsPreventScrollCached = true;\n                    return true;\n                }\n            });\n        } catch (e) {\n        // Ignore\n        }\n    }\n    return $7215afc6de606d6b$var$supportsPreventScrollCached;\n}\nfunction $7215afc6de606d6b$var$getScrollableElements(element) {\n    var parent = element.parentNode;\n    var scrollableElements = [];\n    var rootScrollingElement = document.scrollingElement || document.documentElement;\n    while(parent instanceof HTMLElement && parent !== rootScrollingElement){\n        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({\n            element: parent,\n            scrollTop: parent.scrollTop,\n            scrollLeft: parent.scrollLeft\n        });\n        parent = parent.parentNode;\n    }\n    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({\n        element: rootScrollingElement,\n        scrollTop: rootScrollingElement.scrollTop,\n        scrollLeft: rootScrollingElement.scrollLeft\n    });\n    return scrollableElements;\n}\nfunction $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {\n    for (let { element: element, scrollTop: scrollTop, scrollLeft: scrollLeft } of scrollableElements){\n        element.scrollTop = scrollTop;\n        element.scrollLeft = scrollLeft;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $ab71dadb03a6fb2e$export$622cea445a1c5b7d(element, reverse, orientation = \"horizontal\") {\n    let rect = element.getBoundingClientRect();\n    if (reverse) return orientation === \"horizontal\" ? rect.right : rect.bottom;\n    return orientation === \"horizontal\" ? rect.left : rect.top;\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c87311424ea30a05$var$testUserAgent(re) {\n    var _window_navigator_userAgentData;\n    if (true) return false;\n    return ((_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);\n}\nfunction $c87311424ea30a05$var$testPlatform(re) {\n    var _window_navigator_userAgentData;\n    return  false ? 0 : false;\n}\nfunction $c87311424ea30a05$export$9ac100e40613ea10() {\n    return $c87311424ea30a05$var$testPlatform(/^Mac/i);\n}\nfunction $c87311424ea30a05$export$186c6964ca17d99() {\n    return $c87311424ea30a05$var$testPlatform(/^iPhone/i);\n}\nfunction $c87311424ea30a05$export$7bef049ce92e4224() {\n    return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;\n}\nfunction $c87311424ea30a05$export$fedb369cb70207f1() {\n    return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();\n}\nfunction $c87311424ea30a05$export$e1865c3bedcd822b() {\n    return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();\n}\nfunction $c87311424ea30a05$export$78551043582a6a98() {\n    return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();\n}\nfunction $c87311424ea30a05$export$6446a186d09e379e() {\n    return $c87311424ea30a05$var$testUserAgent(/Chrome/i);\n}\nfunction $c87311424ea30a05$export$a11b0059900ceec8() {\n    return $c87311424ea30a05$var$testUserAgent(/Android/i);\n}\nfunction $c87311424ea30a05$export$b7d78993b74f766d() {\n    return $c87311424ea30a05$var$testUserAgent(/Firefox/i);\n}\nconst $ea8dcbcb9ea1b556$var$RouterContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    isNative: true,\n    open: $ea8dcbcb9ea1b556$var$openSyntheticLink\n});\nfunction $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb(props) {\n    let { children: children, navigate: navigate } = props;\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            isNative: false,\n            open: (target, modifiers)=>{\n                $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>{\n                    if ($ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers)) navigate(link.pathname + link.search + link.hash);\n                    else $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers);\n                });\n            }\n        }), [\n        navigate\n    ]);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($ea8dcbcb9ea1b556$var$RouterContext.Provider, {\n        value: ctx\n    }, children);\n}\nfunction $ea8dcbcb9ea1b556$export$9a302a45f65d0572() {\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($ea8dcbcb9ea1b556$var$RouterContext);\n}\nfunction $ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers) {\n    // Use getAttribute here instead of link.target. Firefox will default link.target to \"_parent\" when inside an iframe.\n    let target = link.getAttribute(\"target\");\n    return (!target || target === \"_self\") && link.origin === location.origin && !link.hasAttribute(\"download\") && !modifiers.metaKey && // open in new tab (mac)\n    !modifiers.ctrlKey && // open in new tab (windows)\n    !modifiers.altKey && // download\n    !modifiers.shiftKey;\n}\nfunction $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {\n    var _window_event_type, _window_event;\n    let { metaKey: metaKey, ctrlKey: ctrlKey, altKey: altKey, shiftKey: shiftKey } = modifiers;\n    // Firefox does not recognize keyboard events as a user action by default, and the popup blocker\n    // will prevent links with target=\"_blank\" from opening. However, it does allow the event if the\n    // Command/Control key is held, which opens the link in a background tab. This seems like the best we can do.\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=257870 and https://bugzilla.mozilla.org/show_bug.cgi?id=746640.\n    if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith(\"key\")) && target.target === \"_blank\") {\n        if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) metaKey = true;\n        else ctrlKey = true;\n    }\n    // WebKit does not support firing click events with modifier keys, but does support keyboard events.\n    // https://github.com/WebKit/WebKit/blob/c03d0ac6e6db178f90923a0a63080b5ca210d25f/Source/WebCore/html/HTMLAnchorElement.cpp#L184\n    let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent(\"keydown\", {\n        keyIdentifier: \"Enter\",\n        metaKey: metaKey,\n        ctrlKey: ctrlKey,\n        altKey: altKey,\n        shiftKey: shiftKey\n    }) : new MouseEvent(\"click\", {\n        metaKey: metaKey,\n        ctrlKey: ctrlKey,\n        altKey: altKey,\n        shiftKey: shiftKey,\n        bubbles: true,\n        cancelable: true\n    });\n    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;\n    (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);\n    target.dispatchEvent(event);\n    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;\n}\n// https://github.com/parcel-bundler/parcel/issues/8724\n$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;\nfunction $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open) {\n    if (target instanceof HTMLAnchorElement) open(target);\n    else if (target.hasAttribute(\"data-href\")) {\n        let link = document.createElement(\"a\");\n        link.href = target.getAttribute(\"data-href\");\n        if (target.hasAttribute(\"data-target\")) link.target = target.getAttribute(\"data-target\");\n        if (target.hasAttribute(\"data-rel\")) link.rel = target.getAttribute(\"data-rel\");\n        if (target.hasAttribute(\"data-download\")) link.download = target.getAttribute(\"data-download\");\n        if (target.hasAttribute(\"data-ping\")) link.ping = target.getAttribute(\"data-ping\");\n        if (target.hasAttribute(\"data-referrer-policy\")) link.referrerPolicy = target.getAttribute(\"data-referrer-policy\");\n        target.appendChild(link);\n        open(link);\n        target.removeChild(link);\n    }\n}\nfunction $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {\n    $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>$ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers));\n}\nfunction $ea8dcbcb9ea1b556$export$51437d503373d223(props) {\n    return {\n        \"data-href\": props.href,\n        \"data-target\": props.target,\n        \"data-rel\": props.rel,\n        \"data-download\": props.download,\n        \"data-ping\": props.ping,\n        \"data-referrer-policy\": props.referrerPolicy\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet $bbed8b41f857bcc0$var$transitionsByElement = new Map();\n// A list of callbacks to call once there are no transitioning elements.\nlet $bbed8b41f857bcc0$var$transitionCallbacks = new Set();\nfunction $bbed8b41f857bcc0$var$setupGlobalEvents() {\n    if (true) return;\n    let onTransitionStart = (e)=>{\n        // Add the transitioning property to the list for this element.\n        let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!transitions) {\n            transitions = new Set();\n            $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions);\n            // The transitioncancel event must be registered on the element itself, rather than as a global\n            // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n            e.target.addEventListener(\"transitioncancel\", onTransitionEnd);\n        }\n        transitions.add(e.propertyName);\n    };\n    let onTransitionEnd = (e)=>{\n        // Remove property from list of transitioning properties.\n        let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!properties) return;\n        properties.delete(e.propertyName);\n        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n        if (properties.size === 0) {\n            e.target.removeEventListener(\"transitioncancel\", onTransitionEnd);\n            $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);\n        }\n        // If no transitioning elements, call all of the queued callbacks.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {\n            for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)cb();\n            $bbed8b41f857bcc0$var$transitionCallbacks.clear();\n        }\n    };\n    document.body.addEventListener(\"transitionrun\", onTransitionStart);\n    document.body.addEventListener(\"transitionend\", onTransitionEnd);\n}\nif (typeof document !== \"undefined\") {\n    if (document.readyState !== \"loading\") $bbed8b41f857bcc0$var$setupGlobalEvents();\n    else document.addEventListener(\"DOMContentLoaded\", $bbed8b41f857bcc0$var$setupGlobalEvents);\n}\nfunction $bbed8b41f857bcc0$export$24490316f764c430(fn) {\n    // Wait one frame to see if an animation starts, e.g. a transition on mount.\n    requestAnimationFrame(()=>{\n        // If no transitions are running, call the function immediately.\n        // Otherwise, add it to a list of callbacks to run at the end of the animation.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();\n        else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);\n    });\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /* eslint-disable rulesdir/pure-render */ // Keep track of elements that we are currently handling dragging for via useDrag1D.\n// If there's an ancestor and a descendant both using useDrag1D(), and the user starts\n// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.\nconst $9cc09df9fd7676be$var$draggingElements = [];\nfunction $9cc09df9fd7676be$export$7bbed75feba39706(props) {\n    console.warn(\"useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html\");\n    let { containerRef: containerRef, reverse: reverse, orientation: orientation, onHover: onHover, onDrag: onDrag, onPositionChange: onPositionChange, onIncrement: onIncrement, onDecrement: onDecrement, onIncrementToMax: onIncrementToMax, onDecrementToMin: onDecrementToMin, onCollapseToggle: onCollapseToggle } = props;\n    let getPosition = (e)=>orientation === \"horizontal\" ? e.clientX : e.clientY;\n    let getNextOffset = (e)=>{\n        let containerOffset = (0, $ab71dadb03a6fb2e$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);\n        let mouseOffset = getPosition(e);\n        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;\n        return nextOffset;\n    };\n    let dragging = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let prevPosition = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Keep track of the current handlers in a ref so that the events can access them.\n    let handlers = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        onPositionChange: onPositionChange,\n        onDrag: onDrag\n    });\n    handlers.current.onDrag = onDrag;\n    handlers.current.onPositionChange = onPositionChange;\n    let onMouseDragged = (e)=>{\n        e.preventDefault();\n        let nextOffset = getNextOffset(e);\n        if (!dragging.current) {\n            dragging.current = true;\n            if (handlers.current.onDrag) handlers.current.onDrag(true);\n            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        }\n        if (prevPosition.current === nextOffset) return;\n        prevPosition.current = nextOffset;\n        if (onPositionChange) onPositionChange(nextOffset);\n    };\n    let onMouseUp = (e)=>{\n        const target = e.target;\n        dragging.current = false;\n        let nextOffset = getNextOffset(e);\n        if (handlers.current.onDrag) handlers.current.onDrag(false);\n        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        $9cc09df9fd7676be$var$draggingElements.splice($9cc09df9fd7676be$var$draggingElements.indexOf(target), 1);\n        window.removeEventListener(\"mouseup\", onMouseUp, false);\n        window.removeEventListener(\"mousemove\", onMouseDragged, false);\n    };\n    let onMouseDown = (e)=>{\n        const target = e.currentTarget;\n        // If we're already handling dragging on a descendant with useDrag1D, then\n        // we don't want to handle the drag motion on this target as well.\n        if ($9cc09df9fd7676be$var$draggingElements.some((elt)=>target.contains(elt))) return;\n        $9cc09df9fd7676be$var$draggingElements.push(target);\n        window.addEventListener(\"mousemove\", onMouseDragged, false);\n        window.addEventListener(\"mouseup\", onMouseUp, false);\n    };\n    let onMouseEnter = ()=>{\n        if (onHover) onHover(true);\n    };\n    let onMouseOut = ()=>{\n        if (onHover) onHover(false);\n    };\n    let onKeyDown = (e)=>{\n        switch(e.key){\n            case \"Left\":\n            case \"ArrowLeft\":\n                if (orientation === \"horizontal\") {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case \"Up\":\n            case \"ArrowUp\":\n                if (orientation === \"vertical\") {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case \"Right\":\n            case \"ArrowRight\":\n                if (orientation === \"horizontal\") {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case \"Down\":\n            case \"ArrowDown\":\n                if (orientation === \"vertical\") {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case \"Home\":\n                e.preventDefault();\n                if (onDecrementToMin) onDecrementToMin();\n                break;\n            case \"End\":\n                e.preventDefault();\n                if (onIncrementToMax) onIncrementToMax();\n                break;\n            case \"Enter\":\n                e.preventDefault();\n                if (onCollapseToggle) onCollapseToggle();\n                break;\n        }\n    };\n    return {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        onKeyDown: onKeyDown\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {\n    let globalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let addGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        // Make sure we remove the listener after it is called with the `once` option.\n        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{\n            globalListeners.current.delete(listener);\n            listener(...args);\n        } : listener;\n        globalListeners.current.set(listener, {\n            type: type,\n            eventTarget: eventTarget,\n            fn: fn,\n            options: options\n        });\n        eventTarget.addEventListener(type, listener, options);\n    }, []);\n    let removeGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        var _globalListeners_current_get;\n        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;\n        eventTarget.removeEventListener(type, fn, options);\n        globalListeners.current.delete(listener);\n    }, []);\n    let removeAllGlobalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        globalListeners.current.forEach((value1, key)=>{\n            removeGlobalListener(value1.eventTarget, value1.type, key, value1.options);\n        });\n    }, [\n        removeGlobalListener\n    ]);\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return removeAllGlobalListeners;\n    }, [\n        removeAllGlobalListeners\n    ]);\n    return {\n        addGlobalListener: addGlobalListener,\n        removeGlobalListener: removeGlobalListener,\n        removeAllGlobalListeners: removeAllGlobalListeners\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $313b98861ee5dd6c$export$d6875122194c7b44(props, defaultLabel) {\n    let { id: id, \"aria-label\": label, \"aria-labelledby\": labelledBy } = props;\n    // If there is both an aria-label and aria-labelledby,\n    // combine them by pointing to the element itself.\n    id = (0, $bdb11010cef70236$export$f680877a34711e37)(id);\n    if (labelledBy && label) {\n        let ids = new Set([\n            id,\n            ...labelledBy.trim().split(/\\s+/)\n        ]);\n        labelledBy = [\n            ...ids\n        ].join(\" \");\n    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\\s+/).join(\" \");\n    // If no labels are provided, use the default\n    if (!label && !labelledBy && defaultLabel) label = defaultLabel;\n    return {\n        id: id,\n        \"aria-label\": label,\n        \"aria-labelledby\": labelledBy\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {\n    const objRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            get current () {\n                return objRef.current;\n            },\n            set current (value){\n                objRef.current = value;\n                if (typeof forwardedRef === \"function\") forwardedRef(value);\n                else if (forwardedRef) forwardedRef.current = value;\n            }\n        }), [\n        forwardedRef\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $4f58c5f72bcf79f7$export$496315a1608d9602(effect, dependencies) {\n    const isInitialMount = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const lastDeps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        isInitialMount.current = true;\n        return ()=>{\n            isInitialMount.current = false;\n        };\n    }, []);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isInitialMount.current) isInitialMount.current = false;\n        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();\n        lastDeps.current = dependencies;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, dependencies);\n}\nfunction $9daab02d461809db$var$hasResizeObserver() {\n    return typeof window.ResizeObserver !== \"undefined\";\n}\nfunction $9daab02d461809db$export$683480f191c0e3ea(options) {\n    const { ref: ref, onResize: onResize } = options;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let element = ref === null || ref === void 0 ? void 0 : ref.current;\n        if (!element) return;\n        if (!$9daab02d461809db$var$hasResizeObserver()) {\n            window.addEventListener(\"resize\", onResize, false);\n            return ()=>{\n                window.removeEventListener(\"resize\", onResize, false);\n            };\n        } else {\n            const resizeObserverInstance = new window.ResizeObserver((entries)=>{\n                if (!entries.length) return;\n                onResize();\n            });\n            resizeObserverInstance.observe(element);\n            return ()=>{\n                if (element) resizeObserverInstance.unobserve(element);\n            };\n        }\n    }, [\n        onResize,\n        ref\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (context && context.ref && ref) {\n            context.ref.current = ref.current;\n            return ()=>{\n                context.ref.current = null;\n            };\n        }\n    });\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $62d8ded9296f3872$export$cfa2225e87938781(node) {\n    if ($62d8ded9296f3872$export$2bb74740c4e19def(node)) node = node.parentElement;\n    while(node && !$62d8ded9296f3872$export$2bb74740c4e19def(node))node = node.parentElement;\n    return node || document.scrollingElement || document.documentElement;\n}\nfunction $62d8ded9296f3872$export$2bb74740c4e19def(node) {\n    let style = window.getComputedStyle(node);\n    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // @ts-ignore\nlet $5df64b3807dc15ee$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction $5df64b3807dc15ee$export$d699905dd57c73ca() {\n    let isSSR = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__.useIsSSR)();\n    let [size, setSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>isSSR ? {\n            width: 0,\n            height: 0\n        } : $5df64b3807dc15ee$var$getViewportSize());\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Use visualViewport api to track available height even on iOS virtual keyboard opening\n        let onResize = ()=>{\n            setSize((size)=>{\n                let newSize = $5df64b3807dc15ee$var$getViewportSize();\n                if (newSize.width === size.width && newSize.height === size.height) return size;\n                return newSize;\n            });\n        };\n        if (!$5df64b3807dc15ee$var$visualViewport) window.addEventListener(\"resize\", onResize);\n        else $5df64b3807dc15ee$var$visualViewport.addEventListener(\"resize\", onResize);\n        return ()=>{\n            if (!$5df64b3807dc15ee$var$visualViewport) window.removeEventListener(\"resize\", onResize);\n            else $5df64b3807dc15ee$var$visualViewport.removeEventListener(\"resize\", onResize);\n        };\n    }, []);\n    return size;\n}\nfunction $5df64b3807dc15ee$var$getViewportSize() {\n    return {\n        width: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.width) || window.innerWidth,\n        height: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.height) || window.innerHeight\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ef06256079686ba0$var$descriptionId = 0;\nconst $ef06256079686ba0$var$descriptionNodes = new Map();\nfunction $ef06256079686ba0$export$f8aeda7b10753fa1(description) {\n    let [id, setId] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (!description) return;\n        let desc = $ef06256079686ba0$var$descriptionNodes.get(description);\n        if (!desc) {\n            let id = `react-aria-description-${$ef06256079686ba0$var$descriptionId++}`;\n            setId(id);\n            let node = document.createElement(\"div\");\n            node.id = id;\n            node.style.display = \"none\";\n            node.textContent = description;\n            document.body.appendChild(node);\n            desc = {\n                refCount: 0,\n                element: node\n            };\n            $ef06256079686ba0$var$descriptionNodes.set(description, desc);\n        } else setId(desc.element.id);\n        desc.refCount++;\n        return ()=>{\n            if (--desc.refCount === 0) {\n                desc.element.remove();\n                $ef06256079686ba0$var$descriptionNodes.delete(description);\n            }\n        };\n    }, [\n        description\n    ]);\n    return {\n        \"aria-describedby\": description ? id : undefined\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e9faafb641e167db$export$90fc3a17d93f704c(ref, event, handler, options) {\n    let handleEvent = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(handler);\n    let isDisabled = handler == null;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isDisabled) return;\n        let element = ref.current;\n        element.addEventListener(event, handleEvent, options);\n        return ()=>{\n            element.removeEventListener(event, handleEvent, options);\n        };\n    }, [\n        ref,\n        event,\n        options,\n        isDisabled,\n        handleEvent\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollView, element) {\n    let offsetX = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, \"left\");\n    let offsetY = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, \"top\");\n    let width = element.offsetWidth;\n    let height = element.offsetHeight;\n    let x = scrollView.scrollLeft;\n    let y = scrollView.scrollTop;\n    // Account for top/left border offsetting the scroll top/Left\n    let { borderTopWidth: borderTopWidth, borderLeftWidth: borderLeftWidth } = getComputedStyle(scrollView);\n    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);\n    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);\n    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width\n    let maxX = borderAdjustedX + scrollView.clientWidth;\n    let maxY = borderAdjustedY + scrollView.clientHeight;\n    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);\n    else if (offsetX + width > maxX) x += offsetX + width - maxX;\n    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);\n    else if (offsetY + height > maxY) y += offsetY + height - maxY;\n    scrollView.scrollLeft = x;\n    scrollView.scrollTop = y;\n}\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */ function $2f04cbc44ee30ce0$var$relativeOffset(ancestor, child, axis) {\n    const prop = axis === \"left\" ? \"offsetLeft\" : \"offsetTop\";\n    let sum = 0;\n    while(child.offsetParent){\n        sum += child[prop];\n        if (child.offsetParent === ancestor) break;\n        else if (child.offsetParent.contains(ancestor)) {\n            // If the ancestor is not `position:relative`, then we stop at\n            // _its_ offset parent, and we subtract off _its_ offset, so that\n            // we end up with the proper offset from child to ancestor.\n            sum -= ancestor[prop];\n            break;\n        }\n        child = child.offsetParent;\n    }\n    return sum;\n}\nfunction $2f04cbc44ee30ce0$export$c826860796309d1b(targetElement, opts) {\n    if (document.contains(targetElement)) {\n        let root = document.scrollingElement || document.documentElement;\n        let isScrollPrevented = window.getComputedStyle(root).overflow === \"hidden\";\n        // If scrolling is not currently prevented then we arent in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view\n        if (!isScrollPrevented) {\n            var // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically\n            _targetElement_scrollIntoView;\n            let { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();\n            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {\n                block: \"nearest\"\n            });\n            let { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();\n            // Account for sub pixel differences from rounding\n            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {\n                var _opts_containingElement_scrollIntoView, _opts_containingElement, _targetElement_scrollIntoView1;\n                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {\n                    block: \"center\",\n                    inline: \"center\"\n                });\n                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {\n                    block: \"nearest\"\n                });\n            }\n        } else {\n            let scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);\n            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.\n            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){\n                $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollParent, targetElement);\n                targetElement = scrollParent;\n                scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);\n            }\n        }\n    }\n}\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6a7db85432448f7f$export$60278871457622de(event) {\n    // JAWS/NVDA with Firefox.\n    if (event.mozInputSource === 0 && event.isTrusted) return true;\n    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead\n    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check\n    // to detect TalkBack virtual clicks.\n    if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType) return event.type === \"click\" && event.buttons === 1;\n    return event.detail === 0 && !event.pointerType;\n}\nfunction $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {\n    // If the pointer size is zero, then we assume it's from a screen reader.\n    // Android TalkBack double tap will sometimes return a event with width and height of 1\n    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.\n    // Cannot use \"event.pressure === 0\" as the sole check due to Safari pointer events always returning pressure === 0\n    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush\n    // Talkback double tap from Windows Firefox touch screen press\n    return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\";\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /* eslint-disable rulesdir/pure-render */ function $5a387cc49350e6db$export$722debc0e56fea39(value1, isEqual) {\n    // Using a ref during render is ok here because it's only an optimization  both values are equivalent.\n    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.\n    let lastValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (value1 && lastValue.current && isEqual(value1, lastValue.current)) value1 = lastValue.current;\n    lastValue.current = value1;\n    return value1;\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $99facab73266f662$export$5add1d006293d136(ref, initialValue, onReset) {\n    let resetValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialValue);\n    let handleReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{\n        if (onReset) onReset(resetValue.current);\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _ref_current;\n        let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;\n        form === null || form === void 0 ? void 0 : form.addEventListener(\"reset\", handleReset);\n        return ()=>{\n            form === null || form === void 0 ? void 0 : form.removeEventListener(\"reset\", handleReset);\n        };\n    }, [\n        ref,\n        handleReset\n    ]);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS91dGlscy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnSjtBQUM4RztBQUM3SjtBQUNsRTtBQUUvQjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNEOzs7Ozs7Ozs7O0NBVUMsR0FDRCxNQUFNd0IsNENBQTRDLE9BQU9DLGFBQWEsY0FBYyxDQUFDLEdBQUdyQixrQ0FBVyxFQUFHc0IsZUFBZSxHQUFHLEtBQUs7QUFJN0g7Ozs7Ozs7Ozs7Q0FVQyxHQUNEOzs7Ozs7Ozs7O0NBVUMsR0FFRCxTQUFTQywwQ0FBMENDLEVBQUU7SUFDakQsTUFBTUMsTUFBTSxDQUFDLEdBQUdyQix5Q0FBWSxFQUFHO0lBQzlCLElBQUdnQix5Q0FBd0MsRUFBRztRQUMzQ0ssSUFBSUMsT0FBTyxHQUFHRjtJQUNsQixHQUFHO1FBQ0NBO0tBQ0g7SUFDRCxhQUFhO0lBQ2IsT0FBTyxDQUFDLEdBQUdsQiw4Q0FBaUIsRUFBRyxDQUFDLEdBQUdxQjtRQUMvQixNQUFNQyxJQUFJSCxJQUFJQyxPQUFPO1FBQ3JCLE9BQU9FLEtBQUtEO0lBQ2hCLEdBQUcsRUFBRTtBQUNUO0FBR0EsU0FBU0UsMENBQTBDQyxZQUFZO0lBQzNELElBQUksQ0FBQ0MsUUFBT0MsU0FBUyxHQUFHLENBQUMsR0FBRzlCLDJDQUFjLEVBQUc0QjtJQUM3QyxJQUFJRyxTQUFTLENBQUMsR0FBRzdCLHlDQUFZLEVBQUc7SUFDaEMsMEVBQTBFO0lBQzFFLHlDQUF5QztJQUN6QyxJQUFJOEIsVUFBVSxDQUFDLEdBQUdYLHlDQUF3QyxFQUFHO1FBQ3pELHVDQUF1QztRQUN2QyxJQUFJWSxXQUFXRixPQUFPUCxPQUFPLENBQUNVLElBQUk7UUFDbEMsOENBQThDO1FBQzlDLElB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dkcseUdBQXlHO0lBQ3pHLElBQUlDLFlBQVksQ0FBQyxHQUFHN1gseUNBQVksRUFBRztJQUNuQyxJQUFJMkIsVUFBU2tXLFVBQVV2VyxPQUFPLElBQUlzVyxRQUFRalcsUUFBT2tXLFVBQVV2VyxPQUFPLEdBQUdLLFNBQVFrVyxVQUFVdlcsT0FBTztJQUM5RnVXLFVBQVV2VyxPQUFPLEdBQUdLO0lBQ3BCLE9BQU9BO0FBQ1g7QUFHQTs7Ozs7Ozs7OztDQVVDLEdBRUQsU0FBU21XLDBDQUEwQ3pXLEdBQUcsRUFBRTBXLFlBQVksRUFBRUMsT0FBTztJQUN6RSxJQUFJQyxhQUFhLENBQUMsR0FBR2pZLHlDQUFZLEVBQUcrWDtJQUNwQyxJQUFJRyxjQUFjLENBQUMsR0FBRy9XLHlDQUF3QyxFQUFHO1FBQzdELElBQUk2VyxTQUFTQSxRQUFRQyxXQUFXM1csT0FBTztJQUMzQztJQUNDLElBQUdsQiw0Q0FBZSxFQUFHO1FBQ2xCLElBQUkrWDtRQUNKLElBQUlDLE9BQU8vVyxRQUFRLFFBQVFBLFFBQVEsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFDOFcsZUFBZTlXLElBQUlDLE9BQU8sTUFBTSxRQUFRNlcsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWFDLElBQUk7UUFDbEpBLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLakwsZ0JBQWdCLENBQUMsU0FBUytLO1FBQzNFLE9BQU87WUFDSEUsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUszSyxtQkFBbUIsQ0FBQyxTQUFTeUs7UUFDbEY7SUFDSixHQUFHO1FBQ0M3VztRQUNBNlc7S0FDSDtBQUNMO0FBS294RixDQUNweEYsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2Fyem9uZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS9pbnRlcmFjdGlvbnMvbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3V0aWxzL2Rpc3QvaW1wb3J0Lm1qcz9kMWY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y2xhbXAgYXMgJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JGNsYW1wLCBzbmFwVmFsdWVUb1N0ZXAgYXMgJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JHNuYXBWYWx1ZVRvU3RlcH0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQgJDEydUdwJHJlYWN0LCB7dXNlU3RhdGUgYXMgJDEydUdwJHVzZVN0YXRlLCB1c2VSZWYgYXMgJDEydUdwJHVzZVJlZiwgdXNlQ2FsbGJhY2sgYXMgJDEydUdwJHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgYXMgJDEydUdwJHVzZUVmZmVjdCwgY3JlYXRlQ29udGV4dCBhcyAkMTJ1R3AkY3JlYXRlQ29udGV4dCwgdXNlTWVtbyBhcyAkMTJ1R3AkdXNlTWVtbywgdXNlQ29udGV4dCBhcyAkMTJ1R3AkdXNlQ29udGV4dH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZVNTUlNhZmVJZCBhcyAkMTJ1R3AkdXNlU1NSU2FmZUlkLCB1c2VJc1NTUiBhcyAkMTJ1R3AkdXNlSXNTU1J9IGZyb20gXCJAcmVhY3QtYXJpYS9zc3JcIjtcbmltcG9ydCAkMTJ1R3AkY2xzeCBmcm9tIFwiY2xzeFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY29uc3QgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyAoMCwgJDEydUdwJHJlYWN0KS51c2VMYXlvdXRFZmZlY3QgOiAoKT0+e307XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKGZuKSB7XG4gICAgY29uc3QgcmVmID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgICgwLCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYykoKCk9PntcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBmbjtcbiAgICB9LCBbXG4gICAgICAgIGZuXG4gICAgXSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgoLi4uYXJncyk9PntcbiAgICAgICAgY29uc3QgZiA9IHJlZi5jdXJyZW50O1xuICAgICAgICByZXR1cm4gZiguLi5hcmdzKTtcbiAgICB9LCBbXSk7XG59XG5cblxuZnVuY3Rpb24gJDFkYmVjYmUyN2EwNGY5YWYkZXhwb3J0JDE0ZDIzOGYzNDI3MjNmMjUoZGVmYXVsdFZhbHVlKSB7XG4gICAgbGV0IFt2YWx1ZSwgc2V0VmFsdWVdID0gKDAsICQxMnVHcCR1c2VTdGF0ZSkoZGVmYXVsdFZhbHVlKTtcbiAgICBsZXQgZWZmZWN0ID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgIC8vIFN0b3JlIHRoZSBmdW5jdGlvbiBpbiBhIHJlZiBzbyB3ZSBjYW4gYWx3YXlzIGFjY2VzcyB0aGUgY3VycmVudCB2ZXJzaW9uXG4gICAgLy8gd2hpY2ggaGFzIHRoZSBwcm9wZXIgYHZhbHVlYCBpbiBzY29wZS5cbiAgICBsZXQgbmV4dFJlZiA9ICgwLCAkOGFlMDVlYWE1YzExNGU5YyRleHBvcnQkN2Y1NGZjMzE4MDUwOGE1MikoKCk9PntcbiAgICAgICAgLy8gUnVuIHRoZSBnZW5lcmF0b3IgdG8gdGhlIG5leHQgeWllbGQuXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IGVmZmVjdC5jdXJyZW50Lm5leHQoKTtcbiAgICAgICAgLy8gSWYgdGhlIGdlbmVyYXRvciBpcyBkb25lLCByZXNldCB0aGUgZWZmZWN0LlxuICAgICAgICBpZiAobmV3VmFsdWUuZG9uZSkge1xuICAgICAgICAgICAgZWZmZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB2YWx1ZSxcbiAgICAgICAgLy8gdGhlbiBjb250aW51ZSB0byB0aGUgbmV4dCB5aWVsZC4gT3RoZXJ3aXNlLFxuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlIGluIHN0YXRlIGFuZCB3YWl0IGZvciB0aGUgbmV4dCBsYXlvdXQgZWZmZWN0LlxuICAgICAgICBpZiAodmFsdWUgPT09IG5ld1ZhbHVlLnZhbHVlKSBuZXh0UmVmKCk7XG4gICAgICAgIGVsc2Ugc2V0VmFsdWUobmV3VmFsdWUudmFsdWUpO1xuICAgIH0pO1xuICAgICgwLCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYykoKCk9PntcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZWZmZWN0IGN1cnJlbnRseSBydW5uaW5nLCBjb250aW51ZSB0byB0aGUgbmV4dCB5aWVsZC5cbiAgICAgICAgaWYgKGVmZmVjdC5jdXJyZW50KSBuZXh0UmVmKCk7XG4gICAgfSk7XG4gICAgbGV0IHF1ZXVlID0gKDAsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKSgoZm4pPT57XG4gICAgICAgIGVmZmVjdC5jdXJyZW50ID0gZm4odmFsdWUpO1xuICAgICAgICBuZXh0UmVmKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHF1ZXVlXG4gICAgXTtcbn1cblxuXG4vLyBjb3BpZWQgZnJvbSBTU1JQcm92aWRlci50c3ggdG8gcmVkdWNlIGV4cG9ydHMsIGlmIG5lZWRlZCBhZ2FpbiwgY29uc2lkZXIgc2hhcmluZ1xubGV0ICRiZGIxMTAxMGNlZjcwMjM2JHZhciRjYW5Vc2VET00gPSBCb29sZWFuKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmxldCAkYmRiMTEwMTBjZWY3MDIzNiR2YXIkaWRzVXBkYXRlck1hcCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRmNjgwODc3YTM0NzExZTM3KGRlZmF1bHRJZCkge1xuICAgIGxldCBbdmFsdWUsIHNldFZhbHVlXSA9ICgwLCAkMTJ1R3AkdXNlU3RhdGUpKGRlZmF1bHRJZCk7XG4gICAgbGV0IG5leHRJZCA9ICgwLCAkMTJ1R3AkdXNlUmVmKShudWxsKTtcbiAgICBsZXQgcmVzID0gKDAsICQxMnVHcCR1c2VTU1JTYWZlSWQpKHZhbHVlKTtcbiAgICBsZXQgdXBkYXRlVmFsdWUgPSAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgodmFsKT0+e1xuICAgICAgICBuZXh0SWQuY3VycmVudCA9IHZhbDtcbiAgICB9LCBbXSk7XG4gICAgaWYgKCRiZGIxMTAxMGNlZjcwMjM2JHZhciRjYW5Vc2VET00pICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwLnNldChyZXMsIHVwZGF0ZVZhbHVlKTtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIGxldCByID0gcmVzO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwLmRlbGV0ZShyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHJlc1xuICAgIF0pO1xuICAgIC8vIFRoaXMgY2Fubm90IGNhdXNlIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSB0aGUgcmVmIGlzIHVwZGF0ZWQgZmlyc3QuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBuZXdJZCA9IG5leHRJZC5jdXJyZW50O1xuICAgICAgICBpZiAobmV3SWQpIHtcbiAgICAgICAgICAgIG5leHRJZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHNldFZhbHVlKG5ld0lkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkY2Q4YzljYjY4Zjg0MjYyOShpZEEsIGlkQikge1xuICAgIGlmIChpZEEgPT09IGlkQikgcmV0dXJuIGlkQTtcbiAgICBsZXQgc2V0SWRBID0gJGJkYjExMDEwY2VmNzAyMzYkdmFyJGlkc1VwZGF0ZXJNYXAuZ2V0KGlkQSk7XG4gICAgaWYgKHNldElkQSkge1xuICAgICAgICBzZXRJZEEoaWRCKTtcbiAgICAgICAgcmV0dXJuIGlkQjtcbiAgICB9XG4gICAgbGV0IHNldElkQiA9ICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwLmdldChpZEIpO1xuICAgIGlmIChzZXRJZEIpIHtcbiAgICAgICAgc2V0SWRCKGlkQSk7XG4gICAgICAgIHJldHVybiBpZEE7XG4gICAgfVxuICAgIHJldHVybiBpZEI7XG59XG5mdW5jdGlvbiAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkYjRjYzA5YzU5MmU4ZmRiOChkZXBBcnJheSA9IFtdKSB7XG4gICAgbGV0IGlkID0gJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGY2ODA4NzdhMzQ3MTFlMzcoKTtcbiAgICBsZXQgW3Jlc29sdmVkSWQsIHNldFJlc29sdmVkSWRdID0gKDAsICQxZGJlY2JlMjdhMDRmOWFmJGV4cG9ydCQxNGQyMzhmMzQyNzIzZjI1KShpZCk7XG4gICAgbGV0IHVwZGF0ZUlkID0gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0UmVzb2x2ZWRJZChmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICB5aWVsZCBpZDtcbiAgICAgICAgICAgIHlpZWxkIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA/IGlkIDogdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGlkLFxuICAgICAgICBzZXRSZXNvbHZlZElkXG4gICAgXSk7XG4gICAgKDAsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjKSh1cGRhdGVJZCwgW1xuICAgICAgICBpZCxcbiAgICAgICAgdXBkYXRlSWQsXG4gICAgICAgIC4uLmRlcEFycmF5XG4gICAgXSk7XG4gICAgcmV0dXJuIHJlc29sdmVkSWQ7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qKlxuICogQ2FsbHMgYWxsIGZ1bmN0aW9ucyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIGNoYWluZWQgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMuXG4gKi8gZnVuY3Rpb24gJGZmNTk2M2ViMWZjY2Y1NTIkZXhwb3J0JGUwOGUzYjY3ZTM5MjEwMWUoLi4uY2FsbGJhY2tzKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKT0+e1xuICAgICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiBjYWxsYmFja3MpaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSBjYWxsYmFjayguLi5hcmdzKTtcbiAgICB9O1xufVxuXG5cbmNvbnN0ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjID0gKGVsKT0+e1xuICAgIHZhciBfZWxfb3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gKF9lbF9vd25lckRvY3VtZW50ID0gZWwgPT09IG51bGwgfHwgZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9lbF9vd25lckRvY3VtZW50ICE9PSB2b2lkIDAgPyBfZWxfb3duZXJEb2N1bWVudCA6IGRvY3VtZW50O1xufTtcbmNvbnN0ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhID0gKGVsKT0+e1xuICAgIGlmIChlbCAmJiBcIndpbmRvd1wiIGluIGVsICYmIGVsLndpbmRvdyA9PT0gZWwpIHJldHVybiBlbDtcbiAgICBjb25zdCBkb2MgPSAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyhlbCk7XG4gICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG59O1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkM2VmNDI1NzVkZjg0YjMwYiRleHBvcnQkOWQxNjExYzc3YzJmZTkyOCguLi5hcmdzKSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIGJhc2UgY2xvbmUgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LiBUaGlzIGlzIGEgbG90IGZhc3RlciB0aGFuIHN0YXJ0aW5nXG4gICAgLy8gd2l0aCBhbiBlbXB0eSBvYmplY3QgYW5kIGFkZGluZyBwcm9wZXJ0aWVzIGFzIHdlIGdvLlxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIC4uLmFyZ3NbMF1cbiAgICB9O1xuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IHByb3BzID0gYXJnc1tpXTtcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gcHJvcHMpe1xuICAgICAgICAgICAgbGV0IGEgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgIGxldCBiID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgIC8vIENoYWluIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGIgPT09IFwiZnVuY3Rpb25cIiAmJiAvLyBUaGlzIGlzIGEgbG90IGZhc3RlciB0aGFuIGEgcmVnZXguXG4gICAgICAgICAgICBrZXlbMF0gPT09IFwib1wiICYmIGtleVsxXSA9PT0gXCJuXCIgJiYga2V5LmNoYXJDb2RlQXQoMikgPj0gLyogJ0EnICovIDY1ICYmIGtleS5jaGFyQ29kZUF0KDIpIDw9IC8qICdaJyAqLyA5MCkgcmVzdWx0W2tleV0gPSAoMCwgJGZmNTk2M2ViMWZjY2Y1NTIkZXhwb3J0JGUwOGUzYjY3ZTM5MjEwMWUpKGEsIGIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoKGtleSA9PT0gXCJjbGFzc05hbWVcIiB8fCBrZXkgPT09IFwiVU5TQUZFX2NsYXNzTmFtZVwiKSAmJiB0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIikgcmVzdWx0W2tleV0gPSAoMCwgJDEydUdwJGNsc3gpKGEsIGIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImlkXCIgJiYgYSAmJiBiKSByZXN1bHQuaWQgPSAoMCwgJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGNkOGM5Y2I2OGY4NDI2MjkpKGEsIGIpO1xuICAgICAgICAgICAgZWxzZSByZXN1bHRba2V5XSA9IGIgIT09IHVuZGVmaW5lZCA/IGIgOiBhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ1ZGM5NTg5OWIzMDZmNjMwJGV4cG9ydCRjOTA1ODMxNjc2NGMxNDBlKC4uLnJlZnMpIHtcbiAgICBpZiAocmVmcy5sZW5ndGggPT09IDEpIHJldHVybiByZWZzWzBdO1xuICAgIHJldHVybiAodmFsdWUpPT57XG4gICAgICAgIGZvciAobGV0IHJlZiBvZiByZWZzKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHJlZih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNvbnN0ICQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRET01Qcm9wTmFtZXMgPSBuZXcgU2V0KFtcbiAgICBcImlkXCJcbl0pO1xuY29uc3QgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxhYmVsYWJsZVByb3BOYW1lcyA9IG5ldyBTZXQoW1xuICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCIsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCIsXG4gICAgXCJhcmlhLWRldGFpbHNcIlxuXSk7XG4vLyBTZWUgTGlua0RPTVByb3BzIGluIGRvbS5kLnRzLlxuY29uc3QgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxpbmtQcm9wTmFtZXMgPSBuZXcgU2V0KFtcbiAgICBcImhyZWZcIixcbiAgICBcInRhcmdldFwiLFxuICAgIFwicmVsXCIsXG4gICAgXCJkb3dubG9hZFwiLFxuICAgIFwicGluZ1wiLFxuICAgIFwicmVmZXJyZXJQb2xpY3lcIlxuXSk7XG5jb25zdCAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkcHJvcFJlID0gL14oZGF0YS0uKikkLztcbmZ1bmN0aW9uICQ2NTQ4NGQwMmRjYjdlYjNlJGV4cG9ydCQ0NTdjM2Q2NTE4ZGQ0YzZmKHByb3BzLCBvcHRzID0ge30pIHtcbiAgICBsZXQgeyBsYWJlbGFibGU6IGxhYmVsYWJsZSwgaXNMaW5rOiBpc0xpbmssIHByb3BOYW1lczogcHJvcE5hbWVzIH0gPSBvcHRzO1xuICAgIGxldCBmaWx0ZXJlZFByb3BzID0ge307XG4gICAgZm9yKGNvbnN0IHByb3AgaW4gcHJvcHMpaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcCkgJiYgKCQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRET01Qcm9wTmFtZXMuaGFzKHByb3ApIHx8IGxhYmVsYWJsZSAmJiAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkbGFiZWxhYmxlUHJvcE5hbWVzLmhhcyhwcm9wKSB8fCBpc0xpbmsgJiYgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxpbmtQcm9wTmFtZXMuaGFzKHByb3ApIHx8IChwcm9wTmFtZXMgPT09IG51bGwgfHwgcHJvcE5hbWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wTmFtZXMuaGFzKHByb3ApKSB8fCAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkcHJvcFJlLnRlc3QocHJvcCkpKSBmaWx0ZXJlZFByb3BzW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgcmV0dXJuIGZpbHRlcmVkUHJvcHM7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ3MjE1YWZjNmRlNjA2ZDZiJGV4cG9ydCRkZTc5ZTJjNjk1ZTA1MmYzKGVsZW1lbnQpIHtcbiAgICBpZiAoJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCgpKSBlbGVtZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc2Nyb2xsYWJsZUVsZW1lbnRzID0gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJGdldFNjcm9sbGFibGVFbGVtZW50cyhlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkcmVzdG9yZVNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGVFbGVtZW50cyk7XG4gICAgfVxufVxubGV0ICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSBudWxsO1xuZnVuY3Rpb24gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCgpIHtcbiAgICBpZiAoJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZCA9PSBudWxsKSB7XG4gICAgICAgICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBmb2N1c0VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZm9jdXNFbGVtLmZvY3VzKHtcbiAgICAgICAgICAgICAgICBnZXQgcHJldmVudFNjcm9sbCAoKSB7XG4gICAgICAgICAgICAgICAgICAgICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZDtcbn1cbmZ1bmN0aW9uICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRnZXRTY3JvbGxhYmxlRWxlbWVudHMoZWxlbWVudCkge1xuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgdmFyIHNjcm9sbGFibGVFbGVtZW50cyA9IFtdO1xuICAgIHZhciByb290U2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHdoaWxlKHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHBhcmVudCAhPT0gcm9vdFNjcm9sbGluZ0VsZW1lbnQpe1xuICAgICAgICBpZiAocGFyZW50Lm9mZnNldEhlaWdodCA8IHBhcmVudC5zY3JvbGxIZWlnaHQgfHwgcGFyZW50Lm9mZnNldFdpZHRoIDwgcGFyZW50LnNjcm9sbFdpZHRoKSBzY3JvbGxhYmxlRWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBlbGVtZW50OiBwYXJlbnQsXG4gICAgICAgICAgICBzY3JvbGxUb3A6IHBhcmVudC5zY3JvbGxUb3AsXG4gICAgICAgICAgICBzY3JvbGxMZWZ0OiBwYXJlbnQuc2Nyb2xsTGVmdFxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChyb290U2Nyb2xsaW5nRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSBzY3JvbGxhYmxlRWxlbWVudHMucHVzaCh7XG4gICAgICAgIGVsZW1lbnQ6IHJvb3RTY3JvbGxpbmdFbGVtZW50LFxuICAgICAgICBzY3JvbGxUb3A6IHJvb3RTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgc2Nyb2xsTGVmdDogcm9vdFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdFxuICAgIH0pO1xuICAgIHJldHVybiBzY3JvbGxhYmxlRWxlbWVudHM7XG59XG5mdW5jdGlvbiAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkcmVzdG9yZVNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGVFbGVtZW50cykge1xuICAgIGZvciAobGV0IHsgZWxlbWVudDogZWxlbWVudCwgc2Nyb2xsVG9wOiBzY3JvbGxUb3AsIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQgfSBvZiBzY3JvbGxhYmxlRWxlbWVudHMpe1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICRhYjcxZGFkYjAzYTZmYjJlJGV4cG9ydCQ2MjJjZWE0NDVhMWM1YjdkKGVsZW1lbnQsIHJldmVyc2UsIG9yaWVudGF0aW9uID0gXCJob3Jpem9udGFsXCIpIHtcbiAgICBsZXQgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKHJldmVyc2UpIHJldHVybiBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyByZWN0LnJpZ2h0IDogcmVjdC5ib3R0b207XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IHJlY3QubGVmdCA6IHJlY3QudG9wO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQocmUpIHtcbiAgICB2YXIgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB3aW5kb3cubmF2aWdhdG9yID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKChfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID0gd2luZG93Lm5hdmlnYXRvcltcInVzZXJBZ2VudERhdGFcIl0pID09PSBudWxsIHx8IF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEuYnJhbmRzLnNvbWUoKGJyYW5kKT0+cmUudGVzdChicmFuZC5icmFuZCkpKSB8fCByZS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0ocmUpIHtcbiAgICB2YXIgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YTtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmF2aWdhdG9yICE9IG51bGwgPyByZS50ZXN0KCgoX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9IHdpbmRvdy5uYXZpZ2F0b3JbXCJ1c2VyQWdlbnREYXRhXCJdKSA9PT0gbnVsbCB8fCBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhLnBsYXRmb3JtKSB8fCB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0oL15NYWMvaSk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkMTg2YzY5NjRjYTE3ZDk5KCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFBsYXRmb3JtKC9eaVBob25lL2kpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDdiZWYwNDljZTkyZTQyMjQoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0oL15pUGFkL2kpIHx8IC8vIGlQYWRPUyAxMyBsaWVzIGFuZCBzYXlzIGl0J3MgYSBNYWMsIGJ1dCB3ZSBjYW4gZGlzdGluZ3Vpc2ggYnkgZGV0ZWN0aW5nIHRvdWNoIHN1cHBvcnQuXG4gICAgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAoKSAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGZlZGIzNjljYjcwMjA3ZjEoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQxODZjNjk2NGNhMTdkOTkoKSB8fCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkN2JlZjA0OWNlOTJlNDIyNCgpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGUxODY1YzNiZWRjZDgyMmIoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwKCkgfHwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGZlZGIzNjljYjcwMjA3ZjEoKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3ODU1MTA0MzU4MmE2YTk4KCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvQXBwbGVXZWJLaXQvaSkgJiYgISRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ2NDQ2YTE4NmQwOWUzNzllKCk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNjQ0NmExODZkMDllMzc5ZSgpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQoL0Nocm9tZS9pKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4KCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvQW5kcm9pZC9pKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRiN2Q3ODk5M2I3NGY3NjZkKCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvRmlyZWZveC9pKTtcbn1cblxuXG5cblxuY29uc3QgJGVhOGRjYmNiOWVhMWI1NTYkdmFyJFJvdXRlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovICgwLCAkMTJ1R3AkY3JlYXRlQ29udGV4dCkoe1xuICAgIGlzTmF0aXZlOiB0cnVlLFxuICAgIG9wZW46ICRlYThkY2JjYjllYTFiNTU2JHZhciRvcGVuU3ludGhldGljTGlua1xufSk7XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkMzIzZTRmYzJmYTQ3NTNmYihwcm9wcykge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgbmF2aWdhdGU6IG5hdmlnYXRlIH0gPSBwcm9wcztcbiAgICBsZXQgY3R4ID0gKDAsICQxMnVHcCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIGlzTmF0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG9wZW46ICh0YXJnZXQsIG1vZGlmaWVycyk9PntcbiAgICAgICAgICAgICAgICAkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkZ2V0U3ludGhldGljTGluayh0YXJnZXQsIChsaW5rKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JGVmYThjOTA5OWU1MzAyMzUobGluaywgbW9kaWZpZXJzKSkgbmF2aWdhdGUobGluay5wYXRobmFtZSArIGxpbmsuc2VhcmNoICsgbGluay5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNyhsaW5rLCBtb2RpZmllcnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgW1xuICAgICAgICBuYXZpZ2F0ZVxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkMTJ1R3AkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGVhOGRjYmNiOWVhMWI1NTYkdmFyJFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGN0eFxuICAgIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5YTMwMmE0NWY2NWQwNTcyKCkge1xuICAgIHJldHVybiAoMCwgJDEydUdwJHVzZUNvbnRleHQpKCRlYThkY2JjYjllYTFiNTU2JHZhciRSb3V0ZXJDb250ZXh0KTtcbn1cbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCRlZmE4YzkwOTllNTMwMjM1KGxpbmssIG1vZGlmaWVycykge1xuICAgIC8vIFVzZSBnZXRBdHRyaWJ1dGUgaGVyZSBpbnN0ZWFkIG9mIGxpbmsudGFyZ2V0LiBGaXJlZm94IHdpbGwgZGVmYXVsdCBsaW5rLnRhcmdldCB0byBcIl9wYXJlbnRcIiB3aGVuIGluc2lkZSBhbiBpZnJhbWUuXG4gICAgbGV0IHRhcmdldCA9IGxpbmsuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuICAgIHJldHVybiAoIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiYgbGluay5vcmlnaW4gPT09IGxvY2F0aW9uLm9yaWdpbiAmJiAhbGluay5oYXNBdHRyaWJ1dGUoXCJkb3dubG9hZFwiKSAmJiAhbW9kaWZpZXJzLm1ldGFLZXkgJiYgLy8gb3BlbiBpbiBuZXcgdGFiIChtYWMpXG4gICAgIW1vZGlmaWVycy5jdHJsS2V5ICYmIC8vIG9wZW4gaW4gbmV3IHRhYiAod2luZG93cylcbiAgICAhbW9kaWZpZXJzLmFsdEtleSAmJiAvLyBkb3dubG9hZFxuICAgICFtb2RpZmllcnMuc2hpZnRLZXk7XG59XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNyh0YXJnZXQsIG1vZGlmaWVycywgc2V0T3BlbmluZyA9IHRydWUpIHtcbiAgICB2YXIgX3dpbmRvd19ldmVudF90eXBlLCBfd2luZG93X2V2ZW50O1xuICAgIGxldCB7IG1ldGFLZXk6IG1ldGFLZXksIGN0cmxLZXk6IGN0cmxLZXksIGFsdEtleTogYWx0S2V5LCBzaGlmdEtleTogc2hpZnRLZXkgfSA9IG1vZGlmaWVycztcbiAgICAvLyBGaXJlZm94IGRvZXMgbm90IHJlY29nbml6ZSBrZXlib2FyZCBldmVudHMgYXMgYSB1c2VyIGFjdGlvbiBieSBkZWZhdWx0LCBhbmQgdGhlIHBvcHVwIGJsb2NrZXJcbiAgICAvLyB3aWxsIHByZXZlbnQgbGlua3Mgd2l0aCB0YXJnZXQ9XCJfYmxhbmtcIiBmcm9tIG9wZW5pbmcuIEhvd2V2ZXIsIGl0IGRvZXMgYWxsb3cgdGhlIGV2ZW50IGlmIHRoZVxuICAgIC8vIENvbW1hbmQvQ29udHJvbCBrZXkgaXMgaGVsZCwgd2hpY2ggb3BlbnMgdGhlIGxpbmsgaW4gYSBiYWNrZ3JvdW5kIHRhYi4gVGhpcyBzZWVtcyBsaWtlIHRoZSBiZXN0IHdlIGNhbiBkby5cbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjU3ODcwIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDY2NDAuXG4gICAgaWYgKCgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYjdkNzg5OTNiNzRmNzY2ZCkoKSAmJiAoKF93aW5kb3dfZXZlbnQgPSB3aW5kb3cuZXZlbnQpID09PSBudWxsIHx8IF93aW5kb3dfZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfd2luZG93X2V2ZW50X3R5cGUgPSBfd2luZG93X2V2ZW50LnR5cGUpID09PSBudWxsIHx8IF93aW5kb3dfZXZlbnRfdHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvd19ldmVudF90eXBlLnN0YXJ0c1dpdGgoXCJrZXlcIikpICYmIHRhcmdldC50YXJnZXQgPT09IFwiX2JsYW5rXCIpIHtcbiAgICAgICAgaWYgKCgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCkoKSkgbWV0YUtleSA9IHRydWU7XG4gICAgICAgIGVsc2UgY3RybEtleSA9IHRydWU7XG4gICAgfVxuICAgIC8vIFdlYktpdCBkb2VzIG5vdCBzdXBwb3J0IGZpcmluZyBjbGljayBldmVudHMgd2l0aCBtb2RpZmllciBrZXlzLCBidXQgZG9lcyBzdXBwb3J0IGtleWJvYXJkIGV2ZW50cy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vV2ViS2l0L1dlYktpdC9ibG9iL2MwM2QwYWM2ZTZkYjE3OGY5MDkyM2EwYTYzMDgwYjVjYTIxMGQyNWYvU291cmNlL1dlYkNvcmUvaHRtbC9IVE1MQW5jaG9yRWxlbWVudC5jcHAjTDE4NFxuICAgIGxldCBldmVudCA9ICgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNzg1NTEwNDM1ODJhNmE5OCkoKSAmJiAoMCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTApKCkgJiYgISgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkN2JlZjA0OWNlOTJlNDIyNCkoKSAmJiB0cnVlID8gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIHtcbiAgICAgICAga2V5SWRlbnRpZmllcjogXCJFbnRlclwiLFxuICAgICAgICBtZXRhS2V5OiBtZXRhS2V5LFxuICAgICAgICBjdHJsS2V5OiBjdHJsS2V5LFxuICAgICAgICBhbHRLZXk6IGFsdEtleSxcbiAgICAgICAgc2hpZnRLZXk6IHNoaWZ0S2V5XG4gICAgfSkgOiBuZXcgTW91c2VFdmVudChcImNsaWNrXCIsIHtcbiAgICAgICAgbWV0YUtleTogbWV0YUtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgYWx0S2V5OiBhbHRLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3LmlzT3BlbmluZyA9IHNldE9wZW5pbmc7XG4gICAgKDAsICQ3MjE1YWZjNmRlNjA2ZDZiJGV4cG9ydCRkZTc5ZTJjNjk1ZTA1MmYzKSh0YXJnZXQpO1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNy5pc09wZW5pbmcgPSBmYWxzZTtcbn1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXJjZWwtYnVuZGxlci9wYXJjZWwvaXNzdWVzLzg3MjRcbiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3LmlzT3BlbmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkdmFyJGdldFN5bnRoZXRpY0xpbmsodGFyZ2V0LCBvcGVuKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50KSBvcGVuKHRhcmdldCk7XG4gICAgZWxzZSBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtaHJlZlwiKSkge1xuICAgICAgICBsZXQgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICBsaW5rLmhyZWYgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1ocmVmXCIpO1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpKSBsaW5rLnRhcmdldCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRhcmdldFwiKTtcbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlbFwiKSkgbGluay5yZWwgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxcIik7XG4gICAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKFwiZGF0YS1kb3dubG9hZFwiKSkgbGluay5kb3dubG9hZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRvd25sb2FkXCIpO1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtcGluZ1wiKSkgbGluay5waW5nID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcGluZ1wiKTtcbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlZmVycmVyLXBvbGljeVwiKSkgbGluay5yZWZlcnJlclBvbGljeSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlZmVycmVyLXBvbGljeVwiKTtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICBvcGVuKGxpbmspO1xuICAgICAgICB0YXJnZXQucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgfVxufVxuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkdmFyJG9wZW5TeW50aGV0aWNMaW5rKHRhcmdldCwgbW9kaWZpZXJzKSB7XG4gICAgJGVhOGRjYmNiOWVhMWI1NTYkdmFyJGdldFN5bnRoZXRpY0xpbmsodGFyZ2V0LCAobGluayk9PiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3KGxpbmssIG1vZGlmaWVycykpO1xufVxuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDUxNDM3ZDUwMzM3M2QyMjMocHJvcHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBcImRhdGEtaHJlZlwiOiBwcm9wcy5ocmVmLFxuICAgICAgICBcImRhdGEtdGFyZ2V0XCI6IHByb3BzLnRhcmdldCxcbiAgICAgICAgXCJkYXRhLXJlbFwiOiBwcm9wcy5yZWwsXG4gICAgICAgIFwiZGF0YS1kb3dubG9hZFwiOiBwcm9wcy5kb3dubG9hZCxcbiAgICAgICAgXCJkYXRhLXBpbmdcIjogcHJvcHMucGluZyxcbiAgICAgICAgXCJkYXRhLXJlZmVycmVyLXBvbGljeVwiOiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFdlIHN0b3JlIGEgZ2xvYmFsIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBhcmUgY3VycmVudGx5IHRyYW5zaXRpb25pbmcsXG4vLyBtYXBwZWQgdG8gYSBzZXQgb2YgQ1NTIHByb3BlcnRpZXMgdGhhdCBhcmUgdHJhbnNpdGlvbmluZyBmb3IgdGhhdCBlbGVtZW50LlxuLy8gVGhpcyBpcyBuZWNlc3NhcnkgcmF0aGVyIHRoYW4gYSBzaW1wbGUgY291bnQgb2YgdHJhbnNpdGlvbnMgYmVjYXVzZSBvZiBicm93c2VyXG4vLyBidWdzLCBlLmcuIENocm9tZSBzb21ldGltZXMgZmlyZXMgYm90aCB0cmFuc2l0aW9uZW5kIGFuZCB0cmFuc2l0aW9uY2FuY2VsIHJhdGhlclxuLy8gdGhhbiBvbmUgb3IgdGhlIG90aGVyLiBTbyB3ZSBuZWVkIHRvIHRyYWNrIHdoYXQncyBhY3R1YWxseSB0cmFuc2l0aW9uaW5nIHNvIHRoYXRcbi8vIHdlIGNhbiBpZ25vcmUgdGhlc2UgZHVwbGljYXRlIGV2ZW50cy5cbmxldCAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQgPSBuZXcgTWFwKCk7XG4vLyBBIGxpc3Qgb2YgY2FsbGJhY2tzIHRvIGNhbGwgb25jZSB0aGVyZSBhcmUgbm8gdHJhbnNpdGlvbmluZyBlbGVtZW50cy5cbmxldCAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbkNhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uICRiYmVkOGI0MWY4NTdiY2MwJHZhciRzZXR1cEdsb2JhbEV2ZW50cygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgIGxldCBvblRyYW5zaXRpb25TdGFydCA9IChlKT0+e1xuICAgICAgICAvLyBBZGQgdGhlIHRyYW5zaXRpb25pbmcgcHJvcGVydHkgdG8gdGhlIGxpc3QgZm9yIHRoaXMgZWxlbWVudC5cbiAgICAgICAgbGV0IHRyYW5zaXRpb25zID0gJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LmdldChlLnRhcmdldCk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LnNldChlLnRhcmdldCwgdHJhbnNpdGlvbnMpO1xuICAgICAgICAgICAgLy8gVGhlIHRyYW5zaXRpb25jYW5jZWwgZXZlbnQgbXVzdCBiZSByZWdpc3RlcmVkIG9uIHRoZSBlbGVtZW50IGl0c2VsZiwgcmF0aGVyIHRoYW4gYXMgYSBnbG9iYWxcbiAgICAgICAgICAgIC8vIGV2ZW50LiBUaGlzIGVuYWJsZXMgdXMgdG8gaGFuZGxlIHdoZW4gdGhlIG5vZGUgaXMgZGVsZXRlZCBmcm9tIHRoZSBkb2N1bWVudCB3aGlsZSBpdCBpcyB0cmFuc2l0aW9uaW5nLlxuICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgY2FuY2VsIGV2ZW50IHdvdWxkIGhhdmUgbm93aGVyZSB0byBidWJibGUgdG8gc28gd2UgbmVlZCB0byBoYW5kbGUgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgICBlLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmNhbmNlbFwiLCBvblRyYW5zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zaXRpb25zLmFkZChlLnByb3BlcnR5TmFtZSk7XG4gICAgfTtcbiAgICBsZXQgb25UcmFuc2l0aW9uRW5kID0gKGUpPT57XG4gICAgICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBmcm9tIGxpc3Qgb2YgdHJhbnNpdGlvbmluZyBwcm9wZXJ0aWVzLlxuICAgICAgICBsZXQgcHJvcGVydGllcyA9ICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5nZXQoZS50YXJnZXQpO1xuICAgICAgICBpZiAoIXByb3BlcnRpZXMpIHJldHVybjtcbiAgICAgICAgcHJvcGVydGllcy5kZWxldGUoZS5wcm9wZXJ0eU5hbWUpO1xuICAgICAgICAvLyBJZiBlbXB0eSwgcmVtb3ZlIHRyYW5zaXRpb25jYW5jZWwgZXZlbnQsIGFuZCByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgbGlzdCBvZiB0cmFuc2l0aW9uaW5nIGVsZW1lbnRzLlxuICAgICAgICBpZiAocHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmNhbmNlbFwiLCBvblRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LmRlbGV0ZShlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gdHJhbnNpdGlvbmluZyBlbGVtZW50cywgY2FsbCBhbGwgb2YgdGhlIHF1ZXVlZCBjYWxsYmFja3MuXG4gICAgICAgIGlmICgkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgY2Igb2YgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25DYWxsYmFja3MpY2IoKTtcbiAgICAgICAgICAgICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uQ2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25ydW5cIiwgb25UcmFuc2l0aW9uU3RhcnQpO1xuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgb25UcmFuc2l0aW9uRW5kKTtcbn1cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpICRiYmVkOGI0MWY4NTdiY2MwJHZhciRzZXR1cEdsb2JhbEV2ZW50cygpO1xuICAgIGVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHNldHVwR2xvYmFsRXZlbnRzKTtcbn1cbmZ1bmN0aW9uICRiYmVkOGI0MWY4NTdiY2MwJGV4cG9ydCQyNDQ5MDMxNmY3NjRjNDMwKGZuKSB7XG4gICAgLy8gV2FpdCBvbmUgZnJhbWUgdG8gc2VlIGlmIGFuIGFuaW1hdGlvbiBzdGFydHMsIGUuZy4gYSB0cmFuc2l0aW9uIG9uIG1vdW50LlxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAvLyBJZiBubyB0cmFuc2l0aW9ucyBhcmUgcnVubmluZywgY2FsbCB0aGUgZnVuY3Rpb24gaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYWRkIGl0IHRvIGEgbGlzdCBvZiBjYWxsYmFja3MgdG8gcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgaWYgKCRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5zaXplID09PSAwKSBmbigpO1xuICAgICAgICBlbHNlICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uQ2FsbGJhY2tzLmFkZChmbik7XG4gICAgfSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qIGVzbGludC1kaXNhYmxlIHJ1bGVzZGlyL3B1cmUtcmVuZGVyICovIFxuXG4vLyBLZWVwIHRyYWNrIG9mIGVsZW1lbnRzIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBoYW5kbGluZyBkcmFnZ2luZyBmb3IgdmlhIHVzZURyYWcxRC5cbi8vIElmIHRoZXJlJ3MgYW4gYW5jZXN0b3IgYW5kIGEgZGVzY2VuZGFudCBib3RoIHVzaW5nIHVzZURyYWcxRCgpLCBhbmQgdGhlIHVzZXIgc3RhcnRzXG4vLyBkcmFnZ2luZyB0aGUgZGVzY2VuZGFudCwgd2UgZG9uJ3Qgd2FudCB1c2VEcmFnMUQgZXZlbnRzIHRvIGZpcmUgZm9yIHRoZSBhbmNlc3Rvci5cbmNvbnN0ICQ5Y2MwOWRmOWZkNzY3NmJlJHZhciRkcmFnZ2luZ0VsZW1lbnRzID0gW107XG5mdW5jdGlvbiAkOWNjMDlkZjlmZDc2NzZiZSRleHBvcnQkN2JiZWQ3NWZlYmEzOTcwNihwcm9wcykge1xuICAgIGNvbnNvbGUud2FybihcInVzZURyYWcxRCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGB1c2VNb3ZlYCBpbnN0ZWFkIGh0dHBzOi8vcmVhY3Qtc3BlY3RydW0uYWRvYmUuY29tL3JlYWN0LWFyaWEvdXNlTW92ZS5odG1sXCIpO1xuICAgIGxldCB7IGNvbnRhaW5lclJlZjogY29udGFpbmVyUmVmLCByZXZlcnNlOiByZXZlcnNlLCBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sIG9uSG92ZXI6IG9uSG92ZXIsIG9uRHJhZzogb25EcmFnLCBvblBvc2l0aW9uQ2hhbmdlOiBvblBvc2l0aW9uQ2hhbmdlLCBvbkluY3JlbWVudDogb25JbmNyZW1lbnQsIG9uRGVjcmVtZW50OiBvbkRlY3JlbWVudCwgb25JbmNyZW1lbnRUb01heDogb25JbmNyZW1lbnRUb01heCwgb25EZWNyZW1lbnRUb01pbjogb25EZWNyZW1lbnRUb01pbiwgb25Db2xsYXBzZVRvZ2dsZTogb25Db2xsYXBzZVRvZ2dsZSB9ID0gcHJvcHM7XG4gICAgbGV0IGdldFBvc2l0aW9uID0gKGUpPT5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBlLmNsaWVudFggOiBlLmNsaWVudFk7XG4gICAgbGV0IGdldE5leHRPZmZzZXQgPSAoZSk9PntcbiAgICAgICAgbGV0IGNvbnRhaW5lck9mZnNldCA9ICgwLCAkYWI3MWRhZGIwM2E2ZmIyZSRleHBvcnQkNjIyY2VhNDQ1YTFjNWI3ZCkoY29udGFpbmVyUmVmLmN1cnJlbnQsIHJldmVyc2UsIG9yaWVudGF0aW9uKTtcbiAgICAgICAgbGV0IG1vdXNlT2Zmc2V0ID0gZ2V0UG9zaXRpb24oZSk7XG4gICAgICAgIGxldCBuZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGNvbnRhaW5lck9mZnNldCAtIG1vdXNlT2Zmc2V0IDogbW91c2VPZmZzZXQgLSBjb250YWluZXJPZmZzZXQ7XG4gICAgICAgIHJldHVybiBuZXh0T2Zmc2V0O1xuICAgIH07XG4gICAgbGV0IGRyYWdnaW5nID0gKDAsICQxMnVHcCR1c2VSZWYpKGZhbHNlKTtcbiAgICBsZXQgcHJldlBvc2l0aW9uID0gKDAsICQxMnVHcCR1c2VSZWYpKDApO1xuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgaGFuZGxlcnMgaW4gYSByZWYgc28gdGhhdCB0aGUgZXZlbnRzIGNhbiBhY2Nlc3MgdGhlbS5cbiAgICBsZXQgaGFuZGxlcnMgPSAoMCwgJDEydUdwJHVzZVJlZikoe1xuICAgICAgICBvblBvc2l0aW9uQ2hhbmdlOiBvblBvc2l0aW9uQ2hhbmdlLFxuICAgICAgICBvbkRyYWc6IG9uRHJhZ1xuICAgIH0pO1xuICAgIGhhbmRsZXJzLmN1cnJlbnQub25EcmFnID0gb25EcmFnO1xuICAgIGhhbmRsZXJzLmN1cnJlbnQub25Qb3NpdGlvbkNoYW5nZSA9IG9uUG9zaXRpb25DaGFuZ2U7XG4gICAgbGV0IG9uTW91c2VEcmFnZ2VkID0gKGUpPT57XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IG5leHRPZmZzZXQgPSBnZXROZXh0T2Zmc2V0KGUpO1xuICAgICAgICBpZiAoIWRyYWdnaW5nLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmN1cnJlbnQub25EcmFnKSBoYW5kbGVycy5jdXJyZW50Lm9uRHJhZyh0cnVlKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycy5jdXJyZW50Lm9uUG9zaXRpb25DaGFuZ2UpIGhhbmRsZXJzLmN1cnJlbnQub25Qb3NpdGlvbkNoYW5nZShuZXh0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlBvc2l0aW9uLmN1cnJlbnQgPT09IG5leHRPZmZzZXQpIHJldHVybjtcbiAgICAgICAgcHJldlBvc2l0aW9uLmN1cnJlbnQgPSBuZXh0T2Zmc2V0O1xuICAgICAgICBpZiAob25Qb3NpdGlvbkNoYW5nZSkgb25Qb3NpdGlvbkNoYW5nZShuZXh0T2Zmc2V0KTtcbiAgICB9O1xuICAgIGxldCBvbk1vdXNlVXAgPSAoZSk9PntcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIGRyYWdnaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5leHRPZmZzZXQgPSBnZXROZXh0T2Zmc2V0KGUpO1xuICAgICAgICBpZiAoaGFuZGxlcnMuY3VycmVudC5vbkRyYWcpIGhhbmRsZXJzLmN1cnJlbnQub25EcmFnKGZhbHNlKTtcbiAgICAgICAgaWYgKGhhbmRsZXJzLmN1cnJlbnQub25Qb3NpdGlvbkNoYW5nZSkgaGFuZGxlcnMuY3VycmVudC5vblBvc2l0aW9uQ2hhbmdlKG5leHRPZmZzZXQpO1xuICAgICAgICAkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cy5zcGxpY2UoJDljYzA5ZGY5ZmQ3Njc2YmUkdmFyJGRyYWdnaW5nRWxlbWVudHMuaW5kZXhPZih0YXJnZXQpLCAxKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlRHJhZ2dlZCwgZmFsc2UpO1xuICAgIH07XG4gICAgbGV0IG9uTW91c2VEb3duID0gKGUpPT57XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICAgICAgLy8gSWYgd2UncmUgYWxyZWFkeSBoYW5kbGluZyBkcmFnZ2luZyBvbiBhIGRlc2NlbmRhbnQgd2l0aCB1c2VEcmFnMUQsIHRoZW5cbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBoYW5kbGUgdGhlIGRyYWcgbW90aW9uIG9uIHRoaXMgdGFyZ2V0IGFzIHdlbGwuXG4gICAgICAgIGlmICgkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cy5zb21lKChlbHQpPT50YXJnZXQuY29udGFpbnMoZWx0KSkpIHJldHVybjtcbiAgICAgICAgJDljYzA5ZGY5ZmQ3Njc2YmUkdmFyJGRyYWdnaW5nRWxlbWVudHMucHVzaCh0YXJnZXQpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlRHJhZ2dlZCwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgfTtcbiAgICBsZXQgb25Nb3VzZUVudGVyID0gKCk9PntcbiAgICAgICAgaWYgKG9uSG92ZXIpIG9uSG92ZXIodHJ1ZSk7XG4gICAgfTtcbiAgICBsZXQgb25Nb3VzZU91dCA9ICgpPT57XG4gICAgICAgIGlmIChvbkhvdmVyKSBvbkhvdmVyKGZhbHNlKTtcbiAgICB9O1xuICAgIGxldCBvbktleURvd24gPSAoZSk9PntcbiAgICAgICAgc3dpdGNoKGUua2V5KXtcbiAgICAgICAgICAgIGNhc2UgXCJMZWZ0XCI6XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkRlY3JlbWVudCAmJiAhcmV2ZXJzZSkgb25EZWNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob25JbmNyZW1lbnQgJiYgcmV2ZXJzZSkgb25JbmNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVXBcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25EZWNyZW1lbnQgJiYgIXJldmVyc2UpIG9uRGVjcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uSW5jcmVtZW50ICYmIHJldmVyc2UpIG9uSW5jcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJpZ2h0XCI6XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25JbmNyZW1lbnQgJiYgIXJldmVyc2UpIG9uSW5jcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uRGVjcmVtZW50ICYmIHJldmVyc2UpIG9uRGVjcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRvd25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkluY3JlbWVudCAmJiAhcmV2ZXJzZSkgb25JbmNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob25EZWNyZW1lbnQgJiYgcmV2ZXJzZSkgb25EZWNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAob25EZWNyZW1lbnRUb01pbikgb25EZWNyZW1lbnRUb01pbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAob25JbmNyZW1lbnRUb01heCkgb25JbmNyZW1lbnRUb01heCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChvbkNvbGxhcHNlVG9nZ2xlKSBvbkNvbGxhcHNlVG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIG9uTW91c2VEb3duOiBvbk1vdXNlRG93bixcbiAgICAgICAgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXIsXG4gICAgICAgIG9uTW91c2VPdXQ6IG9uTW91c2VPdXQsXG4gICAgICAgIG9uS2V5RG93bjogb25LZXlEb3duXG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMDNkZWIyM2ZmMTQ5MjBjNCRleHBvcnQkNGVhZjA0ZTU0YWE4ZWVkNigpIHtcbiAgICBsZXQgZ2xvYmFsTGlzdGVuZXJzID0gKDAsICQxMnVHcCR1c2VSZWYpKG5ldyBNYXAoKSk7XG4gICAgbGV0IGFkZEdsb2JhbExpc3RlbmVyID0gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKGV2ZW50VGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk9PntcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHJlbW92ZSB0aGUgbGlzdGVuZXIgYWZ0ZXIgaXQgaXMgY2FsbGVkIHdpdGggdGhlIGBvbmNlYCBvcHRpb24uXG4gICAgICAgIGxldCBmbiA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25jZSkgPyAoLi4uYXJncyk9PntcbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVycy5jdXJyZW50LmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgICAgICBsaXN0ZW5lciguLi5hcmdzKTtcbiAgICAgICAgfSA6IGxpc3RlbmVyO1xuICAgICAgICBnbG9iYWxMaXN0ZW5lcnMuY3VycmVudC5zZXQobGlzdGVuZXIsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBldmVudFRhcmdldDogZXZlbnRUYXJnZXQsXG4gICAgICAgICAgICBmbjogZm4sXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICB9LCBbXSk7XG4gICAgbGV0IHJlbW92ZUdsb2JhbExpc3RlbmVyID0gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKGV2ZW50VGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk9PntcbiAgICAgICAgdmFyIF9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQ7XG4gICAgICAgIGxldCBmbiA9ICgoX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldCA9IGdsb2JhbExpc3RlbmVycy5jdXJyZW50LmdldChsaXN0ZW5lcikpID09PSBudWxsIHx8IF9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQuZm4pIHx8IGxpc3RlbmVyO1xuICAgICAgICBldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcbiAgICAgICAgZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9LCBbXSk7XG4gICAgbGV0IHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycyA9ICgwLCAkMTJ1R3AkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIGdsb2JhbExpc3RlbmVycy5jdXJyZW50LmZvckVhY2goKHZhbHVlLCBrZXkpPT57XG4gICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih2YWx1ZS5ldmVudFRhcmdldCwgdmFsdWUudHlwZSwga2V5LCB2YWx1ZS5vcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lclxuICAgIF0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHJldHVybiByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnM7XG4gICAgfSwgW1xuICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnNcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcjogYWRkR2xvYmFsTGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyOiByZW1vdmVHbG9iYWxMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzOiByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnNcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQzMTNiOTg4NjFlZTVkZDZjJGV4cG9ydCRkNjg3NTEyMjE5NGM3YjQ0KHByb3BzLCBkZWZhdWx0TGFiZWwpIHtcbiAgICBsZXQgeyBpZDogaWQsIFwiYXJpYS1sYWJlbFwiOiBsYWJlbCwgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRCeSB9ID0gcHJvcHM7XG4gICAgLy8gSWYgdGhlcmUgaXMgYm90aCBhbiBhcmlhLWxhYmVsIGFuZCBhcmlhLWxhYmVsbGVkYnksXG4gICAgLy8gY29tYmluZSB0aGVtIGJ5IHBvaW50aW5nIHRvIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICBpZCA9ICgwLCAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkZjY4MDg3N2EzNDcxMWUzNykoaWQpO1xuICAgIGlmIChsYWJlbGxlZEJ5ICYmIGxhYmVsKSB7XG4gICAgICAgIGxldCBpZHMgPSBuZXcgU2V0KFtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgLi4ubGFiZWxsZWRCeS50cmltKCkuc3BsaXQoL1xccysvKVxuICAgICAgICBdKTtcbiAgICAgICAgbGFiZWxsZWRCeSA9IFtcbiAgICAgICAgICAgIC4uLmlkc1xuICAgICAgICBdLmpvaW4oXCIgXCIpO1xuICAgIH0gZWxzZSBpZiAobGFiZWxsZWRCeSkgbGFiZWxsZWRCeSA9IGxhYmVsbGVkQnkudHJpbSgpLnNwbGl0KC9cXHMrLykuam9pbihcIiBcIik7XG4gICAgLy8gSWYgbm8gbGFiZWxzIGFyZSBwcm92aWRlZCwgdXNlIHRoZSBkZWZhdWx0XG4gICAgaWYgKCFsYWJlbCAmJiAhbGFiZWxsZWRCeSAmJiBkZWZhdWx0TGFiZWwpIGxhYmVsID0gZGVmYXVsdExhYmVsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGxhYmVsLFxuICAgICAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBsYWJlbGxlZEJ5XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkZGY1NjE2NGRmZjU3ODVlMiRleHBvcnQkNDMzOGI1MzMxNWFiZjY2Nihmb3J3YXJkZWRSZWYpIHtcbiAgICBjb25zdCBvYmpSZWYgPSAoMCwgJDEydUdwJHVzZVJlZikoKTtcbiAgICByZXR1cm4gKDAsICQxMnVHcCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIGdldCBjdXJyZW50ICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IGN1cnJlbnQgKHZhbHVlKXtcbiAgICAgICAgICAgICAgICBvYmpSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcImZ1bmN0aW9uXCIpIGZvcndhcmRlZFJlZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yd2FyZGVkUmVmKSBmb3J3YXJkZWRSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgW1xuICAgICAgICBmb3J3YXJkZWRSZWZcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNGY1OGM1ZjcyYmNmNzlmNyRleHBvcnQkNDk2MzE1YTE2MDhkOTYwMihlZmZlY3QsIGRlcGVuZGVuY2llcykge1xuICAgIGNvbnN0IGlzSW5pdGlhbE1vdW50ID0gKDAsICQxMnVHcCR1c2VSZWYpKHRydWUpO1xuICAgIGNvbnN0IGxhc3REZXBzID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpc0luaXRpYWxNb3VudC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpc0luaXRpYWxNb3VudC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoaXNJbml0aWFsTW91bnQuY3VycmVudCkgaXNJbml0aWFsTW91bnQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmICghbGFzdERlcHMuY3VycmVudCB8fCBkZXBlbmRlbmNpZXMuc29tZSgoZGVwLCBpKT0+IU9iamVjdC5pcyhkZXAsIGxhc3REZXBzW2ldKSkpIGVmZmVjdCgpO1xuICAgICAgICBsYXN0RGVwcy5jdXJyZW50ID0gZGVwZW5kZW5jaWVzO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBkZXBlbmRlbmNpZXMpO1xufVxuXG5cblxuXG5mdW5jdGlvbiAkOWRhYWIwMmQ0NjE4MDlkYiR2YXIkaGFzUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiAkOWRhYWIwMmQ0NjE4MDlkYiRleHBvcnQkNjgzNDgwZjE5MWMwZTNlYShvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZWY6IHJlZiwgb25SZXNpemU6IG9uUmVzaXplIH0gPSBvcHRpb25zO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgZWxlbWVudCA9IHJlZiA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcbiAgICAgICAgaWYgKCEkOWRhYWIwMmQ0NjE4MDlkYiR2YXIkaGFzUmVzaXplT2JzZXJ2ZXIoKSkge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXJJbnN0YW5jZSA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG9uUmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVySW5zdGFuY2Uub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSByZXNpemVPYnNlcnZlckluc3RhbmNlLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uUmVzaXplLFxuICAgICAgICByZWZcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkZTc4MDFiZTgyYjRiMmE1MyRleHBvcnQkNGRlYmRiMWEzZjBmYTc5ZShjb250ZXh0LCByZWYpIHtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQucmVmICYmIHJlZikge1xuICAgICAgICAgICAgY29udGV4dC5yZWYuY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCRjZmEyMjI1ZTg3OTM4NzgxKG5vZGUpIHtcbiAgICBpZiAoJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JDJiYjc0NzQwYzRlMTlkZWYobm9kZSkpIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgd2hpbGUobm9kZSAmJiAhJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JDJiYjc0NzQwYzRlMTlkZWYobm9kZSkpbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICByZXR1cm4gbm9kZSB8fCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmKG5vZGUpIHtcbiAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICByZXR1cm4gLyhhdXRvfHNjcm9sbCkvLnRlc3Qoc3R5bGUub3ZlcmZsb3cgKyBzdHlsZS5vdmVyZmxvd1ggKyBzdHlsZS5vdmVyZmxvd1kpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuLy8gQHRzLWlnbm9yZVxubGV0ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cudmlzdWFsVmlld3BvcnQ7XG5mdW5jdGlvbiAkNWRmNjRiMzgwN2RjMTVlZSRleHBvcnQkZDY5OTkwNWRkNTdjNzNjYSgpIHtcbiAgICBsZXQgaXNTU1IgPSAoMCwgJDEydUdwJHVzZUlzU1NSKSgpO1xuICAgIGxldCBbc2l6ZSwgc2V0U2l6ZV0gPSAoMCwgJDEydUdwJHVzZVN0YXRlKSgoKT0+aXNTU1IgPyB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9IDogJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJGdldFZpZXdwb3J0U2l6ZSgpKTtcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgLy8gVXNlIHZpc3VhbFZpZXdwb3J0IGFwaSB0byB0cmFjayBhdmFpbGFibGUgaGVpZ2h0IGV2ZW4gb24gaU9TIHZpcnR1YWwga2V5Ym9hcmQgb3BlbmluZ1xuICAgICAgICBsZXQgb25SZXNpemUgPSAoKT0+e1xuICAgICAgICAgICAgc2V0U2l6ZSgoc2l6ZSk9PntcbiAgICAgICAgICAgICAgICBsZXQgbmV3U2l6ZSA9ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciRnZXRWaWV3cG9ydFNpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3U2l6ZS53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJiBuZXdTaXplLmhlaWdodCA9PT0gc2l6ZS5oZWlnaHQpIHJldHVybiBzaXplO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTaXplO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0KSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG4gICAgICAgIGVsc2UgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmICghJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0KSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG4gICAgICAgICAgICBlbHNlICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkZ2V0Vmlld3BvcnRTaXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiAoJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0LndpZHRoKSB8fCB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiAoJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0LmhlaWdodCkgfHwgd2luZG93LmlubmVySGVpZ2h0XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmxldCAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25JZCA9IDA7XG5jb25zdCAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25Ob2RlcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uICRlZjA2MjU2MDc5Njg2YmEwJGV4cG9ydCRmOGFlZGE3YjEwNzUzZmExKGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IFtpZCwgc2V0SWRdID0gKDAsICQxMnVHcCR1c2VTdGF0ZSkodW5kZWZpbmVkKTtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIGlmICghZGVzY3JpcHRpb24pIHJldHVybjtcbiAgICAgICAgbGV0IGRlc2MgPSAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25Ob2Rlcy5nZXQoZGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAoIWRlc2MpIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGByZWFjdC1hcmlhLWRlc2NyaXB0aW9uLSR7JGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uSWQrK31gO1xuICAgICAgICAgICAgc2V0SWQoaWQpO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgbm9kZS5pZCA9IGlkO1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICByZWZDb3VudDogMCxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uTm9kZXMuc2V0KGRlc2NyaXB0aW9uLCBkZXNjKTtcbiAgICAgICAgfSBlbHNlIHNldElkKGRlc2MuZWxlbWVudC5pZCk7XG4gICAgICAgIGRlc2MucmVmQ291bnQrKztcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoLS1kZXNjLnJlZkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVzYy5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICRlZjA2MjU2MDc5Njg2YmEwJHZhciRkZXNjcmlwdGlvbk5vZGVzLmRlbGV0ZShkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBkZXNjcmlwdGlvblxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiBkZXNjcmlwdGlvbiA/IGlkIDogdW5kZWZpbmVkXG4gICAgfTtcbn1cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJGU5ZmFhZmI2NDFlMTY3ZGIkZXhwb3J0JDkwZmMzYTE3ZDkzZjcwNGMocmVmLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGxldCBoYW5kbGVFdmVudCA9ICgwLCAkOGFlMDVlYWE1YzExNGU5YyRleHBvcnQkN2Y1NGZjMzE4MDUwOGE1MikoaGFuZGxlcik7XG4gICAgbGV0IGlzRGlzYWJsZWQgPSBoYW5kbGVyID09IG51bGw7XG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChpc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgIGxldCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlRXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlRXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcmVmLFxuICAgICAgICBldmVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgaGFuZGxlRXZlbnRcbiAgICBdKTtcbn1cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCQ1M2EwOTEwZjAzODMzN2JkKHNjcm9sbFZpZXcsIGVsZW1lbnQpIHtcbiAgICBsZXQgb2Zmc2V0WCA9ICQyZjA0Y2JjNDRlZTMwY2UwJHZhciRyZWxhdGl2ZU9mZnNldChzY3JvbGxWaWV3LCBlbGVtZW50LCBcImxlZnRcIik7XG4gICAgbGV0IG9mZnNldFkgPSAkMmYwNGNiYzQ0ZWUzMGNlMCR2YXIkcmVsYXRpdmVPZmZzZXQoc2Nyb2xsVmlldywgZWxlbWVudCwgXCJ0b3BcIik7XG4gICAgbGV0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICBsZXQgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHggPSBzY3JvbGxWaWV3LnNjcm9sbExlZnQ7XG4gICAgbGV0IHkgPSBzY3JvbGxWaWV3LnNjcm9sbFRvcDtcbiAgICAvLyBBY2NvdW50IGZvciB0b3AvbGVmdCBib3JkZXIgb2Zmc2V0dGluZyB0aGUgc2Nyb2xsIHRvcC9MZWZ0XG4gICAgbGV0IHsgYm9yZGVyVG9wV2lkdGg6IGJvcmRlclRvcFdpZHRoLCBib3JkZXJMZWZ0V2lkdGg6IGJvcmRlckxlZnRXaWR0aCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxWaWV3KTtcbiAgICBsZXQgYm9yZGVyQWRqdXN0ZWRYID0gc2Nyb2xsVmlldy5zY3JvbGxMZWZ0ICsgcGFyc2VJbnQoYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG4gICAgbGV0IGJvcmRlckFkanVzdGVkWSA9IHNjcm9sbFZpZXcuc2Nyb2xsVG9wICsgcGFyc2VJbnQoYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgICAvLyBJZ25vcmUgZW5kL2JvdHRvbSBib3JkZXIgdmlhIGNsaWVudEhlaWdodC9XaWR0aCBpbnN0ZWFkIG9mIG9mZnNldEhlaWdodC9XaWR0aFxuICAgIGxldCBtYXhYID0gYm9yZGVyQWRqdXN0ZWRYICsgc2Nyb2xsVmlldy5jbGllbnRXaWR0aDtcbiAgICBsZXQgbWF4WSA9IGJvcmRlckFkanVzdGVkWSArIHNjcm9sbFZpZXcuY2xpZW50SGVpZ2h0O1xuICAgIGlmIChvZmZzZXRYIDw9IHgpIHggPSBvZmZzZXRYIC0gcGFyc2VJbnQoYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG4gICAgZWxzZSBpZiAob2Zmc2V0WCArIHdpZHRoID4gbWF4WCkgeCArPSBvZmZzZXRYICsgd2lkdGggLSBtYXhYO1xuICAgIGlmIChvZmZzZXRZIDw9IGJvcmRlckFkanVzdGVkWSkgeSA9IG9mZnNldFkgLSBwYXJzZUludChib3JkZXJUb3BXaWR0aCwgMTApO1xuICAgIGVsc2UgaWYgKG9mZnNldFkgKyBoZWlnaHQgPiBtYXhZKSB5ICs9IG9mZnNldFkgKyBoZWlnaHQgLSBtYXhZO1xuICAgIHNjcm9sbFZpZXcuc2Nyb2xsTGVmdCA9IHg7XG4gICAgc2Nyb2xsVmlldy5zY3JvbGxUb3AgPSB5O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgb2Zmc2V0IGxlZnQgb3IgdG9wIGZyb20gY2hpbGQgdG8gYW5jZXN0b3IgYnkgYWNjdW11bGF0aW5nXG4gKiBvZmZzZXRMZWZ0IG9yIG9mZnNldFRvcCB0aHJvdWdoIGludGVydmVuaW5nIG9mZnNldFBhcmVudHMuXG4gKi8gZnVuY3Rpb24gJDJmMDRjYmM0NGVlMzBjZTAkdmFyJHJlbGF0aXZlT2Zmc2V0KGFuY2VzdG9yLCBjaGlsZCwgYXhpcykge1xuICAgIGNvbnN0IHByb3AgPSBheGlzID09PSBcImxlZnRcIiA/IFwib2Zmc2V0TGVmdFwiIDogXCJvZmZzZXRUb3BcIjtcbiAgICBsZXQgc3VtID0gMDtcbiAgICB3aGlsZShjaGlsZC5vZmZzZXRQYXJlbnQpe1xuICAgICAgICBzdW0gKz0gY2hpbGRbcHJvcF07XG4gICAgICAgIGlmIChjaGlsZC5vZmZzZXRQYXJlbnQgPT09IGFuY2VzdG9yKSBicmVhaztcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQub2Zmc2V0UGFyZW50LmNvbnRhaW5zKGFuY2VzdG9yKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGFuY2VzdG9yIGlzIG5vdCBgcG9zaXRpb246cmVsYXRpdmVgLCB0aGVuIHdlIHN0b3AgYXRcbiAgICAgICAgICAgIC8vIF9pdHNfIG9mZnNldCBwYXJlbnQsIGFuZCB3ZSBzdWJ0cmFjdCBvZmYgX2l0c18gb2Zmc2V0LCBzbyB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBlbmQgdXAgd2l0aCB0aGUgcHJvcGVyIG9mZnNldCBmcm9tIGNoaWxkIHRvIGFuY2VzdG9yLlxuICAgICAgICAgICAgc3VtIC09IGFuY2VzdG9yW3Byb3BdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5mdW5jdGlvbiAkMmYwNGNiYzQ0ZWUzMGNlMCRleHBvcnQkYzgyNjg2MDc5NjMwOWQxYih0YXJnZXRFbGVtZW50LCBvcHRzKSB7XG4gICAgaWYgKGRvY3VtZW50LmNvbnRhaW5zKHRhcmdldEVsZW1lbnQpKSB7XG4gICAgICAgIGxldCByb290ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGxldCBpc1Njcm9sbFByZXZlbnRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpLm92ZXJmbG93ID09PSBcImhpZGRlblwiO1xuICAgICAgICAvLyBJZiBzY3JvbGxpbmcgaXMgbm90IGN1cnJlbnRseSBwcmV2ZW50ZWQgdGhlbiB3ZSBhcmVu4oCZdCBpbiBhIG92ZXJsYXkgbm9yIGlzIGEgb3ZlcmxheSBvcGVuLCBqdXN0IHVzZSBlbGVtZW50LnNjcm9sbEludG9WaWV3IHRvIGJyaW5nIHRoZSBlbGVtZW50IGludG8gdmlld1xuICAgICAgICBpZiAoIWlzU2Nyb2xsUHJldmVudGVkKSB7XG4gICAgICAgICAgICB2YXIgLy8gdXNlIHNjcm9sbEludG9WaWV3KHtibG9jazogJ25lYXJlc3QnfSkgaW5zdGVhZCBvZiAuZm9jdXMgdG8gY2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgZnVsbHkgaW4gdmlldyBvciBub3Qgc2luY2UgLmZvY3VzKClcbiAgICAgICAgICAgIC8vIHdvbid0IGNhdXNlIGEgc2Nyb2xsIGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCBhbmQgZG9lc24ndCBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gYW4gZWxlbWVudCBpcyBwYXJ0aWFsbHkgb3V0IG9mIHZpZXcgaG9yaXpvbnRhbGx5IHZzIHZlcnRpY2FsbHlcbiAgICAgICAgICAgIF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3O1xuICAgICAgICAgICAgbGV0IHsgbGVmdDogb3JpZ2luYWxMZWZ0LCB0b3A6IG9yaWdpbmFsVG9wIH0gPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9PT0gbnVsbCB8fCB0YXJnZXRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcgPSB0YXJnZXRFbGVtZW50LnNjcm9sbEludG9WaWV3KSA9PT0gbnVsbCB8fCBfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcuY2FsbCh0YXJnZXRFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCB7IGxlZnQ6IG5ld0xlZnQsIHRvcDogbmV3VG9wIH0gPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgLy8gQWNjb3VudCBmb3Igc3ViIHBpeGVsIGRpZmZlcmVuY2VzIGZyb20gcm91bmRpbmdcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhvcmlnaW5hbExlZnQgLSBuZXdMZWZ0KSA+IDEgfHwgTWF0aC5hYnMob3JpZ2luYWxUb3AgLSBuZXdUb3ApID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBfb3B0c19jb250YWluaW5nRWxlbWVudF9zY3JvbGxJbnRvVmlldywgX29wdHNfY29udGFpbmluZ0VsZW1lbnQsIF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MTtcbiAgICAgICAgICAgICAgICBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfb3B0c19jb250YWluaW5nRWxlbWVudCA9IG9wdHMuY29udGFpbmluZ0VsZW1lbnQpID09PSBudWxsIHx8IF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX29wdHNfY29udGFpbmluZ0VsZW1lbnRfc2Nyb2xsSW50b1ZpZXcgPSBfb3B0c19jb250YWluaW5nRWxlbWVudC5zY3JvbGxJbnRvVmlldykgPT09IG51bGwgfHwgX29wdHNfY29udGFpbmluZ0VsZW1lbnRfc2Nyb2xsSW50b1ZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50X3Njcm9sbEludG9WaWV3LmNhbGwoX29wdHNfY29udGFpbmluZ0VsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZTogXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIChfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldzEgPSB0YXJnZXRFbGVtZW50LnNjcm9sbEludG9WaWV3KSA9PT0gbnVsbCB8fCBfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MS5jYWxsKHRhcmdldEVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsUGFyZW50ID0gKDAsICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCRjZmEyMjI1ZTg3OTM4NzgxKSh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgIC8vIElmIHNjcm9sbGluZyBpcyBwcmV2ZW50ZWQsIHdlIGRvbid0IHdhbnQgdG8gc2Nyb2xsIHRoZSBib2R5IHNpbmNlIGl0IG1pZ2h0IG1vdmUgdGhlIG92ZXJsYXkgcGFydGlhbGx5IG9mZnNjcmVlbiBhbmQgdGhlIHVzZXIgY2FuJ3Qgc2Nyb2xsIGl0IGJhY2sgaW50byB2aWV3LlxuICAgICAgICAgICAgd2hpbGUodGFyZ2V0RWxlbWVudCAmJiBzY3JvbGxQYXJlbnQgJiYgdGFyZ2V0RWxlbWVudCAhPT0gcm9vdCAmJiBzY3JvbGxQYXJlbnQgIT09IHJvb3Qpe1xuICAgICAgICAgICAgICAgICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCQ1M2EwOTEwZjAzODMzN2JkKHNjcm9sbFBhcmVudCwgdGFyZ2V0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IHNjcm9sbFBhcmVudDtcbiAgICAgICAgICAgICAgICBzY3JvbGxQYXJlbnQgPSAoMCwgJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JGNmYTIyMjVlODc5Mzg3ODEpKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDYwMjc4ODcxNDU3NjIyZGUoZXZlbnQpIHtcbiAgICAvLyBKQVdTL05WREEgd2l0aCBGaXJlZm94LlxuICAgIGlmIChldmVudC5tb3pJbnB1dFNvdXJjZSA9PT0gMCAmJiBldmVudC5pc1RydXN0ZWQpIHJldHVybiB0cnVlO1xuICAgIC8vIEFuZHJvaWQgVGFsa0JhY2sncyBkZXRhaWwgdmFsdWUgdmFyaWVzIGRlcGVuZGluZyBvbiB0aGUgZXZlbnQgbGlzdGVuZXIgcHJvdmlkaW5nIHRoZSBldmVudCBzbyB3ZSBoYXZlIHNwZWNpZmljIGxvZ2ljIGhlcmUgaW5zdGVhZFxuICAgIC8vIElmIHBvaW50ZXJUeXBlIGlzIGRlZmluZWQsIGV2ZW50IGlzIGZyb20gYSBjbGljayBsaXN0ZW5lci4gRm9yIGV2ZW50cyBmcm9tIG1vdXNlZG93biBsaXN0ZW5lciwgZGV0YWlsID09PSAwIGlzIGEgc3VmZmljaWVudCBjaGVja1xuICAgIC8vIHRvIGRldGVjdCBUYWxrQmFjayB2aXJ0dWFsIGNsaWNrcy5cbiAgICBpZiAoKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4KSgpICYmIGV2ZW50LnBvaW50ZXJUeXBlKSByZXR1cm4gZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbnMgPT09IDE7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCA9PT0gMCAmJiAhZXZlbnQucG9pbnRlclR5cGU7XG59XG5mdW5jdGlvbiAkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkMjliZjFiNWYyYzU2Y2Y2MyhldmVudCkge1xuICAgIC8vIElmIHRoZSBwb2ludGVyIHNpemUgaXMgemVybywgdGhlbiB3ZSBhc3N1bWUgaXQncyBmcm9tIGEgc2NyZWVuIHJlYWRlci5cbiAgICAvLyBBbmRyb2lkIFRhbGtCYWNrIGRvdWJsZSB0YXAgd2lsbCBzb21ldGltZXMgcmV0dXJuIGEgZXZlbnQgd2l0aCB3aWR0aCBhbmQgaGVpZ2h0IG9mIDFcbiAgICAvLyBhbmQgcG9pbnRlclR5cGUgPT09ICdtb3VzZScgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgYSBzcGVjaWZpYyBjb21iaW5hdGlvbiBvZiBldmVudCBhdHRyaWJ1dGVzLlxuICAgIC8vIENhbm5vdCB1c2UgXCJldmVudC5wcmVzc3VyZSA9PT0gMFwiIGFzIHRoZSBzb2xlIGNoZWNrIGR1ZSB0byBTYWZhcmkgcG9pbnRlciBldmVudHMgYWx3YXlzIHJldHVybmluZyBwcmVzc3VyZSA9PT0gMFxuICAgIC8vIGluc3RlYWQgb2YgLjUsIHNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA2MjE2LiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyBpcyB0byBkaXN0aW5ndXNoXG4gICAgLy8gVGFsa2JhY2sgZG91YmxlIHRhcCBmcm9tIFdpbmRvd3MgRmlyZWZveCB0b3VjaCBzY3JlZW4gcHJlc3NcbiAgICByZXR1cm4gISgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCkoKSAmJiBldmVudC53aWR0aCA9PT0gMCAmJiBldmVudC5oZWlnaHQgPT09IDAgfHwgZXZlbnQud2lkdGggPT09IDEgJiYgZXZlbnQuaGVpZ2h0ID09PSAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMCAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiO1xufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qIGVzbGludC1kaXNhYmxlIHJ1bGVzZGlyL3B1cmUtcmVuZGVyICovIFxuZnVuY3Rpb24gJDVhMzg3Y2M0OTM1MGU2ZGIkZXhwb3J0JDcyMmRlYmMwZTU2ZmVhMzkodmFsdWUsIGlzRXF1YWwpIHtcbiAgICAvLyBVc2luZyBhIHJlZiBkdXJpbmcgcmVuZGVyIGlzIG9rIGhlcmUgYmVjYXVzZSBpdCdzIG9ubHkgYW4gb3B0aW1pemF0aW9uIOKAkyBib3RoIHZhbHVlcyBhcmUgZXF1aXZhbGVudC5cbiAgICAvLyBJZiBhIHJlbmRlciBpcyB0aHJvd24gYXdheSwgaXQnbGwgc3RpbGwgd29yayB0aGUgc2FtZSBubyBtYXR0ZXIgaWYgdGhlIG5leHQgcmVuZGVyIGlzIHRoZSBzYW1lIG9yIG5vdC5cbiAgICBsZXQgbGFzdFZhbHVlID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgIGlmICh2YWx1ZSAmJiBsYXN0VmFsdWUuY3VycmVudCAmJiBpc0VxdWFsKHZhbHVlLCBsYXN0VmFsdWUuY3VycmVudCkpIHZhbHVlID0gbGFzdFZhbHVlLmN1cnJlbnQ7XG4gICAgbGFzdFZhbHVlLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkOTlmYWNhYjczMjY2ZjY2MiRleHBvcnQkNWFkZDFkMDA2MjkzZDEzNihyZWYsIGluaXRpYWxWYWx1ZSwgb25SZXNldCkge1xuICAgIGxldCByZXNldFZhbHVlID0gKDAsICQxMnVHcCR1c2VSZWYpKGluaXRpYWxWYWx1ZSk7XG4gICAgbGV0IGhhbmRsZVJlc2V0ID0gKDAsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKSgoKT0+e1xuICAgICAgICBpZiAob25SZXNldCkgb25SZXNldChyZXNldFZhbHVlLmN1cnJlbnQpO1xuICAgIH0pO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICB2YXIgX3JlZl9jdXJyZW50O1xuICAgICAgICBsZXQgZm9ybSA9IHJlZiA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfcmVmX2N1cnJlbnQgPSByZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlZl9jdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVmX2N1cnJlbnQuZm9ybTtcbiAgICAgICAgZm9ybSA9PT0gbnVsbCB8fCBmb3JtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZm9ybSA9PT0gbnVsbCB8fCBmb3JtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByZWYsXG4gICAgICAgIGhhbmRsZVJlc2V0XG4gICAgXSk7XG59XG5cblxuXG5cbmV4cG9ydCB7JGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGY2ODA4NzdhMzQ3MTFlMzcgYXMgdXNlSWQsICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRjZDhjOWNiNjhmODQyNjI5IGFzIG1lcmdlSWRzLCAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkYjRjYzA5YzU5MmU4ZmRiOCBhcyB1c2VTbG90SWQsICRmZjU5NjNlYjFmY2NmNTUyJGV4cG9ydCRlMDhlM2I2N2UzOTIxMDFlIGFzIGNoYWluLCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyBhcyBnZXRPd25lckRvY3VtZW50LCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkZjIxYTFmZmFlMjYwMTQ1YSBhcyBnZXRPd25lcldpbmRvdywgJDNlZjQyNTc1ZGY4NGIzMGIkZXhwb3J0JDlkMTYxMWM3N2MyZmU5MjggYXMgbWVyZ2VQcm9wcywgJDVkYzk1ODk5YjMwNmY2MzAkZXhwb3J0JGM5MDU4MzE2NzY0YzE0MGUgYXMgbWVyZ2VSZWZzLCAkNjU0ODRkMDJkY2I3ZWIzZSRleHBvcnQkNDU3YzNkNjUxOGRkNGM2ZiBhcyBmaWx0ZXJET01Qcm9wcywgJDcyMTVhZmM2ZGU2MDZkNmIkZXhwb3J0JGRlNzllMmM2OTVlMDUyZjMgYXMgZm9jdXNXaXRob3V0U2Nyb2xsaW5nLCAkYWI3MWRhZGIwM2E2ZmIyZSRleHBvcnQkNjIyY2VhNDQ1YTFjNWI3ZCBhcyBnZXRPZmZzZXQsICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3IGFzIG9wZW5MaW5rLCAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkNTE0MzdkNTAzMzczZDIyMyBhcyBnZXRTeW50aGV0aWNMaW5rUHJvcHMsICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQzMjNlNGZjMmZhNDc1M2ZiIGFzIFJvdXRlclByb3ZpZGVyLCAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkZWZhOGM5MDk5ZTUzMDIzNSBhcyBzaG91bGRDbGllbnROYXZpZ2F0ZSwgJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDlhMzAyYTQ1ZjY1ZDA1NzIgYXMgdXNlUm91dGVyLCAkYmJlZDhiNDFmODU3YmNjMCRleHBvcnQkMjQ0OTAzMTZmNzY0YzQzMCBhcyBydW5BZnRlclRyYW5zaXRpb24sICQ5Y2MwOWRmOWZkNzY3NmJlJGV4cG9ydCQ3YmJlZDc1ZmViYTM5NzA2IGFzIHVzZURyYWcxRCwgJDAzZGViMjNmZjE0OTIwYzQkZXhwb3J0JDRlYWYwNGU1NGFhOGVlZDYgYXMgdXNlR2xvYmFsTGlzdGVuZXJzLCAkMzEzYjk4ODYxZWU1ZGQ2YyRleHBvcnQkZDY4NzUxMjIxOTRjN2I0NCBhcyB1c2VMYWJlbHMsICRkZjU2MTY0ZGZmNTc4NWUyJGV4cG9ydCQ0MzM4YjUzMzE1YWJmNjY2IGFzIHVzZU9iamVjdFJlZiwgJDRmNThjNWY3MmJjZjc5ZjckZXhwb3J0JDQ5NjMxNWExNjA4ZDk2MDIgYXMgdXNlVXBkYXRlRWZmZWN0LCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYyBhcyB1c2VMYXlvdXRFZmZlY3QsICQ5ZGFhYjAyZDQ2MTgwOWRiJGV4cG9ydCQ2ODM0ODBmMTkxYzBlM2VhIGFzIHVzZVJlc2l6ZU9ic2VydmVyLCAkZTc4MDFiZTgyYjRiMmE1MyRleHBvcnQkNGRlYmRiMWEzZjBmYTc5ZSBhcyB1c2VTeW5jUmVmLCAkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkY2ZhMjIyNWU4NzkzODc4MSBhcyBnZXRTY3JvbGxQYXJlbnQsICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmIGFzIGlzU2Nyb2xsYWJsZSwgJDVkZjY0YjM4MDdkYzE1ZWUkZXhwb3J0JGQ2OTk5MDVkZDU3YzczY2EgYXMgdXNlVmlld3BvcnRTaXplLCAkZWYwNjI1NjA3OTY4NmJhMCRleHBvcnQkZjhhZWRhN2IxMDc1M2ZhMSBhcyB1c2VEZXNjcmlwdGlvbiwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAgYXMgaXNNYWMsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQxODZjNjk2NGNhMTdkOTkgYXMgaXNJUGhvbmUsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0IGFzIGlzSVBhZCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGZlZGIzNjljYjcwMjA3ZjEgYXMgaXNJT1MsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRlMTg2NWMzYmVkY2Q4MjJiIGFzIGlzQXBwbGVEZXZpY2UsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3ODU1MTA0MzU4MmE2YTk4IGFzIGlzV2ViS2l0LCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNjQ0NmExODZkMDllMzc5ZSBhcyBpc0Nocm9tZSwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGExMWIwMDU5OTAwY2VlYzggYXMgaXNBbmRyb2lkLCAkZTlmYWFmYjY0MWUxNjdkYiRleHBvcnQkOTBmYzNhMTdkOTNmNzA0YyBhcyB1c2VFdmVudCwgJDFkYmVjYmUyN2EwNGY5YWYkZXhwb3J0JDE0ZDIzOGYzNDI3MjNmMjUgYXMgdXNlVmFsdWVFZmZlY3QsICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCQ1M2EwOTEwZjAzODMzN2JkIGFzIHNjcm9sbEludG9WaWV3LCAkMmYwNGNiYzQ0ZWUzMGNlMCRleHBvcnQkYzgyNjg2MDc5NjMwOWQxYiBhcyBzY3JvbGxJbnRvVmlld3BvcnQsICQ0NTA3NDYxYTFiODcwMTIzJHJlX2V4cG9ydCRjbGFtcCBhcyBjbGFtcCwgJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JHNuYXBWYWx1ZVRvU3RlcCBhcyBzbmFwVmFsdWVUb1N0ZXAsICQ2YTdkYjg1NDMyNDQ4ZjdmJGV4cG9ydCQ2MDI3ODg3MTQ1NzYyMmRlIGFzIGlzVmlydHVhbENsaWNrLCAkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkMjliZjFiNWYyYzU2Y2Y2MyBhcyBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyIGFzIHVzZUVmZmVjdEV2ZW50LCAkNWEzODdjYzQ5MzUwZTZkYiRleHBvcnQkNzIyZGViYzBlNTZmZWEzOSBhcyB1c2VEZWVwTWVtbywgJDk5ZmFjYWI3MzI2NmY2NjIkZXhwb3J0JDVhZGQxZDAwNjI5M2QxMzYgYXMgdXNlRm9ybVJlc2V0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjbGFtcCIsIiQ0NTA3NDYxYTFiODcwMTIzJHJlX2V4cG9ydCRjbGFtcCIsInNuYXBWYWx1ZVRvU3RlcCIsIiQ0NTA3NDYxYTFiODcwMTIzJHJlX2V4cG9ydCRzbmFwVmFsdWVUb1N0ZXAiLCIkMTJ1R3AkcmVhY3QiLCJ1c2VTdGF0ZSIsIiQxMnVHcCR1c2VTdGF0ZSIsInVzZVJlZiIsIiQxMnVHcCR1c2VSZWYiLCJ1c2VDYWxsYmFjayIsIiQxMnVHcCR1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsIiQxMnVHcCR1c2VFZmZlY3QiLCJjcmVhdGVDb250ZXh0IiwiJDEydUdwJGNyZWF0ZUNvbnRleHQiLCJ1c2VNZW1vIiwiJDEydUdwJHVzZU1lbW8iLCJ1c2VDb250ZXh0IiwiJDEydUdwJHVzZUNvbnRleHQiLCJ1c2VTU1JTYWZlSWQiLCIkMTJ1R3AkdXNlU1NSU2FmZUlkIiwidXNlSXNTU1IiLCIkMTJ1R3AkdXNlSXNTU1IiLCIkMTJ1R3AkY2xzeCIsIiRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjIiwiZG9jdW1lbnQiLCJ1c2VMYXlvdXRFZmZlY3QiLCIkOGFlMDVlYWE1YzExNGU5YyRleHBvcnQkN2Y1NGZjMzE4MDUwOGE1MiIsImZuIiwicmVmIiwiY3VycmVudCIsImFyZ3MiLCJmIiwiJDFkYmVjYmUyN2EwNGY5YWYkZXhwb3J0JDE0ZDIzOGYzNDI3MjNmMjUiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZSIsInNldFZhbHVlIiwiZWZmZWN0IiwibmV4dFJlZiIsIm5ld1ZhbHVlIiwibmV4dCIsImRvbmUiLCJxdWV1ZSIsIiRiZGIxMTAxMGNlZjcwMjM2JHZhciRjYW5Vc2VET00iLCJCb29sZWFuIiwid2luZG93IiwiY3JlYXRlRWxlbWVudCIsIiRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwIiwiTWFwIiwiJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGY2ODA4NzdhMzQ3MTFlMzciLCJkZWZhdWx0SWQiLCJuZXh0SWQiLCJyZXMiLCJ1cGRhdGVWYWx1ZSIsInZhbCIsInNldCIsInIiLCJkZWxldGUiLCJuZXdJZCIsIiRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRjZDhjOWNiNjhmODQyNjI5IiwiaWRBIiwiaWRCIiwic2V0SWRBIiwiZ2V0Iiwic2V0SWRCIiwiJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGI0Y2MwOWM1OTJlOGZkYjgiLCJkZXBBcnJheSIsImlkIiwicmVzb2x2ZWRJZCIsInNldFJlc29sdmVkSWQiLCJ1cGRhdGVJZCIsImdldEVsZW1lbnRCeUlkIiwidW5kZWZpbmVkIiwiJGZmNTk2M2ViMWZjY2Y1NTIkZXhwb3J0JGUwOGUzYjY3ZTM5MjEwMWUiLCJjYWxsYmFja3MiLCJjYWxsYmFjayIsIiQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjIiwiZWwiLCJfZWxfb3duZXJEb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCIkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkZjIxYTFmZmFlMjYwMTQ1YSIsImRvYyIsImRlZmF1bHRWaWV3IiwiJDNlZjQyNTc1ZGY4NGIzMGIkZXhwb3J0JDlkMTYxMWM3N2MyZmU5MjgiLCJyZXN1bHQiLCJpIiwibGVuZ3RoIiwicHJvcHMiLCJrZXkiLCJhIiwiYiIsImNoYXJDb2RlQXQiLCIkNWRjOTU4OTliMzA2ZjYzMCRleHBvcnQkYzkwNTgzMTY3NjRjMTQwZSIsInJlZnMiLCIkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkRE9NUHJvcE5hbWVzIiwiU2V0IiwiJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxhYmVsYWJsZVByb3BOYW1lcyIsIiQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRsaW5rUHJvcE5hbWVzIiwiJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJHByb3BSZSIsIiQ2NTQ4NGQwMmRjYjdlYjNlJGV4cG9ydCQ0NTdjM2Q2NTE4ZGQ0YzZmIiwib3B0cyIsImxhYmVsYWJsZSIsImlzTGluayIsInByb3BOYW1lcyIsImZpbHRlcmVkUHJvcHMiLCJwcm9wIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaGFzIiwidGVzdCIsIiQ3MjE1YWZjNmRlNjA2ZDZiJGV4cG9ydCRkZTc5ZTJjNjk1ZTA1MmYzIiwiZWxlbWVudCIsIiQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGwiLCJmb2N1cyIsInByZXZlbnRTY3JvbGwiLCJzY3JvbGxhYmxlRWxlbWVudHMiLCIkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkZ2V0U2Nyb2xsYWJsZUVsZW1lbnRzIiwiJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsIiQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQiLCJmb2N1c0VsZW0iLCJlIiwicGFyZW50IiwicGFyZW50Tm9kZSIsInJvb3RTY3JvbGxpbmdFbGVtZW50Iiwic2Nyb2xsaW5nRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsIkhUTUxFbGVtZW50Iiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJzY3JvbGxXaWR0aCIsInB1c2giLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwiJGFiNzFkYWRiMDNhNmZiMmUkZXhwb3J0JDYyMmNlYTQ0NWExYzViN2QiLCJyZXZlcnNlIiwib3JpZW50YXRpb24iLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwidG9wIiwiJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQiLCJyZSIsIl93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEiLCJuYXZpZ2F0b3IiLCJicmFuZHMiLCJzb21lIiwiYnJhbmQiLCJ1c2VyQWdlbnQiLCIkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFBsYXRmb3JtIiwicGxhdGZvcm0iLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQxODZjNjk2NGNhMTdkOTkiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkN2JlZjA0OWNlOTJlNDIyNCIsIm1heFRvdWNoUG9pbnRzIiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGZlZGIzNjljYjcwMjA3ZjEiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZTE4NjVjM2JlZGNkODIyYiIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3ODU1MTA0MzU4MmE2YTk4IiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDY0NDZhMTg2ZDA5ZTM3OWUiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRiN2Q3ODk5M2I3NGY3NjZkIiwiJGVhOGRjYmNiOWVhMWI1NTYkdmFyJFJvdXRlckNvbnRleHQiLCJpc05hdGl2ZSIsIm9wZW4iLCIkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkb3BlblN5bnRoZXRpY0xpbmsiLCIkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkMzIzZTRmYzJmYTQ3NTNmYiIsImNoaWxkcmVuIiwibmF2aWdhdGUiLCJjdHgiLCJ0YXJnZXQiLCJtb2RpZmllcnMiLCIkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkZ2V0U3ludGhldGljTGluayIsImxpbmsiLCIkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkZWZhOGM5MDk5ZTUzMDIzNSIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCIsIiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3IiwiUHJvdmlkZXIiLCIkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOWEzMDJhNDVmNjVkMDU3MiIsImdldEF0dHJpYnV0ZSIsIm9yaWdpbiIsImxvY2F0aW9uIiwiaGFzQXR0cmlidXRlIiwibWV0YUtleSIsImN0cmxLZXkiLCJhbHRLZXkiLCJzaGlmdEtleSIsInNldE9wZW5pbmciLCJfd2luZG93X2V2ZW50X3R5cGUiLCJfd2luZG93X2V2ZW50IiwiZXZlbnQiLCJ0eXBlIiwic3RhcnRzV2l0aCIsIktleWJvYXJkRXZlbnQiLCJrZXlJZGVudGlmaWVyIiwiTW91c2VFdmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiaXNPcGVuaW5nIiwiZGlzcGF0Y2hFdmVudCIsIkhUTUxBbmNob3JFbGVtZW50IiwiaHJlZiIsInJlbCIsImRvd25sb2FkIiwicGluZyIsInJlZmVycmVyUG9saWN5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsIiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ1MTQzN2Q1MDMzNzNkMjIzIiwiJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50IiwiJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25DYWxsYmFja3MiLCIkYmJlZDhiNDFmODU3YmNjMCR2YXIkc2V0dXBHbG9iYWxFdmVudHMiLCJvblRyYW5zaXRpb25TdGFydCIsInRyYW5zaXRpb25zIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uVHJhbnNpdGlvbkVuZCIsImFkZCIsInByb3BlcnR5TmFtZSIsInByb3BlcnRpZXMiLCJzaXplIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNiIiwiY2xlYXIiLCJib2R5IiwicmVhZHlTdGF0ZSIsIiRiYmVkOGI0MWY4NTdiY2MwJGV4cG9ydCQyNDQ5MDMxNmY3NjRjNDMwIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiJDljYzA5ZGY5ZmQ3Njc2YmUkdmFyJGRyYWdnaW5nRWxlbWVudHMiLCIkOWNjMDlkZjlmZDc2NzZiZSRleHBvcnQkN2JiZWQ3NWZlYmEzOTcwNiIsImNvbnNvbGUiLCJ3YXJuIiwiY29udGFpbmVyUmVmIiwib25Ib3ZlciIsIm9uRHJhZyIsIm9uUG9zaXRpb25DaGFuZ2UiLCJvbkluY3JlbWVudCIsIm9uRGVjcmVtZW50Iiwib25JbmNyZW1lbnRUb01heCIsIm9uRGVjcmVtZW50VG9NaW4iLCJvbkNvbGxhcHNlVG9nZ2xlIiwiZ2V0UG9zaXRpb24iLCJjbGllbnRYIiwiY2xpZW50WSIsImdldE5leHRPZmZzZXQiLCJjb250YWluZXJPZmZzZXQiLCJtb3VzZU9mZnNldCIsIm5leHRPZmZzZXQiLCJkcmFnZ2luZyIsInByZXZQb3NpdGlvbiIsImhhbmRsZXJzIiwib25Nb3VzZURyYWdnZWQiLCJwcmV2ZW50RGVmYXVsdCIsIm9uTW91c2VVcCIsInNwbGljZSIsImluZGV4T2YiLCJvbk1vdXNlRG93biIsImN1cnJlbnRUYXJnZXQiLCJlbHQiLCJjb250YWlucyIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VPdXQiLCJvbktleURvd24iLCIkMDNkZWIyM2ZmMTQ5MjBjNCRleHBvcnQkNGVhZjA0ZTU0YWE4ZWVkNiIsImdsb2JhbExpc3RlbmVycyIsImFkZEdsb2JhbExpc3RlbmVyIiwiZXZlbnRUYXJnZXQiLCJsaXN0ZW5lciIsIm9wdGlvbnMiLCJvbmNlIiwicmVtb3ZlR2xvYmFsTGlzdGVuZXIiLCJfZ2xvYmFsTGlzdGVuZXJzX2N1cnJlbnRfZ2V0IiwicmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzIiwiZm9yRWFjaCIsIiQzMTNiOTg4NjFlZTVkZDZjJGV4cG9ydCRkNjg3NTEyMjE5NGM3YjQ0IiwiZGVmYXVsdExhYmVsIiwibGFiZWwiLCJsYWJlbGxlZEJ5IiwiaWRzIiwidHJpbSIsInNwbGl0Iiwiam9pbiIsIiRkZjU2MTY0ZGZmNTc4NWUyJGV4cG9ydCQ0MzM4YjUzMzE1YWJmNjY2IiwiZm9yd2FyZGVkUmVmIiwib2JqUmVmIiwiJDRmNThjNWY3MmJjZjc5ZjckZXhwb3J0JDQ5NjMxNWExNjA4ZDk2MDIiLCJkZXBlbmRlbmNpZXMiLCJpc0luaXRpYWxNb3VudCIsImxhc3REZXBzIiwiZGVwIiwiaXMiLCIkOWRhYWIwMmQ0NjE4MDlkYiR2YXIkaGFzUmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsIiQ5ZGFhYjAyZDQ2MTgwOWRiJGV4cG9ydCQ2ODM0ODBmMTkxYzBlM2VhIiwib25SZXNpemUiLCJyZXNpemVPYnNlcnZlckluc3RhbmNlIiwiZW50cmllcyIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCIkZTc4MDFiZTgyYjRiMmE1MyRleHBvcnQkNGRlYmRiMWEzZjBmYTc5ZSIsImNvbnRleHQiLCIkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkY2ZhMjIyNWU4NzkzODc4MSIsIm5vZGUiLCIkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkMmJiNzQ3NDBjNGUxOWRlZiIsInBhcmVudEVsZW1lbnQiLCJzdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsIiQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCIsInZpc3VhbFZpZXdwb3J0IiwiJDVkZjY0YjM4MDdkYzE1ZWUkZXhwb3J0JGQ2OTk5MDVkZDU3YzczY2EiLCJpc1NTUiIsInNldFNpemUiLCJ3aWR0aCIsImhlaWdodCIsIiQ1ZGY2NGIzODA3ZGMxNWVlJHZhciRnZXRWaWV3cG9ydFNpemUiLCJuZXdTaXplIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiJGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uSWQiLCIkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25Ob2RlcyIsIiRlZjA2MjU2MDc5Njg2YmEwJGV4cG9ydCRmOGFlZGE3YjEwNzUzZmExIiwiZGVzY3JpcHRpb24iLCJzZXRJZCIsImRlc2MiLCJkaXNwbGF5IiwidGV4dENvbnRlbnQiLCJyZWZDb3VudCIsInJlbW92ZSIsIiRlOWZhYWZiNjQxZTE2N2RiJGV4cG9ydCQ5MGZjM2ExN2Q5M2Y3MDRjIiwiaGFuZGxlciIsImhhbmRsZUV2ZW50IiwiaXNEaXNhYmxlZCIsIiQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCQ1M2EwOTEwZjAzODMzN2JkIiwic2Nyb2xsVmlldyIsIm9mZnNldFgiLCIkMmYwNGNiYzQ0ZWUzMGNlMCR2YXIkcmVsYXRpdmVPZmZzZXQiLCJvZmZzZXRZIiwieCIsInkiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlckFkanVzdGVkWCIsInBhcnNlSW50IiwiYm9yZGVyQWRqdXN0ZWRZIiwibWF4WCIsImNsaWVudFdpZHRoIiwibWF4WSIsImNsaWVudEhlaWdodCIsImFuY2VzdG9yIiwiY2hpbGQiLCJheGlzIiwic3VtIiwib2Zmc2V0UGFyZW50IiwiJDJmMDRjYmM0NGVlMzBjZTAkZXhwb3J0JGM4MjY4NjA3OTYzMDlkMWIiLCJ0YXJnZXRFbGVtZW50Iiwicm9vdCIsImlzU2Nyb2xsUHJldmVudGVkIiwiX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXciLCJvcmlnaW5hbExlZnQiLCJvcmlnaW5hbFRvcCIsInNjcm9sbEludG9WaWV3IiwiYmxvY2siLCJuZXdMZWZ0IiwibmV3VG9wIiwiTWF0aCIsImFicyIsIl9vcHRzX2NvbnRhaW5pbmdFbGVtZW50X3Njcm9sbEludG9WaWV3IiwiX29wdHNfY29udGFpbmluZ0VsZW1lbnQiLCJfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldzEiLCJjb250YWluaW5nRWxlbWVudCIsImlubGluZSIsInNjcm9sbFBhcmVudCIsIiQ2YTdkYjg1NDMyNDQ4ZjdmJGV4cG9ydCQ2MDI3ODg3MTQ1NzYyMmRlIiwibW96SW5wdXRTb3VyY2UiLCJpc1RydXN0ZWQiLCJwb2ludGVyVHlwZSIsImJ1dHRvbnMiLCJkZXRhaWwiLCIkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkMjliZjFiNWYyYzU2Y2Y2MyIsInByZXNzdXJlIiwiJDVhMzg3Y2M0OTM1MGU2ZGIkZXhwb3J0JDcyMmRlYmMwZTU2ZmVhMzkiLCJpc0VxdWFsIiwibGFzdFZhbHVlIiwiJDk5ZmFjYWI3MzI2NmY2NjIkZXhwb3J0JDVhZGQxZDAwNjI5M2QxMzYiLCJpbml0aWFsVmFsdWUiLCJvblJlc2V0IiwicmVzZXRWYWx1ZSIsImhhbmRsZVJlc2V0IiwiX3JlZl9jdXJyZW50IiwiZm9ybSIsInVzZUlkIiwibWVyZ2VJZHMiLCJ1c2VTbG90SWQiLCJjaGFpbiIsImdldE93bmVyRG9jdW1lbnQiLCJnZXRPd25lcldpbmRvdyIsIm1lcmdlUHJvcHMiLCJtZXJnZVJlZnMiLCJmaWx0ZXJET01Qcm9wcyIsImZvY3VzV2l0aG91dFNjcm9sbGluZyIsImdldE9mZnNldCIsIm9wZW5MaW5rIiwiZ2V0U3ludGhldGljTGlua1Byb3BzIiwiUm91dGVyUHJvdmlkZXIiLCJzaG91bGRDbGllbnROYXZpZ2F0ZSIsInVzZVJvdXRlciIsInJ1bkFmdGVyVHJhbnNpdGlvbiIsInVzZURyYWcxRCIsInVzZUdsb2JhbExpc3RlbmVycyIsInVzZUxhYmVscyIsInVzZU9iamVjdFJlZiIsInVzZVVwZGF0ZUVmZmVjdCIsInVzZVJlc2l6ZU9ic2VydmVyIiwidXNlU3luY1JlZiIsImdldFNjcm9sbFBhcmVudCIsImlzU2Nyb2xsYWJsZSIsInVzZVZpZXdwb3J0U2l6ZSIsInVzZURlc2NyaXB0aW9uIiwiaXNNYWMiLCJpc0lQaG9uZSIsImlzSVBhZCIsImlzSU9TIiwiaXNBcHBsZURldmljZSIsImlzV2ViS2l0IiwiaXNDaHJvbWUiLCJpc0FuZHJvaWQiLCJ1c2VFdmVudCIsInVzZVZhbHVlRWZmZWN0Iiwic2Nyb2xsSW50b1ZpZXdwb3J0IiwiaXNWaXJ0dWFsQ2xpY2siLCJpc1ZpcnR1YWxQb2ludGVyRXZlbnQiLCJ1c2VFZmZlY3RFdmVudCIsInVzZURlZXBNZW1vIiwidXNlRm9ybVJlc2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/interactions/node_modules/@react-stately/utils/dist/import.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@react-aria/interactions/node_modules/@react-stately/utils/dist/import.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ $9446cca9a3875146$export$7d15b64cf5a3a4c4),\n/* harmony export */   snapValueToStep: () => (/* binding */ $9446cca9a3875146$export$cb6e0bb50bc19463),\n/* harmony export */   toFixedNumber: () => (/* binding */ $9446cca9a3875146$export$b6268554fba451f),\n/* harmony export */   useControlledState: () => (/* binding */ $458b0a5536c1a7cf$export$40bfa8c7b0832715)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n    let [stateValue, setStateValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(value || defaultValue);\n    let isControlledRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value !== undefined);\n    let isControlled = value !== undefined;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let wasControlled = isControlledRef.current;\n        if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? \"controlled\" : \"uncontrolled\"} to ${isControlled ? \"controlled\" : \"uncontrolled\"}.`);\n        isControlledRef.current = isControlled;\n    }, [\n        isControlled\n    ]);\n    let currentValue = isControlled ? value : stateValue;\n    let setValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value, ...args)=>{\n        let onChangeCaller = (value, ...onChangeArgs)=>{\n            if (onChange) {\n                if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);\n            }\n            if (!isControlled) // calling setState multiple times with the same value only emits onChange once.\n            // We do not use a ref for this because we specifically _do_ want the value to\n            // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            currentValue = value;\n        };\n        if (typeof value === \"function\") {\n            console.warn(\"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320\");\n            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n            // when someone using useControlledState calls setControlledState(myFunc)\n            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n            let updateFunction = (oldValue, ...functionArgs)=>{\n                let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n                onChangeCaller(interceptedValue, ...args);\n                if (!isControlled) return interceptedValue;\n                return oldValue;\n            };\n            setStateValue(updateFunction);\n        } else {\n            if (!isControlled) setStateValue(value);\n            onChangeCaller(value, ...args);\n        }\n    }, [\n        isControlled,\n        currentValue,\n        onChange\n    ]);\n    return [\n        currentValue,\n        setValue\n    ];\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */ function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n    let newValue = Math.min(Math.max(value, min), max);\n    return newValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n    min = Number(min);\n    max = Number(max);\n    let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n    if (!isNaN(min)) {\n        if (snappedValue < min) snappedValue = min;\n        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n    // correct floating point behavior by rounding to step precision\n    let string = step.toString();\n    let index = string.indexOf(\".\");\n    let precision = index >= 0 ? string.length - index : 0;\n    if (precision > 0) {\n        let pow = Math.pow(10, precision);\n        snappedValue = Math.round(snappedValue * pow) / pow;\n    }\n    return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n    const pow = Math.pow(base, digits);\n    return Math.round(value * pow) / pow;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS91dGlscy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNkk7QUFFN0k7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FDRCxTQUFTUSwwQ0FBMENDLEtBQUssRUFBRUMsWUFBWSxFQUFFQyxRQUFRO0lBQzVFLElBQUksQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHLENBQUMsR0FBR1osMkNBQWMsRUFBR1EsU0FBU0M7SUFDaEUsSUFBSUksa0JBQWtCLENBQUMsR0FBR1gseUNBQVksRUFBR00sVUFBVU07SUFDbkQsSUFBSUMsZUFBZVAsVUFBVU07SUFDNUIsSUFBR1YsNENBQWUsRUFBRztRQUNsQixJQUFJWSxnQkFBZ0JILGdCQUFnQkksT0FBTztRQUMzQyxJQUFJRCxrQkFBa0JELGNBQWNHLFFBQVFDLElBQUksQ0FBQyxDQUFDLCtCQUErQixFQUFFSCxnQkFBZ0IsZUFBZSxlQUFlLElBQUksRUFBRUQsZUFBZSxlQUFlLGVBQWUsQ0FBQyxDQUFDO1FBQ3RMRixnQkFBZ0JJLE9BQU8sR0FBR0Y7SUFDOUIsR0FBRztRQUNDQTtLQUNIO0lBQ0QsSUFBSUssZUFBZUwsZUFBZVAsUUFBUUc7SUFDMUMsSUFBSVUsV0FBVyxDQUFDLEdBQUdmLDhDQUFpQixFQUFHLENBQUNFLE9BQU8sR0FBR2M7UUFDOUMsSUFBSUMsaUJBQWlCLENBQUNmLE9BQU8sR0FBR2dCO1lBQzVCLElBQUlkLFVBQVU7Z0JBQ1YsSUFBSSxDQUFDZSxPQUFPQyxFQUFFLENBQUNOLGNBQWNaLFFBQVFFLFNBQVNGLFVBQVVnQjtZQUM1RDtZQUNBLElBQUksQ0FBQ1QsY0FDTCxnRkFBZ0Y7WUFDaEYsOEVBQThFO1lBQzlFLHlGQUF5RjtZQUN6Rix1REFBdUQ7WUFDdkRLLGVBQWVaO1FBQ25CO1FBQ0EsSUFBSSxPQUFPQSxVQUFVLFlBQVk7WUFDN0JVLFFBQVFDLElBQUksQ0FBQztZQUNiLG9HQUFvRztZQUNwRyx5RUFBeUU7WUFDekUsa0lBQWtJO1lBQ2xJLGlLQUFpSztZQUNqSyx5SUFBeUk7WUFDekksSUFBSVEsaUJBQWlCLENBQUNDLFVBQVUsR0FBR0M7Z0JBQy9CLElBQUlDLG1CQUFtQnRCLE1BQU1PLGVBQWVLLGVBQWVRLGFBQWFDO2dCQUN4RU4sZUFBZU8scUJBQXFCUjtnQkFDcEMsSUFBSSxDQUFDUCxjQUFjLE9BQU9lO2dCQUMxQixPQUFPRjtZQUNYO1lBQ0FoQixjQUFjZTtRQUNsQixPQUFPO1lBQ0gsSUFBSSxDQUFDWixjQUFjSCxjQUFjSjtZQUNqQ2UsZUFBZWYsVUFBVWM7UUFDN0I7SUFDSixHQUFHO1FBQ0NQO1FBQ0FLO1FBQ0FWO0tBQ0g7SUFDRCxPQUFPO1FBQ0hVO1FBQ0FDO0tBQ0g7QUFDTDtBQUdBOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Q0FFSCxHQUFHLFNBQVNVLDBDQUEwQ3ZCLEtBQUssRUFBRXdCLE1BQU0sQ0FBQ0MsUUFBUSxFQUFFQyxNQUFNRCxRQUFRO0lBQ3pGLElBQUlFLFdBQVdDLEtBQUtKLEdBQUcsQ0FBQ0ksS0FBS0YsR0FBRyxDQUFDMUIsT0FBT3dCLE1BQU1FO0lBQzlDLE9BQU9DO0FBQ1g7QUFDQSxTQUFTRSwwQ0FBMEM3QixLQUFLLEVBQUV3QixHQUFHLEVBQUVFLEdBQUcsRUFBRUksSUFBSTtJQUNwRU4sTUFBTU8sT0FBT1A7SUFDYkUsTUFBTUssT0FBT0w7SUFDYixJQUFJTSxZQUFZLENBQUNoQyxRQUFTaUMsQ0FBQUEsTUFBTVQsT0FBTyxJQUFJQSxHQUFFLENBQUMsSUFBS007SUFDbkQsSUFBSUksZUFBZU4sS0FBS08sR0FBRyxDQUFDSCxhQUFhLEtBQUtGLE9BQU85QixRQUFRNEIsS0FBS1EsSUFBSSxDQUFDSixhQUFjRixDQUFBQSxPQUFPRixLQUFLTyxHQUFHLENBQUNILFVBQVMsSUFBS2hDLFFBQVFnQztJQUMzSCxJQUFJLENBQUNDLE1BQU1ULE1BQU07UUFDYixJQUFJVSxlQUFlVixLQUFLVSxlQUFlVjthQUNsQyxJQUFJLENBQUNTLE1BQU1QLFFBQVFRLGVBQWVSLEtBQUtRLGVBQWVWLE1BQU1JLEtBQUtTLEtBQUssQ0FBQyxDQUFDWCxNQUFNRixHQUFFLElBQUtNLFFBQVFBO0lBQ3RHLE9BQU8sSUFBSSxDQUFDRyxNQUFNUCxRQUFRUSxlQUFlUixLQUFLUSxlQUFlTixLQUFLUyxLQUFLLENBQUNYLE1BQU1JLFFBQVFBO0lBQ3RGLGdFQUFnRTtJQUNoRSxJQUFJUSxTQUFTUixLQUFLUyxRQUFRO0lBQzFCLElBQUlDLFFBQVFGLE9BQU9HLE9BQU8sQ0FBQztJQUMzQixJQUFJQyxZQUFZRixTQUFTLElBQUlGLE9BQU9LLE1BQU0sR0FBR0gsUUFBUTtJQUNyRCxJQUFJRSxZQUFZLEdBQUc7UUFDZixJQUFJRSxNQUFNaEIsS0FBS2dCLEdBQUcsQ0FBQyxJQUFJRjtRQUN2QlIsZUFBZU4sS0FBS2lCLEtBQUssQ0FBQ1gsZUFBZVUsT0FBT0E7SUFDcEQ7SUFDQSxPQUFPVjtBQUNYO0FBQ0EsU0FBU1kseUNBQXlDOUMsS0FBSyxFQUFFK0MsTUFBTSxFQUFFQyxPQUFPLEVBQUU7SUFDdEUsTUFBTUosTUFBTWhCLEtBQUtnQixHQUFHLENBQUNJLE1BQU1EO0lBQzNCLE9BQU9uQixLQUFLaUIsS0FBSyxDQUFDN0MsUUFBUTRDLE9BQU9BO0FBQ3JDO0FBS3NQLENBQ3RQLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhcnpvbmUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS91dGlscy9kaXN0L2ltcG9ydC5tanM/YzlhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZVN0YXRlIGFzICQ2aW11aCR1c2VTdGF0ZSwgdXNlUmVmIGFzICQ2aW11aCR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkNmltdWgkdXNlRWZmZWN0LCB1c2VDYWxsYmFjayBhcyAkNmltdWgkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDQ1OGIwYTU1MzZjMWE3Y2YkZXhwb3J0JDQwYmZhOGM3YjA4MzI3MTUodmFsdWUsIGRlZmF1bHRWYWx1ZSwgb25DaGFuZ2UpIHtcbiAgICBsZXQgW3N0YXRlVmFsdWUsIHNldFN0YXRlVmFsdWVdID0gKDAsICQ2aW11aCR1c2VTdGF0ZSkodmFsdWUgfHwgZGVmYXVsdFZhbHVlKTtcbiAgICBsZXQgaXNDb250cm9sbGVkUmVmID0gKDAsICQ2aW11aCR1c2VSZWYpKHZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgIGxldCBpc0NvbnRyb2xsZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICgwLCAkNmltdWgkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgd2FzQ29udHJvbGxlZCA9IGlzQ29udHJvbGxlZFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAod2FzQ29udHJvbGxlZCAhPT0gaXNDb250cm9sbGVkKSBjb25zb2xlLndhcm4oYFdBUk46IEEgY29tcG9uZW50IGNoYW5nZWQgZnJvbSAke3dhc0NvbnRyb2xsZWQgPyBcImNvbnRyb2xsZWRcIiA6IFwidW5jb250cm9sbGVkXCJ9IHRvICR7aXNDb250cm9sbGVkID8gXCJjb250cm9sbGVkXCIgOiBcInVuY29udHJvbGxlZFwifS5gKTtcbiAgICAgICAgaXNDb250cm9sbGVkUmVmLmN1cnJlbnQgPSBpc0NvbnRyb2xsZWQ7XG4gICAgfSwgW1xuICAgICAgICBpc0NvbnRyb2xsZWRcbiAgICBdKTtcbiAgICBsZXQgY3VycmVudFZhbHVlID0gaXNDb250cm9sbGVkID8gdmFsdWUgOiBzdGF0ZVZhbHVlO1xuICAgIGxldCBzZXRWYWx1ZSA9ICgwLCAkNmltdWgkdXNlQ2FsbGJhY2spKCh2YWx1ZSwgLi4uYXJncyk9PntcbiAgICAgICAgbGV0IG9uQ2hhbmdlQ2FsbGVyID0gKHZhbHVlLCAuLi5vbkNoYW5nZUFyZ3MpPT57XG4gICAgICAgICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5pcyhjdXJyZW50VmFsdWUsIHZhbHVlKSkgb25DaGFuZ2UodmFsdWUsIC4uLm9uQ2hhbmdlQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxlZCkgLy8gSWYgdW5jb250cm9sbGVkLCBtdXRhdGUgdGhlIGN1cnJlbnRWYWx1ZSBsb2NhbCB2YXJpYWJsZSBzbyB0aGF0XG4gICAgICAgICAgICAvLyBjYWxsaW5nIHNldFN0YXRlIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlIHNhbWUgdmFsdWUgb25seSBlbWl0cyBvbkNoYW5nZSBvbmNlLlxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHVzZSBhIHJlZiBmb3IgdGhpcyBiZWNhdXNlIHdlIHNwZWNpZmljYWxseSBfZG9fIHdhbnQgdGhlIHZhbHVlIHRvXG4gICAgICAgICAgICAvLyByZXNldCBldmVyeSByZW5kZXIsIGFuZCBhc3NpZ25pbmcgdG8gYSByZWYgaW4gcmVuZGVyIGJyZWFrcyBhYm9ydGVkIHN1c3BlbmRlZCByZW5kZXJzLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV2UgY2FuIG5vdCBzdXBwb3J0IGEgZnVuY3Rpb24gY2FsbGJhY2suIFNlZSBHaXRodWIgSXNzdWVzIGZvciBkZXRhaWxzIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9pc3N1ZXMvMjMyMFwiKTtcbiAgICAgICAgICAgIC8vIHRoaXMgc3VwcG9ydHMgZnVuY3Rpb25hbCB1cGRhdGVzIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ob29rcy1yZWZlcmVuY2UuaHRtbCNmdW5jdGlvbmFsLXVwZGF0ZXNcbiAgICAgICAgICAgIC8vIHdoZW4gc29tZW9uZSB1c2luZyB1c2VDb250cm9sbGVkU3RhdGUgY2FsbHMgc2V0Q29udHJvbGxlZFN0YXRlKG15RnVuYylcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBjYWxsIG91ciB1c2VTdGF0ZSBzZXRTdGF0ZSB3aXRoIGEgZnVuY3Rpb24gYXMgd2VsbCB3aGljaCBpbnZva2VzIG15RnVuYyBhbmQgY2FsbHMgb25DaGFuZ2Ugd2l0aCB0aGUgdmFsdWUgZnJvbSBteUZ1bmNcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGluIGFuIHVuY29udHJvbGxlZCBzdGF0ZSwgdGhlbiB3ZSBhbHNvIHJldHVybiB0aGUgdmFsdWUgb2YgbXlGdW5jIHdoaWNoIHRvIHNldFN0YXRlIGxvb2tzIGFzIHRob3VnaCBpdCB3YXMganVzdCBjYWxsZWQgd2l0aCBteUZ1bmMgZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UganVzdCByZXR1cm4gdGhlIGNvbnRyb2xsZWQgdmFsdWUsIHdoaWNoIHdvbid0IGNhdXNlIGEgcmVyZW5kZXIgYmVjYXVzZSBSZWFjdCBrbm93cyB0byBiYWlsIG91dCB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgICAgICAgbGV0IHVwZGF0ZUZ1bmN0aW9uID0gKG9sZFZhbHVlLCAuLi5mdW5jdGlvbkFyZ3MpPT57XG4gICAgICAgICAgICAgICAgbGV0IGludGVyY2VwdGVkVmFsdWUgPSB2YWx1ZShpc0NvbnRyb2xsZWQgPyBjdXJyZW50VmFsdWUgOiBvbGRWYWx1ZSwgLi4uZnVuY3Rpb25BcmdzKTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZUNhbGxlcihpbnRlcmNlcHRlZFZhbHVlLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxlZCkgcmV0dXJuIGludGVyY2VwdGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldFN0YXRlVmFsdWUodXBkYXRlRnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWQpIHNldFN0YXRlVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgb25DaGFuZ2VDYWxsZXIodmFsdWUsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc0NvbnRyb2xsZWQsXG4gICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgb25DaGFuZ2VcbiAgICBdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjdXJyZW50VmFsdWUsXG4gICAgICAgIHNldFZhbHVlXG4gICAgXTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLyoqXG4gKiBUYWtlcyBhIHZhbHVlIGFuZCBmb3JjZXMgaXQgdG8gdGhlIGNsb3Nlc3QgbWluL21heCBpZiBpdCdzIG91dHNpZGUuIEFsc28gZm9yY2VzIGl0IHRvIHRoZSBjbG9zZXN0IHZhbGlkIHN0ZXAuXG4gKi8gZnVuY3Rpb24gJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JDdkMTViNjRjZjVhM2E0YzQodmFsdWUsIG1pbiA9IC1JbmZpbml0eSwgbWF4ID0gSW5maW5pdHkpIHtcbiAgICBsZXQgbmV3VmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbiAgICByZXR1cm4gbmV3VmFsdWU7XG59XG5mdW5jdGlvbiAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkY2I2ZTBiYjUwYmMxOTQ2Myh2YWx1ZSwgbWluLCBtYXgsIHN0ZXApIHtcbiAgICBtaW4gPSBOdW1iZXIobWluKTtcbiAgICBtYXggPSBOdW1iZXIobWF4KTtcbiAgICBsZXQgcmVtYWluZGVyID0gKHZhbHVlIC0gKGlzTmFOKG1pbikgPyAwIDogbWluKSkgJSBzdGVwO1xuICAgIGxldCBzbmFwcGVkVmFsdWUgPSBNYXRoLmFicyhyZW1haW5kZXIpICogMiA+PSBzdGVwID8gdmFsdWUgKyBNYXRoLnNpZ24ocmVtYWluZGVyKSAqIChzdGVwIC0gTWF0aC5hYnMocmVtYWluZGVyKSkgOiB2YWx1ZSAtIHJlbWFpbmRlcjtcbiAgICBpZiAoIWlzTmFOKG1pbikpIHtcbiAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZSA8IG1pbikgc25hcHBlZFZhbHVlID0gbWluO1xuICAgICAgICBlbHNlIGlmICghaXNOYU4obWF4KSAmJiBzbmFwcGVkVmFsdWUgPiBtYXgpIHNuYXBwZWRWYWx1ZSA9IG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbikgLyBzdGVwKSAqIHN0ZXA7XG4gICAgfSBlbHNlIGlmICghaXNOYU4obWF4KSAmJiBzbmFwcGVkVmFsdWUgPiBtYXgpIHNuYXBwZWRWYWx1ZSA9IE1hdGguZmxvb3IobWF4IC8gc3RlcCkgKiBzdGVwO1xuICAgIC8vIGNvcnJlY3QgZmxvYXRpbmcgcG9pbnQgYmVoYXZpb3IgYnkgcm91bmRpbmcgdG8gc3RlcCBwcmVjaXNpb25cbiAgICBsZXQgc3RyaW5nID0gc3RlcC50b1N0cmluZygpO1xuICAgIGxldCBpbmRleCA9IHN0cmluZy5pbmRleE9mKFwiLlwiKTtcbiAgICBsZXQgcHJlY2lzaW9uID0gaW5kZXggPj0gMCA/IHN0cmluZy5sZW5ndGggLSBpbmRleCA6IDA7XG4gICAgaWYgKHByZWNpc2lvbiA+IDApIHtcbiAgICAgICAgbGV0IHBvdyA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgICBzbmFwcGVkVmFsdWUgPSBNYXRoLnJvdW5kKHNuYXBwZWRWYWx1ZSAqIHBvdykgLyBwb3c7XG4gICAgfVxuICAgIHJldHVybiBzbmFwcGVkVmFsdWU7XG59XG5mdW5jdGlvbiAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkYjYyNjg1NTRmYmE0NTFmKHZhbHVlLCBkaWdpdHMsIGJhc2UgPSAxMCkge1xuICAgIGNvbnN0IHBvdyA9IE1hdGgucG93KGJhc2UsIGRpZ2l0cyk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwb3cpIC8gcG93O1xufVxuXG5cblxuXG5leHBvcnQgeyQ0NThiMGE1NTM2YzFhN2NmJGV4cG9ydCQ0MGJmYThjN2IwODMyNzE1IGFzIHVzZUNvbnRyb2xsZWRTdGF0ZSwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JDdkMTViNjRjZjVhM2E0YzQgYXMgY2xhbXAsICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRjYjZlMGJiNTBiYzE5NDYzIGFzIHNuYXBWYWx1ZVRvU3RlcCwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGI2MjY4NTU0ZmJhNDUxZiBhcyB0b0ZpeGVkTnVtYmVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsIiQ2aW11aCR1c2VTdGF0ZSIsInVzZVJlZiIsIiQ2aW11aCR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkNmltdWgkdXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCIkNmltdWgkdXNlQ2FsbGJhY2siLCIkNDU4YjBhNTUzNmMxYTdjZiRleHBvcnQkNDBiZmE4YzdiMDgzMjcxNSIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwib25DaGFuZ2UiLCJzdGF0ZVZhbHVlIiwic2V0U3RhdGVWYWx1ZSIsImlzQ29udHJvbGxlZFJlZiIsInVuZGVmaW5lZCIsImlzQ29udHJvbGxlZCIsIndhc0NvbnRyb2xsZWQiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJjdXJyZW50VmFsdWUiLCJzZXRWYWx1ZSIsImFyZ3MiLCJvbkNoYW5nZUNhbGxlciIsIm9uQ2hhbmdlQXJncyIsIk9iamVjdCIsImlzIiwidXBkYXRlRnVuY3Rpb24iLCJvbGRWYWx1ZSIsImZ1bmN0aW9uQXJncyIsImludGVyY2VwdGVkVmFsdWUiLCIkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkN2QxNWI2NGNmNWEzYTRjNCIsIm1pbiIsIkluZmluaXR5IiwibWF4IiwibmV3VmFsdWUiLCJNYXRoIiwiJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGNiNmUwYmI1MGJjMTk0NjMiLCJzdGVwIiwiTnVtYmVyIiwicmVtYWluZGVyIiwiaXNOYU4iLCJzbmFwcGVkVmFsdWUiLCJhYnMiLCJzaWduIiwiZmxvb3IiLCJzdHJpbmciLCJ0b1N0cmluZyIsImluZGV4IiwiaW5kZXhPZiIsInByZWNpc2lvbiIsImxlbmd0aCIsInBvdyIsInJvdW5kIiwiJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGI2MjY4NTU0ZmJhNDUxZiIsImRpZ2l0cyIsImJhc2UiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCJjbGFtcCIsInNuYXBWYWx1ZVRvU3RlcCIsInRvRml4ZWROdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/interactions/node_modules/@react-stately/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/ssr/dist/import.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@react-aria/ssr/dist/import.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SSRProvider: () => (/* binding */ $b5e257d569688ac6$export$9f8ac96af4b1b2ae),\n/* harmony export */   useIsSSR: () => (/* binding */ $b5e257d569688ac6$export$535bd6ca7f90a273),\n/* harmony export */   useSSRSafeId: () => (/* binding */ $b5e257d569688ac6$export$619500959fc48b26)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is\n// guarded by a check that it only runs on the client side.\n// eslint-disable-next-line rulesdir/useLayoutEffectRule\n// Default context value to use in case there is no SSRProvider. This is fine for\n// client-only apps. In order to support multiple copies of React Aria potentially\n// being on the page at once, the prefix is set to a random number. SSRProvider\n// will reset this to zero for consistency between server and client, so in the\n// SSR case multiple copies of React Aria is not supported.\nconst $b5e257d569688ac6$var$defaultContext = {\n    prefix: String(Math.round(Math.random() * 10000000000)),\n    current: 0\n};\nconst $b5e257d569688ac6$var$SSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext($b5e257d569688ac6$var$defaultContext);\nconst $b5e257d569688ac6$var$IsSSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(false);\n// This is only used in React < 18.\nfunction $b5e257d569688ac6$var$LegacySSRProvider(props) {\n    let cur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let counter = $b5e257d569688ac6$var$useCounter(cur === $b5e257d569688ac6$var$defaultContext);\n    let [isSSR, setIsSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            // If this is the first SSRProvider, start with an empty string prefix, otherwise\n            // append and increment the counter.\n            prefix: cur === $b5e257d569688ac6$var$defaultContext ? \"\" : `${cur.prefix}-${counter}`,\n            current: 0\n        }), [\n        cur,\n        counter\n    ]);\n    // If on the client, and the component was initially server rendered,\n    // then schedule a layout effect to update the component after hydration.\n    if (typeof document !== \"undefined\") // because the condition never changes after mounting.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        setIsSSR(false);\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$SSRContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$IsSSRContext.Provider, {\n        value: isSSR\n    }, props.children));\n}\nlet $b5e257d569688ac6$var$warnedAboutSSRProvider = false;\nfunction $b5e257d569688ac6$export$9f8ac96af4b1b2ae(props) {\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\") {\n        if ( true && !$b5e257d569688ac6$var$warnedAboutSSRProvider) {\n            console.warn(\"In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.\");\n            $b5e257d569688ac6$var$warnedAboutSSRProvider = true;\n        }\n        return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, react__WEBPACK_IMPORTED_MODULE_0__).Fragment, null, props.children);\n    }\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$LegacySSRProvider, props);\n}\nlet $b5e257d569688ac6$var$canUseDOM = Boolean( false && 0);\nlet $b5e257d569688ac6$var$componentIds = new WeakMap();\nfunction $b5e257d569688ac6$var$useCounter(isDisabled = false) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // eslint-disable-next-line rulesdir/pure-render\n    if (ref.current === null && !isDisabled) {\n        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.\n        // This means our id counter will be incremented twice instead of once. This is a problem because on the\n        // server, components are only rendered once and so ids generated on the server won't match the client.\n        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this\n        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.\n        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.\n        // To ensure that we only increment the global counter once, we store the starting id for this component in\n        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.\n        // Since React runs the second render immediately after the first, this is safe.\n        // @ts-ignore\n        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, react__WEBPACK_IMPORTED_MODULE_0__).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;\n        if (currentOwner) {\n            let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);\n            if (prevComponentValue == null) $b5e257d569688ac6$var$componentIds.set(currentOwner, {\n                id: ctx.current,\n                state: currentOwner.memoizedState\n            });\n            else if (currentOwner.memoizedState !== prevComponentValue.state) {\n                // On the second render, the memoizedState gets reset by React.\n                // Reset the counter, and remove from the weak map so we don't\n                // do this for subsequent useId calls.\n                ctx.current = prevComponentValue.id;\n                $b5e257d569688ac6$var$componentIds.delete(currentOwner);\n            }\n        }\n        // eslint-disable-next-line rulesdir/pure-render\n        ref.current = ++ctx.current;\n    }\n    // eslint-disable-next-line rulesdir/pure-render\n    return ref.current;\n}\nfunction $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    // If we are rendering in a non-DOM environment, and there's no SSRProvider,\n    // provide a warning to hint to the developer to add one.\n    if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM) console.warn(\"When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.\");\n    let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);\n    let prefix = ctx === $b5e257d569688ac6$var$defaultContext && \"development\" === \"test\" ? 0 : `react-aria${ctx.prefix}`;\n    return defaultId || `${prefix}-${counter}`;\n}\nfunction $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {\n    // @ts-ignore\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__).useId();\n    let [didSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());\n    let prefix = didSSR || \"development\" === \"test\" ? \"react-aria\" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;\n    return defaultId || `${prefix}-${id}`;\n}\nconst $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;\nfunction $b5e257d569688ac6$var$getSnapshot() {\n    return false;\n}\nfunction $b5e257d569688ac6$var$getServerSnapshot() {\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction $b5e257d569688ac6$var$subscribe(onStoreChange) {\n    // noop\n    return ()=>{};\n}\nfunction $b5e257d569688ac6$export$535bd6ca7f90a273() {\n    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"] === \"function\") return (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$IsSSRContext);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvc3NyL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdNO0FBRWhNOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsMEZBQTBGO0FBQzlGLDJEQUEyRDtBQUMzRCx3REFBd0Q7QUFFeEQsaUZBQWlGO0FBQ2pGLGtGQUFrRjtBQUNsRiwrRUFBK0U7QUFDL0UsK0VBQStFO0FBQy9FLDJEQUEyRDtBQUMzRCxNQUFNVyx1Q0FBdUM7SUFDekNDLFFBQVFDLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLO0lBQzFDQyxTQUFTO0FBQ2I7QUFDQSxNQUFNQyxtQ0FBaUQsV0FBSCxHQUFJLElBQUdsQixrQ0FBVyxFQUFHbUIsYUFBYSxDQUFDUjtBQUN2RixNQUFNUyxxQ0FBbUQsV0FBSCxHQUFJLElBQUdwQixrQ0FBVyxFQUFHbUIsYUFBYSxDQUFDO0FBQ3pGLG1DQUFtQztBQUNuQyxTQUFTRSx3Q0FBd0NDLEtBQUs7SUFDbEQsSUFBSUMsTUFBTSxDQUFDLEdBQUdyQiw2Q0FBZ0IsRUFBR2dCO0lBQ2pDLElBQUlNLFVBQVVDLGlDQUFpQ0YsUUFBUVo7SUFDdkQsSUFBSSxDQUFDZSxPQUFPQyxTQUFTLEdBQUcsQ0FBQyxHQUFHdkIsMkNBQWMsRUFBRztJQUM3QyxJQUFJd0IsUUFBUSxDQUFDLEdBQUd0QiwwQ0FBYSxFQUFHLElBQUs7WUFDN0IsaUZBQWlGO1lBQ2pGLG9DQUFvQztZQUNwQ00sUUFBUVcsUUFBUVosdUNBQXVDLEtBQUssQ0FBQyxFQUFFWSxJQUFJWCxNQUFNLENBQUMsQ0FBQyxFQUFFWSxRQUFRLENBQUM7WUFDdEZQLFNBQVM7UUFDYixJQUFJO1FBQ0pNO1FBQ0FDO0tBQ0g7SUFDRCxxRUFBcUU7SUFDckUseUVBQXlFO0lBQ3pFLElBQUksT0FBT0ssYUFBYSxhQUd4QixzREFGc0Q7SUFDdEQsc0RBQXNEO0lBQ3JELElBQUdyQixrREFBcUIsRUFBRztRQUN4Qm1CLFNBQVM7SUFDYixHQUFHLEVBQUU7SUFDTCxPQUFxQixXQUFILEdBQUksSUFBRzNCLGtDQUFXLEVBQUc4QixhQUFhLENBQUNaLGlDQUFpQ2EsUUFBUSxFQUFFO1FBQzVGSCxPQUFPQTtJQUNYLEdBQWlCLFdBQUgsR0FBSSxJQUFHNUIsa0NBQVcsRUFBRzhCLGFBQWEsQ0FBQ1YsbUNBQW1DVyxRQUFRLEVBQUU7UUFDMUZILE9BQU9GO0lBQ1gsR0FBR0osTUFBTVUsUUFBUTtBQUNyQjtBQUNBLElBQUlDLCtDQUErQztBQUNuRCxTQUFTQywwQ0FBMENaLEtBQUs7SUFDcEQsSUFBSSxPQUFPLENBQUMsR0FBR3RCLGtDQUFXLENBQUUsQ0FBQyxRQUFRLEtBQUssWUFBWTtRQUNsRCxJQUFJbUMsS0FBK0IsSUFBSSxDQUFDRiw4Q0FBOEM7WUFDbEZHLFFBQVFDLElBQUksQ0FBQztZQUNiSiwrQ0FBK0M7UUFDbkQ7UUFDQSxPQUFxQixXQUFILEdBQUksSUFBR2pDLGtDQUFXLEVBQUc4QixhQUFhLENBQUMsQ0FBQyxHQUFHOUIsa0NBQVcsRUFBR3NDLFFBQVEsRUFBRSxNQUFNaEIsTUFBTVUsUUFBUTtJQUN6RztJQUNBLE9BQXFCLFdBQUgsR0FBSSxJQUFHaEMsa0NBQVcsRUFBRzhCLGFBQWEsQ0FBQ1QseUNBQXlDQztBQUNsRztBQUNBLElBQUlpQixrQ0FBa0NDLFFBQVEsTUFBZ0QsSUFBSUMsQ0FBNkI7QUFDL0gsSUFBSUMscUNBQXFDLElBQUlDO0FBQzdDLFNBQVNsQixpQ0FBaUNtQixhQUFhLEtBQUs7SUFDeEQsSUFBSUMsTUFBTSxDQUFDLEdBQUczQyw2Q0FBZ0IsRUFBR2dCO0lBQ2pDLElBQUk0QixNQUFNLENBQUMsR0FBR3BDLHlDQUFZLEVBQUc7SUFDN0IsZ0RBQWdEO0lBQ2hELElBQUlvQyxJQUFJN0IsT0FBTyxLQUFLLFFBQVEsQ0FBQzJCLFlBQVk7UUFDckMsSUFBSUcsNkVBQTZFQztRQUNqRiwwR0FBMEc7UUFDMUcsd0dBQXdHO1FBQ3hHLHVHQUF1RztRQUN2RywrR0FBK0c7UUFDL0csZ0hBQWdIO1FBQ2hILHVIQUF1SDtRQUN2SCwyR0FBMkc7UUFDM0cseUdBQXlHO1FBQ3pHLGdGQUFnRjtRQUNoRixhQUFhO1FBQ2IsSUFBSUMsZUFBZSxDQUFDRCw0REFBNEQsQ0FBQyxHQUFHaEQsa0NBQVcsRUFBR2tELGtEQUFrRCxNQUFNLFFBQVFGLDhEQUE4RCxLQUFLLElBQUksS0FBSyxJQUFJLENBQUNELDhFQUE4RUMsMERBQTBERyxpQkFBaUIsTUFBTSxRQUFRSixnRkFBZ0YsS0FBSyxJQUFJLEtBQUssSUFBSUEsNEVBQTRFOUIsT0FBTztRQUMva0IsSUFBSWdDLGNBQWM7WUFDZCxJQUFJRyxxQkFBcUJWLG1DQUFtQ1csR0FBRyxDQUFDSjtZQUNoRSxJQUFJRyxzQkFBc0IsTUFDMUJWLG1DQUFtQ1ksR0FBRyxDQUFDTCxjQUFjO2dCQUNqRE0sSUFBSVYsSUFBSTVCLE9BQU87Z0JBQ2Z1QyxPQUFPUCxhQUFhUSxhQUFhO1lBQ3JDO2lCQUNLLElBQUlSLGFBQWFRLGFBQWEsS0FBS0wsbUJBQW1CSSxLQUFLLEVBQUU7Z0JBQzlELCtEQUErRDtnQkFDL0QsOERBQThEO2dCQUM5RCxzQ0FBc0M7Z0JBQ3RDWCxJQUFJNUIsT0FBTyxHQUFHbUMsbUJBQW1CRyxFQUFFO2dCQUNuQ2IsbUNBQW1DZ0IsTUFBTSxDQUFDVDtZQUM5QztRQUNKO1FBQ0EsZ0RBQWdEO1FBQ2hESCxJQUFJN0IsT0FBTyxHQUFHLEVBQUU0QixJQUFJNUIsT0FBTztJQUMvQjtJQUNBLGdEQUFnRDtJQUNoRCxPQUFPNkIsSUFBSTdCLE9BQU87QUFDdEI7QUFDQSxTQUFTMEMseUNBQXlDQyxTQUFTO0lBQ3ZELElBQUlmLE1BQU0sQ0FBQyxHQUFHM0MsNkNBQWdCLEVBQUdnQjtJQUNqQyw0RUFBNEU7SUFDNUUseURBQXlEO0lBQ3pELElBQUkyQixRQUFRbEMsd0NBQXdDLENBQUM0QixpQ0FBaUNILFFBQVFDLElBQUksQ0FBQztJQUNuRyxJQUFJYixVQUFVQyxpQ0FBaUMsQ0FBQyxDQUFDbUM7SUFDakQsSUFBSWhELFNBQVNpQyxRQUFRbEMsd0NBQXdDd0Isa0JBQXlCLFNBQVMsQ0FBWSxHQUFHLENBQUMsVUFBVSxFQUFFVSxJQUFJakMsTUFBTSxDQUFDLENBQUM7SUFDdkksT0FBT2dELGFBQWEsQ0FBQyxFQUFFaEQsT0FBTyxDQUFDLEVBQUVZLFFBQVEsQ0FBQztBQUM5QztBQUNBLFNBQVNxQyx5Q0FBeUNELFNBQVM7SUFDdkQsYUFBYTtJQUNiLElBQUlMLEtBQUssQ0FBQyxHQUFHdkQsa0NBQVcsRUFBRzhELEtBQUs7SUFDaEMsSUFBSSxDQUFDQyxPQUFPLEdBQUcsQ0FBQyxHQUFHM0QsMkNBQWMsRUFBRzREO0lBQ3BDLElBQUlwRCxTQUFTbUQsVUFBVTVCLGtCQUF5QixTQUFTLGVBQWUsQ0FBQyxVQUFVLEVBQUV4QixxQ0FBcUNDLE1BQU0sQ0FBQyxDQUFDO0lBQ2xJLE9BQU9nRCxhQUFhLENBQUMsRUFBRWhELE9BQU8sQ0FBQyxFQUFFMkMsR0FBRyxDQUFDO0FBQ3pDO0FBQ0EsTUFBTVUsNENBQTRDLE9BQU8sQ0FBQyxHQUFHakUsa0NBQVcsQ0FBRSxDQUFDLFFBQVEsS0FBSyxhQUFhNkQsMkNBQTJDRjtBQUNoSixTQUFTTztJQUNMLE9BQU87QUFDWDtBQUNBLFNBQVNDO0lBQ0wsT0FBTztBQUNYO0FBQ0EsNkRBQTZEO0FBQzdELFNBQVNDLGdDQUFnQ0MsYUFBYTtJQUNsRCxPQUFPO0lBQ1AsT0FBTyxLQUFLO0FBQ2hCO0FBQ0EsU0FBU0w7SUFDTCxpR0FBaUc7SUFDakcsSUFBSSxPQUFPLENBQUMsR0FBR2hFLGtDQUFXLENBQUUsQ0FBQyx1QkFBdUIsS0FBSyxZQUFZLE9BQU8sQ0FBQyxHQUFHQSxrQ0FBVyxDQUFFLENBQUMsdUJBQXVCLENBQUNvRSxpQ0FBaUNGLG1DQUFtQ0M7SUFDMUwsc0RBQXNEO0lBQ3RELE9BQU8sQ0FBQyxHQUFHakUsNkNBQWdCLEVBQUdrQjtBQUNsQztBQUtvTCxDQUNwTCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXJ6b25lLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3Nzci9kaXN0L2ltcG9ydC5tanM/ZmM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJDczU0p4JHJlYWN0LCB7dXNlQ29udGV4dCBhcyAkNzNTSngkdXNlQ29udGV4dCwgdXNlU3RhdGUgYXMgJDczU0p4JHVzZVN0YXRlLCB1c2VNZW1vIGFzICQ3M1NKeCR1c2VNZW1vLCB1c2VMYXlvdXRFZmZlY3QgYXMgJDczU0p4JHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIGFzICQ3M1NKeCR1c2VSZWZ9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFdlIG11c3QgYXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggQHJlYWN0LWFyaWEvdXRpbHMsIGFuZCB0aGlzIHVzZUxheW91dEVmZmVjdCBpc1xuLy8gZ3VhcmRlZCBieSBhIGNoZWNrIHRoYXQgaXQgb25seSBydW5zIG9uIHRoZSBjbGllbnQgc2lkZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci91c2VMYXlvdXRFZmZlY3RSdWxlXG5cbi8vIERlZmF1bHQgY29udGV4dCB2YWx1ZSB0byB1c2UgaW4gY2FzZSB0aGVyZSBpcyBubyBTU1JQcm92aWRlci4gVGhpcyBpcyBmaW5lIGZvclxuLy8gY2xpZW50LW9ubHkgYXBwcy4gSW4gb3JkZXIgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgQXJpYSBwb3RlbnRpYWxseVxuLy8gYmVpbmcgb24gdGhlIHBhZ2UgYXQgb25jZSwgdGhlIHByZWZpeCBpcyBzZXQgdG8gYSByYW5kb20gbnVtYmVyLiBTU1JQcm92aWRlclxuLy8gd2lsbCByZXNldCB0aGlzIHRvIHplcm8gZm9yIGNvbnNpc3RlbmN5IGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQsIHNvIGluIHRoZVxuLy8gU1NSIGNhc2UgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IEFyaWEgaXMgbm90IHN1cHBvcnRlZC5cbmNvbnN0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCA9IHtcbiAgICBwcmVmaXg6IFN0cmluZyhNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMCkpLFxuICAgIGN1cnJlbnQ6IDBcbn07XG5jb25zdCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlQ29udGV4dCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQpO1xuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJElzU1NSQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vLyBUaGlzIGlzIG9ubHkgdXNlZCBpbiBSZWFjdCA8IDE4LlxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJExlZ2FjeVNTUlByb3ZpZGVyKHByb3BzKSB7XG4gICAgbGV0IGN1ciA9ICgwLCAkNzNTSngkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIGxldCBjb3VudGVyID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoY3VyID09PSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQpO1xuICAgIGxldCBbaXNTU1IsIHNldElzU1NSXSA9ICgwLCAkNzNTSngkdXNlU3RhdGUpKHRydWUpO1xuICAgIGxldCB2YWx1ZSA9ICgwLCAkNzNTSngkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBTU1JQcm92aWRlciwgc3RhcnQgd2l0aCBhbiBlbXB0eSBzdHJpbmcgcHJlZml4LCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGFwcGVuZCBhbmQgaW5jcmVtZW50IHRoZSBjb3VudGVyLlxuICAgICAgICAgICAgcHJlZml4OiBjdXIgPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCA/IFwiXCIgOiBgJHtjdXIucHJlZml4fS0ke2NvdW50ZXJ9YCxcbiAgICAgICAgICAgIGN1cnJlbnQ6IDBcbiAgICAgICAgfSksIFtcbiAgICAgICAgY3VyLFxuICAgICAgICBjb3VudGVyXG4gICAgXSk7XG4gICAgLy8gSWYgb24gdGhlIGNsaWVudCwgYW5kIHRoZSBjb21wb25lbnQgd2FzIGluaXRpYWxseSBzZXJ2ZXIgcmVuZGVyZWQsXG4gICAgLy8gdGhlbiBzY2hlZHVsZSBhIGxheW91dCBlZmZlY3QgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQgYWZ0ZXIgaHlkcmF0aW9uLlxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIC8vIFRoaXMgaWYgc3RhdGVtZW50IHRlY2huaWNhbGx5IGJyZWFrcyB0aGUgcnVsZXMgb2YgaG9va3MsIGJ1dCBpcyBzYWZlXG4gICAgLy8gYmVjYXVzZSB0aGUgY29uZGl0aW9uIG5ldmVyIGNoYW5nZXMgYWZ0ZXIgbW91bnRpbmcuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgKDAsICQ3M1NKeCR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIHNldElzU1NSKGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9LCAvKiNfX1BVUkVfXyovICgwLCAkNzNTSngkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJElzU1NSQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogaXNTU1JcbiAgICB9LCBwcm9wcy5jaGlsZHJlbikpO1xufVxubGV0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciR3YXJuZWRBYm91dFNTUlByb3ZpZGVyID0gZmFsc2U7XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkOWY4YWM5NmFmNGIxYjJhZShwcm9wcykge1xuICAgIGlmICh0eXBlb2YgKDAsICQ3M1NKeCRyZWFjdClbXCJ1c2VJZFwiXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJ0ZXN0XCIgJiYgISRiNWUyNTdkNTY5Njg4YWM2JHZhciR3YXJuZWRBYm91dFNTUlByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbiBSZWFjdCAxOCwgU1NSUHJvdmlkZXIgaXMgbm90IG5lY2Vzc2FyeSBhbmQgaXMgYSBub29wLiBZb3UgY2FuIHJlbW92ZSBpdCBmcm9tIHlvdXIgYXBwLlwiKTtcbiAgICAgICAgICAgICRiNWUyNTdkNTY5Njg4YWM2JHZhciR3YXJuZWRBYm91dFNTUlByb3ZpZGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVFbGVtZW50KCgwLCAkNzNTSngkcmVhY3QpLkZyYWdtZW50LCBudWxsLCBwcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkNzNTSngkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJExlZ2FjeVNTUlByb3ZpZGVyLCBwcm9wcyk7XG59XG5sZXQgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNhblVzZURPTSA9IEJvb2xlYW4odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubGV0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoaXNEaXNhYmxlZCA9IGZhbHNlKSB7XG4gICAgbGV0IGN0eCA9ICgwLCAkNzNTSngkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIGxldCByZWYgPSAoMCwgJDczU0p4JHVzZVJlZikobnVsbCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3B1cmUtcmVuZGVyXG4gICAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICAgIHZhciBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIsIF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICAgICAgLy8gSW4gc3RyaWN0IG1vZGUsIFJlYWN0IHJlbmRlcnMgY29tcG9uZW50cyB0d2ljZSwgYW5kIHRoZSByZWYgd2lsbCBiZSByZXNldCB0byBudWxsIG9uIHRoZSBzZWNvbmQgcmVuZGVyLlxuICAgICAgICAvLyBUaGlzIG1lYW5zIG91ciBpZCBjb3VudGVyIHdpbGwgYmUgaW5jcmVtZW50ZWQgdHdpY2UgaW5zdGVhZCBvZiBvbmNlLiBUaGlzIGlzIGEgcHJvYmxlbSBiZWNhdXNlIG9uIHRoZVxuICAgICAgICAvLyBzZXJ2ZXIsIGNvbXBvbmVudHMgYXJlIG9ubHkgcmVuZGVyZWQgb25jZSBhbmQgc28gaWRzIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIHdvbid0IG1hdGNoIHRoZSBjbGllbnQuXG4gICAgICAgIC8vIEluIFJlYWN0IDE4LCB1c2VJZCB3YXMgaW50cm9kdWNlZCB0byBzb2x2ZSB0aGlzLCBidXQgaXQgaXMgbm90IGF2YWlsYWJsZSBpbiBvbGRlciB2ZXJzaW9ucy4gU28gdG8gc29sdmUgdGhpc1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHVzZSBzb21lIFJlYWN0IGludGVybmFscyB0byBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgRmliZXIgaW5zdGFuY2UsIHdoaWNoIGlzIHN0YWJsZSBiZXR3ZWVuIHJlbmRlcnMuXG4gICAgICAgIC8vIFRoaXMgaXMgZXhwb3NlZCBhcyBSZWFjdEN1cnJlbnRPd25lciBpbiBkZXZlbG9wbWVudCwgd2hpY2ggaXMgYWxsIHdlIG5lZWQgc2luY2UgU3RyaWN0TW9kZSBvbmx5IHJ1bnMgaW4gZGV2ZWxvcG1lbnQuXG4gICAgICAgIC8vIFRvIGVuc3VyZSB0aGF0IHdlIG9ubHkgaW5jcmVtZW50IHRoZSBnbG9iYWwgY291bnRlciBvbmNlLCB3ZSBzdG9yZSB0aGUgc3RhcnRpbmcgaWQgZm9yIHRoaXMgY29tcG9uZW50IGluXG4gICAgICAgIC8vIGEgd2VhayBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoZSBGaWJlci4gT24gdGhlIHNlY29uZCByZW5kZXIsIHdlIHJlc2V0IHRoZSBnbG9iYWwgY291bnRlciB0byB0aGlzIHZhbHVlLlxuICAgICAgICAvLyBTaW5jZSBSZWFjdCBydW5zIHRoZSBzZWNvbmQgcmVuZGVyIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBmaXJzdCwgdGhpcyBpcyBzYWZlLlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBjdXJyZW50T3duZXIgPSAoX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gKDAsICQ3M1NKeCRyZWFjdCkuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQpID09PSBudWxsIHx8IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lciA9IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcikgPT09IG51bGwgfHwgX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEX1JlYWN0Q3VycmVudE93bmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGN1cnJlbnRPd25lcikge1xuICAgICAgICAgICAgbGV0IHByZXZDb21wb25lbnRWYWx1ZSA9ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuZ2V0KGN1cnJlbnRPd25lcik7XG4gICAgICAgICAgICBpZiAocHJldkNvbXBvbmVudFZhbHVlID09IG51bGwpIC8vIE9uIHRoZSBmaXJzdCByZW5kZXIsIGFuZCBmaXJzdCBjYWxsIHRvIHVzZUlkLCBzdG9yZSB0aGUgaWQgYW5kIHN0YXRlIGluIG91ciB3ZWFrIG1hcC5cbiAgICAgICAgICAgICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuc2V0KGN1cnJlbnRPd25lciwge1xuICAgICAgICAgICAgICAgIGlkOiBjdHguY3VycmVudCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogY3VycmVudE93bmVyLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudE93bmVyLm1lbW9pemVkU3RhdGUgIT09IHByZXZDb21wb25lbnRWYWx1ZS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIE9uIHRoZSBzZWNvbmQgcmVuZGVyLCB0aGUgbWVtb2l6ZWRTdGF0ZSBnZXRzIHJlc2V0IGJ5IFJlYWN0LlxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjb3VudGVyLCBhbmQgcmVtb3ZlIGZyb20gdGhlIHdlYWsgbWFwIHNvIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gZG8gdGhpcyBmb3Igc3Vic2VxdWVudCB1c2VJZCBjYWxscy5cbiAgICAgICAgICAgICAgICBjdHguY3VycmVudCA9IHByZXZDb21wb25lbnRWYWx1ZS5pZDtcbiAgICAgICAgICAgICAgICAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY29tcG9uZW50SWRzLmRlbGV0ZShjdXJyZW50T3duZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci9wdXJlLXJlbmRlclxuICAgICAgICByZWYuY3VycmVudCA9ICsrY3R4LmN1cnJlbnQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci9wdXJlLXJlbmRlclxuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VMZWdhY3lTU1JTYWZlSWQoZGVmYXVsdElkKSB7XG4gICAgbGV0IGN0eCA9ICgwLCAkNzNTSngkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIC8vIElmIHdlIGFyZSByZW5kZXJpbmcgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCBhbmQgdGhlcmUncyBubyBTU1JQcm92aWRlcixcbiAgICAvLyBwcm92aWRlIGEgd2FybmluZyB0byBoaW50IHRvIHRoZSBkZXZlbG9wZXIgdG8gYWRkIG9uZS5cbiAgICBpZiAoY3R4ID09PSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQgJiYgISRiNWUyNTdkNTY5Njg4YWM2JHZhciRjYW5Vc2VET00pIGNvbnNvbGUud2FybihcIldoZW4gc2VydmVyIHJlbmRlcmluZywgeW91IG11c3Qgd3JhcCB5b3VyIGFwcGxpY2F0aW9uIGluIGFuIDxTU1JQcm92aWRlcj4gdG8gZW5zdXJlIGNvbnNpc3RlbnQgaWRzIGFyZSBnZW5lcmF0ZWQgYmV0d2VlbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIuXCIpO1xuICAgIGxldCBjb3VudGVyID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoISFkZWZhdWx0SWQpO1xuICAgIGxldCBwcmVmaXggPSBjdHggPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyBcInJlYWN0LWFyaWFcIiA6IGByZWFjdC1hcmlhJHtjdHgucHJlZml4fWA7XG4gICAgcmV0dXJuIGRlZmF1bHRJZCB8fCBgJHtwcmVmaXh9LSR7Y291bnRlcn1gO1xufVxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZU1vZGVyblNTUlNhZmVJZChkZWZhdWx0SWQpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IGlkID0gKDAsICQ3M1NKeCRyZWFjdCkudXNlSWQoKTtcbiAgICBsZXQgW2RpZFNTUl0gPSAoMCwgJDczU0p4JHVzZVN0YXRlKSgkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MygpKTtcbiAgICBsZXQgcHJlZml4ID0gZGlkU1NSIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IFwicmVhY3QtYXJpYVwiIDogYHJlYWN0LWFyaWEkeyRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dC5wcmVmaXh9YDtcbiAgICByZXR1cm4gZGVmYXVsdElkIHx8IGAke3ByZWZpeH0tJHtpZH1gO1xufVxuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDYxOTUwMDk1OWZjNDhiMjYgPSB0eXBlb2YgKDAsICQ3M1NKeCRyZWFjdClbXCJ1c2VJZFwiXSA9PT0gXCJmdW5jdGlvblwiID8gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZU1vZGVyblNTUlNhZmVJZCA6ICRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VMZWdhY3lTU1JTYWZlSWQ7XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U25hcHNob3QoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHN1YnNjcmliZShvblN0b3JlQ2hhbmdlKSB7XG4gICAgLy8gbm9vcFxuICAgIHJldHVybiAoKT0+e307XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MygpIHtcbiAgICAvLyBJbiBSZWFjdCAxOCwgd2UgY2FuIHVzZSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB0byBkZXRlY3QgaWYgd2UncmUgc2VydmVyIHJlbmRlcmluZyBvciBoeWRyYXRpbmcuXG4gICAgaWYgKHR5cGVvZiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCJdID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCJdKCRiNWUyNTdkNTY5Njg4YWM2JHZhciRzdWJzY3JpYmUsICRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTbmFwc2hvdCwgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNlcnZlclNuYXBzaG90KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICByZXR1cm4gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0KTtcbn1cblxuXG5cblxuZXhwb3J0IHskYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkOWY4YWM5NmFmNGIxYjJhZSBhcyBTU1JQcm92aWRlciwgJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDYxOTUwMDk1OWZjNDhiMjYgYXMgdXNlU1NSU2FmZUlkLCAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MyBhcyB1c2VJc1NTUn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJDczU0p4JHJlYWN0IiwidXNlQ29udGV4dCIsIiQ3M1NKeCR1c2VDb250ZXh0IiwidXNlU3RhdGUiLCIkNzNTSngkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJDczU0p4JHVzZU1lbW8iLCJ1c2VMYXlvdXRFZmZlY3QiLCIkNzNTSngkdXNlTGF5b3V0RWZmZWN0IiwidXNlUmVmIiwiJDczU0p4JHVzZVJlZiIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCIsInByZWZpeCIsIlN0cmluZyIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsImN1cnJlbnQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJExlZ2FjeVNTUlByb3ZpZGVyIiwicHJvcHMiLCJjdXIiLCJjb3VudGVyIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIiLCJpc1NTUiIsInNldElzU1NSIiwidmFsdWUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsImNoaWxkcmVuIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIiLCIkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkOWY4YWM5NmFmNGIxYjJhZSIsInByb2Nlc3MiLCJjb25zb2xlIiwid2FybiIsIkZyYWdtZW50IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNhblVzZURPTSIsIkJvb2xlYW4iLCJ3aW5kb3ciLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY29tcG9uZW50SWRzIiwiV2Vha01hcCIsImlzRGlzYWJsZWQiLCJjdHgiLCJyZWYiLCJfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIiLCJfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJjdXJyZW50T3duZXIiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwicHJldkNvbXBvbmVudFZhbHVlIiwiZ2V0Iiwic2V0IiwiaWQiLCJzdGF0ZSIsIm1lbW9pemVkU3RhdGUiLCJkZWxldGUiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTGVnYWN5U1NSU2FmZUlkIiwiZGVmYXVsdElkIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZU1vZGVyblNTUlNhZmVJZCIsInVzZUlkIiwiZGlkU1NSIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDUzNWJkNmNhN2Y5MGEyNzMiLCIkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNjE5NTAwOTU5ZmM0OGIyNiIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTbmFwc2hvdCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTZXJ2ZXJTbmFwc2hvdCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRzdWJzY3JpYmUiLCJvblN0b3JlQ2hhbmdlIiwiU1NSUHJvdmlkZXIiLCJ1c2VTU1JTYWZlSWQiLCJ1c2VJc1NTUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/ssr/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/utils/dist/import.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@react-aria/utils/dist/import.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RouterProvider: () => (/* binding */ $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb),\n/* harmony export */   chain: () => (/* binding */ $ff5963eb1fccf552$export$e08e3b67e392101e),\n/* harmony export */   clamp: () => (/* reexport safe */ _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.clamp),\n/* harmony export */   filterDOMProps: () => (/* binding */ $65484d02dcb7eb3e$export$457c3d6518dd4c6f),\n/* harmony export */   focusWithoutScrolling: () => (/* binding */ $7215afc6de606d6b$export$de79e2c695e052f3),\n/* harmony export */   getOffset: () => (/* binding */ $ab71dadb03a6fb2e$export$622cea445a1c5b7d),\n/* harmony export */   getOwnerDocument: () => (/* binding */ $431fbd86ca7dc216$export$b204af158042fbac),\n/* harmony export */   getOwnerWindow: () => (/* binding */ $431fbd86ca7dc216$export$f21a1ffae260145a),\n/* harmony export */   getScrollParent: () => (/* binding */ $62d8ded9296f3872$export$cfa2225e87938781),\n/* harmony export */   getSyntheticLinkProps: () => (/* binding */ $ea8dcbcb9ea1b556$export$51437d503373d223),\n/* harmony export */   isAndroid: () => (/* binding */ $c87311424ea30a05$export$a11b0059900ceec8),\n/* harmony export */   isAppleDevice: () => (/* binding */ $c87311424ea30a05$export$e1865c3bedcd822b),\n/* harmony export */   isChrome: () => (/* binding */ $c87311424ea30a05$export$6446a186d09e379e),\n/* harmony export */   isFirefox: () => (/* binding */ $c87311424ea30a05$export$b7d78993b74f766d),\n/* harmony export */   isIOS: () => (/* binding */ $c87311424ea30a05$export$fedb369cb70207f1),\n/* harmony export */   isIPad: () => (/* binding */ $c87311424ea30a05$export$7bef049ce92e4224),\n/* harmony export */   isIPhone: () => (/* binding */ $c87311424ea30a05$export$186c6964ca17d99),\n/* harmony export */   isMac: () => (/* binding */ $c87311424ea30a05$export$9ac100e40613ea10),\n/* harmony export */   isScrollable: () => (/* binding */ $62d8ded9296f3872$export$2bb74740c4e19def),\n/* harmony export */   isVirtualClick: () => (/* binding */ $6a7db85432448f7f$export$60278871457622de),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ $6a7db85432448f7f$export$29bf1b5f2c56cf63),\n/* harmony export */   isWebKit: () => (/* binding */ $c87311424ea30a05$export$78551043582a6a98),\n/* harmony export */   mergeIds: () => (/* binding */ $bdb11010cef70236$export$cd8c9cb68f842629),\n/* harmony export */   mergeProps: () => (/* binding */ $3ef42575df84b30b$export$9d1611c77c2fe928),\n/* harmony export */   mergeRefs: () => (/* binding */ $5dc95899b306f630$export$c9058316764c140e),\n/* harmony export */   openLink: () => (/* binding */ $ea8dcbcb9ea1b556$export$95185d699e05d4d7),\n/* harmony export */   runAfterTransition: () => (/* binding */ $bbed8b41f857bcc0$export$24490316f764c430),\n/* harmony export */   scrollIntoView: () => (/* binding */ $2f04cbc44ee30ce0$export$53a0910f038337bd),\n/* harmony export */   scrollIntoViewport: () => (/* binding */ $2f04cbc44ee30ce0$export$c826860796309d1b),\n/* harmony export */   shouldClientNavigate: () => (/* binding */ $ea8dcbcb9ea1b556$export$efa8c9099e530235),\n/* harmony export */   snapValueToStep: () => (/* reexport safe */ _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.snapValueToStep),\n/* harmony export */   useDeepMemo: () => (/* binding */ $5a387cc49350e6db$export$722debc0e56fea39),\n/* harmony export */   useDescription: () => (/* binding */ $ef06256079686ba0$export$f8aeda7b10753fa1),\n/* harmony export */   useDrag1D: () => (/* binding */ $9cc09df9fd7676be$export$7bbed75feba39706),\n/* harmony export */   useEffectEvent: () => (/* binding */ $8ae05eaa5c114e9c$export$7f54fc3180508a52),\n/* harmony export */   useEvent: () => (/* binding */ $e9faafb641e167db$export$90fc3a17d93f704c),\n/* harmony export */   useFormReset: () => (/* binding */ $99facab73266f662$export$5add1d006293d136),\n/* harmony export */   useGlobalListeners: () => (/* binding */ $03deb23ff14920c4$export$4eaf04e54aa8eed6),\n/* harmony export */   useId: () => (/* binding */ $bdb11010cef70236$export$f680877a34711e37),\n/* harmony export */   useLabels: () => (/* binding */ $313b98861ee5dd6c$export$d6875122194c7b44),\n/* harmony export */   useLayoutEffect: () => (/* binding */ $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c),\n/* harmony export */   useObjectRef: () => (/* binding */ $df56164dff5785e2$export$4338b53315abf666),\n/* harmony export */   useResizeObserver: () => (/* binding */ $9daab02d461809db$export$683480f191c0e3ea),\n/* harmony export */   useRouter: () => (/* binding */ $ea8dcbcb9ea1b556$export$9a302a45f65d0572),\n/* harmony export */   useSlotId: () => (/* binding */ $bdb11010cef70236$export$b4cc09c592e8fdb8),\n/* harmony export */   useSyncRef: () => (/* binding */ $e7801be82b4b2a53$export$4debdb1a3f0fa79e),\n/* harmony export */   useUpdateEffect: () => (/* binding */ $4f58c5f72bcf79f7$export$496315a1608d9602),\n/* harmony export */   useValueEffect: () => (/* binding */ $1dbecbe27a04f9af$export$14d238f342723f25),\n/* harmony export */   useViewportSize: () => (/* binding */ $5df64b3807dc15ee$export$d699905dd57c73ca)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/./node_modules/@react-aria/utils/node_modules/@react-aria/ssr/dist/import.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== \"undefined\" ? (0, react__WEBPACK_IMPORTED_MODULE_0__).useLayoutEffect : ()=>{};\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {\n    const ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        ref.current = fn;\n    }, [\n        fn\n    ]);\n    // @ts-ignore\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        const f = ref.current;\n        return f(...args);\n    }, []);\n}\nfunction $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {\n    let [value1, setValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue);\n    let effect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Store the function in a ref so we can always access the current version\n    // which has the proper `value` in scope.\n    let nextRef = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{\n        // Run the generator to the next yield.\n        let newValue = effect.current.next();\n        // If the generator is done, reset the effect.\n        if (newValue.done) {\n            effect.current = null;\n            return;\n        }\n        // If the value is the same as the current value,\n        // then continue to the next yield. Otherwise,\n        // set the value in state and wait for the next layout effect.\n        if (value1 === newValue.value) nextRef();\n        else setValue(newValue.value);\n    });\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        // If there is an effect currently running, continue to the next yield.\n        if (effect.current) nextRef();\n    });\n    let queue = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((fn)=>{\n        effect.current = fn(value1);\n        nextRef();\n    });\n    return [\n        value1,\n        queue\n    ];\n}\n// copied from SSRProvider.tsx to reduce exports, if needed again, consider sharing\nlet $bdb11010cef70236$var$canUseDOM = Boolean( false && 0);\nlet $bdb11010cef70236$var$idsUpdaterMap = new Map();\nfunction $bdb11010cef70236$export$f680877a34711e37(defaultId) {\n    let [value1, setValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultId);\n    let nextId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let res = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__.useSSRSafeId)(value1);\n    let updateValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((val)=>{\n        nextId.current = val;\n    }, []);\n    if ($bdb11010cef70236$var$canUseDOM) $bdb11010cef70236$var$idsUpdaterMap.set(res, updateValue);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        let r = res;\n        return ()=>{\n            $bdb11010cef70236$var$idsUpdaterMap.delete(r);\n        };\n    }, [\n        res\n    ]);\n    // This cannot cause an infinite loop because the ref is updated first.\n    // eslint-disable-next-line\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let newId = nextId.current;\n        if (newId) {\n            nextId.current = null;\n            setValue(newId);\n        }\n    });\n    return res;\n}\nfunction $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {\n    if (idA === idB) return idA;\n    let setIdA = $bdb11010cef70236$var$idsUpdaterMap.get(idA);\n    if (setIdA) {\n        setIdA(idB);\n        return idB;\n    }\n    let setIdB = $bdb11010cef70236$var$idsUpdaterMap.get(idB);\n    if (setIdB) {\n        setIdB(idA);\n        return idA;\n    }\n    return idB;\n}\nfunction $bdb11010cef70236$export$b4cc09c592e8fdb8(depArray = []) {\n    let id = $bdb11010cef70236$export$f680877a34711e37();\n    let [resolvedId, setResolvedId] = (0, $1dbecbe27a04f9af$export$14d238f342723f25)(id);\n    let updateId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResolvedId(function*() {\n            yield id;\n            yield document.getElementById(id) ? id : undefined;\n        });\n    }, [\n        id,\n        setResolvedId\n    ]);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updateId, [\n        id,\n        updateId,\n        ...depArray\n    ]);\n    return resolvedId;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Calls all functions in the order they were chained with the same arguments.\n */ function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks) {\n    return (...args)=>{\n        for (let callback of callbacks)if (typeof callback === \"function\") callback(...args);\n    };\n}\nconst $431fbd86ca7dc216$export$b204af158042fbac = (el)=>{\n    var _el_ownerDocument;\n    return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;\n};\nconst $431fbd86ca7dc216$export$f21a1ffae260145a = (el)=>{\n    if (el && \"window\" in el && el.window === el) return el;\n    const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);\n    return doc.defaultView || window;\n};\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $3ef42575df84b30b$export$9d1611c77c2fe928(...args) {\n    // Start with a base clone of the first argument. This is a lot faster than starting\n    // with an empty object and adding properties as we go.\n    let result = {\n        ...args[0]\n    };\n    for(let i = 1; i < args.length; i++){\n        let props = args[i];\n        for(let key in props){\n            let a = result[key];\n            let b = props[key];\n            // Chain events\n            if (typeof a === \"function\" && typeof b === \"function\" && // This is a lot faster than a regex.\n            key[0] === \"o\" && key[1] === \"n\" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a, b);\n            else if ((key === \"className\" || key === \"UNSAFE_className\") && typeof a === \"string\" && typeof b === \"string\") result[key] = (0, clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a, b);\n            else if (key === \"id\" && a && b) result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a, b);\n            else result[key] = b !== undefined ? b : a;\n        }\n    }\n    return result;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $5dc95899b306f630$export$c9058316764c140e(...refs) {\n    if (refs.length === 1) return refs[0];\n    return (value1)=>{\n        for (let ref of refs){\n            if (typeof ref === \"function\") ref(value1);\n            else if (ref != null) ref.current = value1;\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $65484d02dcb7eb3e$var$DOMPropNames = new Set([\n    \"id\"\n]);\nconst $65484d02dcb7eb3e$var$labelablePropNames = new Set([\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-describedby\",\n    \"aria-details\"\n]);\n// See LinkDOMProps in dom.d.ts.\nconst $65484d02dcb7eb3e$var$linkPropNames = new Set([\n    \"href\",\n    \"target\",\n    \"rel\",\n    \"download\",\n    \"ping\",\n    \"referrerPolicy\"\n]);\nconst $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;\nfunction $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {}) {\n    let { labelable: labelable, isLink: isLink, propNames: propNames } = opts;\n    let filteredProps = {};\n    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || isLink && $65484d02dcb7eb3e$var$linkPropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop))) filteredProps[prop] = props[prop];\n    return filteredProps;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $7215afc6de606d6b$export$de79e2c695e052f3(element) {\n    if ($7215afc6de606d6b$var$supportsPreventScroll()) element.focus({\n        preventScroll: true\n    });\n    else {\n        let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);\n        element.focus();\n        $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);\n    }\n}\nlet $7215afc6de606d6b$var$supportsPreventScrollCached = null;\nfunction $7215afc6de606d6b$var$supportsPreventScroll() {\n    if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {\n        $7215afc6de606d6b$var$supportsPreventScrollCached = false;\n        try {\n            var focusElem = document.createElement(\"div\");\n            focusElem.focus({\n                get preventScroll () {\n                    $7215afc6de606d6b$var$supportsPreventScrollCached = true;\n                    return true;\n                }\n            });\n        } catch (e) {\n        // Ignore\n        }\n    }\n    return $7215afc6de606d6b$var$supportsPreventScrollCached;\n}\nfunction $7215afc6de606d6b$var$getScrollableElements(element) {\n    var parent = element.parentNode;\n    var scrollableElements = [];\n    var rootScrollingElement = document.scrollingElement || document.documentElement;\n    while(parent instanceof HTMLElement && parent !== rootScrollingElement){\n        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({\n            element: parent,\n            scrollTop: parent.scrollTop,\n            scrollLeft: parent.scrollLeft\n        });\n        parent = parent.parentNode;\n    }\n    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({\n        element: rootScrollingElement,\n        scrollTop: rootScrollingElement.scrollTop,\n        scrollLeft: rootScrollingElement.scrollLeft\n    });\n    return scrollableElements;\n}\nfunction $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {\n    for (let { element: element, scrollTop: scrollTop, scrollLeft: scrollLeft } of scrollableElements){\n        element.scrollTop = scrollTop;\n        element.scrollLeft = scrollLeft;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $ab71dadb03a6fb2e$export$622cea445a1c5b7d(element, reverse, orientation = \"horizontal\") {\n    let rect = element.getBoundingClientRect();\n    if (reverse) return orientation === \"horizontal\" ? rect.right : rect.bottom;\n    return orientation === \"horizontal\" ? rect.left : rect.top;\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c87311424ea30a05$var$testUserAgent(re) {\n    var _window_navigator_userAgentData;\n    if (true) return false;\n    return ((_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);\n}\nfunction $c87311424ea30a05$var$testPlatform(re) {\n    var _window_navigator_userAgentData;\n    return  false ? 0 : false;\n}\nfunction $c87311424ea30a05$export$9ac100e40613ea10() {\n    return $c87311424ea30a05$var$testPlatform(/^Mac/i);\n}\nfunction $c87311424ea30a05$export$186c6964ca17d99() {\n    return $c87311424ea30a05$var$testPlatform(/^iPhone/i);\n}\nfunction $c87311424ea30a05$export$7bef049ce92e4224() {\n    return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;\n}\nfunction $c87311424ea30a05$export$fedb369cb70207f1() {\n    return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();\n}\nfunction $c87311424ea30a05$export$e1865c3bedcd822b() {\n    return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();\n}\nfunction $c87311424ea30a05$export$78551043582a6a98() {\n    return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();\n}\nfunction $c87311424ea30a05$export$6446a186d09e379e() {\n    return $c87311424ea30a05$var$testUserAgent(/Chrome/i);\n}\nfunction $c87311424ea30a05$export$a11b0059900ceec8() {\n    return $c87311424ea30a05$var$testUserAgent(/Android/i);\n}\nfunction $c87311424ea30a05$export$b7d78993b74f766d() {\n    return $c87311424ea30a05$var$testUserAgent(/Firefox/i);\n}\nconst $ea8dcbcb9ea1b556$var$RouterContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    isNative: true,\n    open: $ea8dcbcb9ea1b556$var$openSyntheticLink\n});\nfunction $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb(props) {\n    let { children: children, navigate: navigate } = props;\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            isNative: false,\n            open: (target, modifiers)=>{\n                $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>{\n                    if ($ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers)) navigate(link.pathname + link.search + link.hash);\n                    else $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers);\n                });\n            }\n        }), [\n        navigate\n    ]);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($ea8dcbcb9ea1b556$var$RouterContext.Provider, {\n        value: ctx\n    }, children);\n}\nfunction $ea8dcbcb9ea1b556$export$9a302a45f65d0572() {\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($ea8dcbcb9ea1b556$var$RouterContext);\n}\nfunction $ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers) {\n    // Use getAttribute here instead of link.target. Firefox will default link.target to \"_parent\" when inside an iframe.\n    let target = link.getAttribute(\"target\");\n    return (!target || target === \"_self\") && link.origin === location.origin && !link.hasAttribute(\"download\") && !modifiers.metaKey && // open in new tab (mac)\n    !modifiers.ctrlKey && // open in new tab (windows)\n    !modifiers.altKey && // download\n    !modifiers.shiftKey;\n}\nfunction $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {\n    var _window_event_type, _window_event;\n    let { metaKey: metaKey, ctrlKey: ctrlKey, altKey: altKey, shiftKey: shiftKey } = modifiers;\n    // Firefox does not recognize keyboard events as a user action by default, and the popup blocker\n    // will prevent links with target=\"_blank\" from opening. However, it does allow the event if the\n    // Command/Control key is held, which opens the link in a background tab. This seems like the best we can do.\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=257870 and https://bugzilla.mozilla.org/show_bug.cgi?id=746640.\n    if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith(\"key\")) && target.target === \"_blank\") {\n        if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) metaKey = true;\n        else ctrlKey = true;\n    }\n    // WebKit does not support firing click events with modifier keys, but does support keyboard events.\n    // https://github.com/WebKit/WebKit/blob/c03d0ac6e6db178f90923a0a63080b5ca210d25f/Source/WebCore/html/HTMLAnchorElement.cpp#L184\n    let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent(\"keydown\", {\n        keyIdentifier: \"Enter\",\n        metaKey: metaKey,\n        ctrlKey: ctrlKey,\n        altKey: altKey,\n        shiftKey: shiftKey\n    }) : new MouseEvent(\"click\", {\n        metaKey: metaKey,\n        ctrlKey: ctrlKey,\n        altKey: altKey,\n        shiftKey: shiftKey,\n        bubbles: true,\n        cancelable: true\n    });\n    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;\n    (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);\n    target.dispatchEvent(event);\n    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;\n}\n// https://github.com/parcel-bundler/parcel/issues/8724\n$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;\nfunction $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open) {\n    if (target instanceof HTMLAnchorElement) open(target);\n    else if (target.hasAttribute(\"data-href\")) {\n        let link = document.createElement(\"a\");\n        link.href = target.getAttribute(\"data-href\");\n        if (target.hasAttribute(\"data-target\")) link.target = target.getAttribute(\"data-target\");\n        if (target.hasAttribute(\"data-rel\")) link.rel = target.getAttribute(\"data-rel\");\n        if (target.hasAttribute(\"data-download\")) link.download = target.getAttribute(\"data-download\");\n        if (target.hasAttribute(\"data-ping\")) link.ping = target.getAttribute(\"data-ping\");\n        if (target.hasAttribute(\"data-referrer-policy\")) link.referrerPolicy = target.getAttribute(\"data-referrer-policy\");\n        target.appendChild(link);\n        open(link);\n        target.removeChild(link);\n    }\n}\nfunction $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {\n    $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>$ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers));\n}\nfunction $ea8dcbcb9ea1b556$export$51437d503373d223(props) {\n    return {\n        \"data-href\": props.href,\n        \"data-target\": props.target,\n        \"data-rel\": props.rel,\n        \"data-download\": props.download,\n        \"data-ping\": props.ping,\n        \"data-referrer-policy\": props.referrerPolicy\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet $bbed8b41f857bcc0$var$transitionsByElement = new Map();\n// A list of callbacks to call once there are no transitioning elements.\nlet $bbed8b41f857bcc0$var$transitionCallbacks = new Set();\nfunction $bbed8b41f857bcc0$var$setupGlobalEvents() {\n    if (true) return;\n    let onTransitionStart = (e)=>{\n        // Add the transitioning property to the list for this element.\n        let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!transitions) {\n            transitions = new Set();\n            $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions);\n            // The transitioncancel event must be registered on the element itself, rather than as a global\n            // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n            e.target.addEventListener(\"transitioncancel\", onTransitionEnd);\n        }\n        transitions.add(e.propertyName);\n    };\n    let onTransitionEnd = (e)=>{\n        // Remove property from list of transitioning properties.\n        let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!properties) return;\n        properties.delete(e.propertyName);\n        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n        if (properties.size === 0) {\n            e.target.removeEventListener(\"transitioncancel\", onTransitionEnd);\n            $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);\n        }\n        // If no transitioning elements, call all of the queued callbacks.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {\n            for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)cb();\n            $bbed8b41f857bcc0$var$transitionCallbacks.clear();\n        }\n    };\n    document.body.addEventListener(\"transitionrun\", onTransitionStart);\n    document.body.addEventListener(\"transitionend\", onTransitionEnd);\n}\nif (typeof document !== \"undefined\") {\n    if (document.readyState !== \"loading\") $bbed8b41f857bcc0$var$setupGlobalEvents();\n    else document.addEventListener(\"DOMContentLoaded\", $bbed8b41f857bcc0$var$setupGlobalEvents);\n}\nfunction $bbed8b41f857bcc0$export$24490316f764c430(fn) {\n    // Wait one frame to see if an animation starts, e.g. a transition on mount.\n    requestAnimationFrame(()=>{\n        // If no transitions are running, call the function immediately.\n        // Otherwise, add it to a list of callbacks to run at the end of the animation.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();\n        else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);\n    });\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /* eslint-disable rulesdir/pure-render */ // Keep track of elements that we are currently handling dragging for via useDrag1D.\n// If there's an ancestor and a descendant both using useDrag1D(), and the user starts\n// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.\nconst $9cc09df9fd7676be$var$draggingElements = [];\nfunction $9cc09df9fd7676be$export$7bbed75feba39706(props) {\n    console.warn(\"useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html\");\n    let { containerRef: containerRef, reverse: reverse, orientation: orientation, onHover: onHover, onDrag: onDrag, onPositionChange: onPositionChange, onIncrement: onIncrement, onDecrement: onDecrement, onIncrementToMax: onIncrementToMax, onDecrementToMin: onDecrementToMin, onCollapseToggle: onCollapseToggle } = props;\n    let getPosition = (e)=>orientation === \"horizontal\" ? e.clientX : e.clientY;\n    let getNextOffset = (e)=>{\n        let containerOffset = (0, $ab71dadb03a6fb2e$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);\n        let mouseOffset = getPosition(e);\n        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;\n        return nextOffset;\n    };\n    let dragging = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let prevPosition = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Keep track of the current handlers in a ref so that the events can access them.\n    let handlers = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        onPositionChange: onPositionChange,\n        onDrag: onDrag\n    });\n    handlers.current.onDrag = onDrag;\n    handlers.current.onPositionChange = onPositionChange;\n    let onMouseDragged = (e)=>{\n        e.preventDefault();\n        let nextOffset = getNextOffset(e);\n        if (!dragging.current) {\n            dragging.current = true;\n            if (handlers.current.onDrag) handlers.current.onDrag(true);\n            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        }\n        if (prevPosition.current === nextOffset) return;\n        prevPosition.current = nextOffset;\n        if (onPositionChange) onPositionChange(nextOffset);\n    };\n    let onMouseUp = (e)=>{\n        const target = e.target;\n        dragging.current = false;\n        let nextOffset = getNextOffset(e);\n        if (handlers.current.onDrag) handlers.current.onDrag(false);\n        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        $9cc09df9fd7676be$var$draggingElements.splice($9cc09df9fd7676be$var$draggingElements.indexOf(target), 1);\n        window.removeEventListener(\"mouseup\", onMouseUp, false);\n        window.removeEventListener(\"mousemove\", onMouseDragged, false);\n    };\n    let onMouseDown = (e)=>{\n        const target = e.currentTarget;\n        // If we're already handling dragging on a descendant with useDrag1D, then\n        // we don't want to handle the drag motion on this target as well.\n        if ($9cc09df9fd7676be$var$draggingElements.some((elt)=>target.contains(elt))) return;\n        $9cc09df9fd7676be$var$draggingElements.push(target);\n        window.addEventListener(\"mousemove\", onMouseDragged, false);\n        window.addEventListener(\"mouseup\", onMouseUp, false);\n    };\n    let onMouseEnter = ()=>{\n        if (onHover) onHover(true);\n    };\n    let onMouseOut = ()=>{\n        if (onHover) onHover(false);\n    };\n    let onKeyDown = (e)=>{\n        switch(e.key){\n            case \"Left\":\n            case \"ArrowLeft\":\n                if (orientation === \"horizontal\") {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case \"Up\":\n            case \"ArrowUp\":\n                if (orientation === \"vertical\") {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case \"Right\":\n            case \"ArrowRight\":\n                if (orientation === \"horizontal\") {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case \"Down\":\n            case \"ArrowDown\":\n                if (orientation === \"vertical\") {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case \"Home\":\n                e.preventDefault();\n                if (onDecrementToMin) onDecrementToMin();\n                break;\n            case \"End\":\n                e.preventDefault();\n                if (onIncrementToMax) onIncrementToMax();\n                break;\n            case \"Enter\":\n                e.preventDefault();\n                if (onCollapseToggle) onCollapseToggle();\n                break;\n        }\n    };\n    return {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        onKeyDown: onKeyDown\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {\n    let globalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let addGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        // Make sure we remove the listener after it is called with the `once` option.\n        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{\n            globalListeners.current.delete(listener);\n            listener(...args);\n        } : listener;\n        globalListeners.current.set(listener, {\n            type: type,\n            eventTarget: eventTarget,\n            fn: fn,\n            options: options\n        });\n        eventTarget.addEventListener(type, listener, options);\n    }, []);\n    let removeGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        var _globalListeners_current_get;\n        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;\n        eventTarget.removeEventListener(type, fn, options);\n        globalListeners.current.delete(listener);\n    }, []);\n    let removeAllGlobalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        globalListeners.current.forEach((value1, key)=>{\n            removeGlobalListener(value1.eventTarget, value1.type, key, value1.options);\n        });\n    }, [\n        removeGlobalListener\n    ]);\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return removeAllGlobalListeners;\n    }, [\n        removeAllGlobalListeners\n    ]);\n    return {\n        addGlobalListener: addGlobalListener,\n        removeGlobalListener: removeGlobalListener,\n        removeAllGlobalListeners: removeAllGlobalListeners\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $313b98861ee5dd6c$export$d6875122194c7b44(props, defaultLabel) {\n    let { id: id, \"aria-label\": label, \"aria-labelledby\": labelledBy } = props;\n    // If there is both an aria-label and aria-labelledby,\n    // combine them by pointing to the element itself.\n    id = (0, $bdb11010cef70236$export$f680877a34711e37)(id);\n    if (labelledBy && label) {\n        let ids = new Set([\n            id,\n            ...labelledBy.trim().split(/\\s+/)\n        ]);\n        labelledBy = [\n            ...ids\n        ].join(\" \");\n    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\\s+/).join(\" \");\n    // If no labels are provided, use the default\n    if (!label && !labelledBy && defaultLabel) label = defaultLabel;\n    return {\n        id: id,\n        \"aria-label\": label,\n        \"aria-labelledby\": labelledBy\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {\n    const objRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            get current () {\n                return objRef.current;\n            },\n            set current (value){\n                objRef.current = value;\n                if (typeof forwardedRef === \"function\") forwardedRef(value);\n                else if (forwardedRef) forwardedRef.current = value;\n            }\n        }), [\n        forwardedRef\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $4f58c5f72bcf79f7$export$496315a1608d9602(effect, dependencies) {\n    const isInitialMount = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const lastDeps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        isInitialMount.current = true;\n        return ()=>{\n            isInitialMount.current = false;\n        };\n    }, []);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isInitialMount.current) isInitialMount.current = false;\n        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();\n        lastDeps.current = dependencies;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, dependencies);\n}\nfunction $9daab02d461809db$var$hasResizeObserver() {\n    return typeof window.ResizeObserver !== \"undefined\";\n}\nfunction $9daab02d461809db$export$683480f191c0e3ea(options) {\n    const { ref: ref, onResize: onResize } = options;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let element = ref === null || ref === void 0 ? void 0 : ref.current;\n        if (!element) return;\n        if (!$9daab02d461809db$var$hasResizeObserver()) {\n            window.addEventListener(\"resize\", onResize, false);\n            return ()=>{\n                window.removeEventListener(\"resize\", onResize, false);\n            };\n        } else {\n            const resizeObserverInstance = new window.ResizeObserver((entries)=>{\n                if (!entries.length) return;\n                onResize();\n            });\n            resizeObserverInstance.observe(element);\n            return ()=>{\n                if (element) resizeObserverInstance.unobserve(element);\n            };\n        }\n    }, [\n        onResize,\n        ref\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (context && context.ref && ref) {\n            context.ref.current = ref.current;\n            return ()=>{\n                context.ref.current = null;\n            };\n        }\n    });\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $62d8ded9296f3872$export$cfa2225e87938781(node, checkForOverflow) {\n    if ($62d8ded9296f3872$export$2bb74740c4e19def(node, checkForOverflow)) node = node.parentElement;\n    while(node && !$62d8ded9296f3872$export$2bb74740c4e19def(node, checkForOverflow))node = node.parentElement;\n    return node || document.scrollingElement || document.documentElement;\n}\nfunction $62d8ded9296f3872$export$2bb74740c4e19def(node, checkForOverflow) {\n    let style = window.getComputedStyle(node);\n    let isScrollable = /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n    if (isScrollable && checkForOverflow) isScrollable = node.scrollHeight !== node.clientHeight || node.scrollWidth !== node.clientWidth;\n    return isScrollable;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // @ts-ignore\nlet $5df64b3807dc15ee$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction $5df64b3807dc15ee$export$d699905dd57c73ca() {\n    let isSSR = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__.useIsSSR)();\n    let [size, setSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>isSSR ? {\n            width: 0,\n            height: 0\n        } : $5df64b3807dc15ee$var$getViewportSize());\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Use visualViewport api to track available height even on iOS virtual keyboard opening\n        let onResize = ()=>{\n            setSize((size)=>{\n                let newSize = $5df64b3807dc15ee$var$getViewportSize();\n                if (newSize.width === size.width && newSize.height === size.height) return size;\n                return newSize;\n            });\n        };\n        if (!$5df64b3807dc15ee$var$visualViewport) window.addEventListener(\"resize\", onResize);\n        else $5df64b3807dc15ee$var$visualViewport.addEventListener(\"resize\", onResize);\n        return ()=>{\n            if (!$5df64b3807dc15ee$var$visualViewport) window.removeEventListener(\"resize\", onResize);\n            else $5df64b3807dc15ee$var$visualViewport.removeEventListener(\"resize\", onResize);\n        };\n    }, []);\n    return size;\n}\nfunction $5df64b3807dc15ee$var$getViewportSize() {\n    return {\n        width: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.width) || window.innerWidth,\n        height: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.height) || window.innerHeight\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ef06256079686ba0$var$descriptionId = 0;\nconst $ef06256079686ba0$var$descriptionNodes = new Map();\nfunction $ef06256079686ba0$export$f8aeda7b10753fa1(description) {\n    let [id, setId] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (!description) return;\n        let desc = $ef06256079686ba0$var$descriptionNodes.get(description);\n        if (!desc) {\n            let id = `react-aria-description-${$ef06256079686ba0$var$descriptionId++}`;\n            setId(id);\n            let node = document.createElement(\"div\");\n            node.id = id;\n            node.style.display = \"none\";\n            node.textContent = description;\n            document.body.appendChild(node);\n            desc = {\n                refCount: 0,\n                element: node\n            };\n            $ef06256079686ba0$var$descriptionNodes.set(description, desc);\n        } else setId(desc.element.id);\n        desc.refCount++;\n        return ()=>{\n            if (--desc.refCount === 0) {\n                desc.element.remove();\n                $ef06256079686ba0$var$descriptionNodes.delete(description);\n            }\n        };\n    }, [\n        description\n    ]);\n    return {\n        \"aria-describedby\": description ? id : undefined\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e9faafb641e167db$export$90fc3a17d93f704c(ref, event, handler, options) {\n    let handleEvent = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(handler);\n    let isDisabled = handler == null;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isDisabled) return;\n        let element = ref.current;\n        element.addEventListener(event, handleEvent, options);\n        return ()=>{\n            element.removeEventListener(event, handleEvent, options);\n        };\n    }, [\n        ref,\n        event,\n        options,\n        isDisabled,\n        handleEvent\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollView, element) {\n    let offsetX = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, \"left\");\n    let offsetY = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, \"top\");\n    let width = element.offsetWidth;\n    let height = element.offsetHeight;\n    let x = scrollView.scrollLeft;\n    let y = scrollView.scrollTop;\n    // Account for top/left border offsetting the scroll top/Left\n    let { borderTopWidth: borderTopWidth, borderLeftWidth: borderLeftWidth } = getComputedStyle(scrollView);\n    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);\n    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);\n    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width\n    let maxX = borderAdjustedX + scrollView.clientWidth;\n    let maxY = borderAdjustedY + scrollView.clientHeight;\n    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);\n    else if (offsetX + width > maxX) x += offsetX + width - maxX;\n    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);\n    else if (offsetY + height > maxY) y += offsetY + height - maxY;\n    scrollView.scrollLeft = x;\n    scrollView.scrollTop = y;\n}\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */ function $2f04cbc44ee30ce0$var$relativeOffset(ancestor, child, axis) {\n    const prop = axis === \"left\" ? \"offsetLeft\" : \"offsetTop\";\n    let sum = 0;\n    while(child.offsetParent){\n        sum += child[prop];\n        if (child.offsetParent === ancestor) break;\n        else if (child.offsetParent.contains(ancestor)) {\n            // If the ancestor is not `position:relative`, then we stop at\n            // _its_ offset parent, and we subtract off _its_ offset, so that\n            // we end up with the proper offset from child to ancestor.\n            sum -= ancestor[prop];\n            break;\n        }\n        child = child.offsetParent;\n    }\n    return sum;\n}\nfunction $2f04cbc44ee30ce0$export$c826860796309d1b(targetElement, opts) {\n    if (document.contains(targetElement)) {\n        let root = document.scrollingElement || document.documentElement;\n        let isScrollPrevented = window.getComputedStyle(root).overflow === \"hidden\";\n        // If scrolling is not currently prevented then we arent in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view\n        if (!isScrollPrevented) {\n            var // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically\n            _targetElement_scrollIntoView;\n            let { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();\n            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {\n                block: \"nearest\"\n            });\n            let { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();\n            // Account for sub pixel differences from rounding\n            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {\n                var _opts_containingElement_scrollIntoView, _opts_containingElement, _targetElement_scrollIntoView1;\n                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {\n                    block: \"center\",\n                    inline: \"center\"\n                });\n                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {\n                    block: \"nearest\"\n                });\n            }\n        } else {\n            let scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);\n            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.\n            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){\n                $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollParent, targetElement);\n                targetElement = scrollParent;\n                scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);\n            }\n        }\n    }\n}\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6a7db85432448f7f$export$60278871457622de(event) {\n    // JAWS/NVDA with Firefox.\n    if (event.mozInputSource === 0 && event.isTrusted) return true;\n    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead\n    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check\n    // to detect TalkBack virtual clicks.\n    if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType) return event.type === \"click\" && event.buttons === 1;\n    return event.detail === 0 && !event.pointerType;\n}\nfunction $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {\n    // If the pointer size is zero, then we assume it's from a screen reader.\n    // Android TalkBack double tap will sometimes return a event with width and height of 1\n    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.\n    // Cannot use \"event.pressure === 0\" as the sole check due to Safari pointer events always returning pressure === 0\n    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush\n    // Talkback double tap from Windows Firefox touch screen press\n    return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\";\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /* eslint-disable rulesdir/pure-render */ function $5a387cc49350e6db$export$722debc0e56fea39(value1, isEqual) {\n    // Using a ref during render is ok here because it's only an optimization  both values are equivalent.\n    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.\n    let lastValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (value1 && lastValue.current && isEqual(value1, lastValue.current)) value1 = lastValue.current;\n    lastValue.current = value1;\n    return value1;\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $99facab73266f662$export$5add1d006293d136(ref, initialValue, onReset) {\n    let resetValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialValue);\n    let handleReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{\n        if (onReset) onReset(resetValue.current);\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _ref_current;\n        let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;\n        form === null || form === void 0 ? void 0 : form.addEventListener(\"reset\", handleReset);\n        return ()=>{\n            form === null || form === void 0 ? void 0 : form.removeEventListener(\"reset\", handleReset);\n        };\n    }, [\n        ref,\n        handleReset\n    ]);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdKO0FBQzhHO0FBQzdKO0FBQ2xFO0FBRS9COzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0Q7Ozs7Ozs7Ozs7Q0FVQyxHQUNELE1BQU13Qiw0Q0FBNEMsT0FBT0MsYUFBYSxjQUFjLENBQUMsR0FBR3JCLGtDQUFXLEVBQUdzQixlQUFlLEdBQUcsS0FBSztBQUk3SDs7Ozs7Ozs7OztDQVVDLEdBQ0Q7Ozs7Ozs7Ozs7Q0FVQyxHQUVELFNBQVNDLDBDQUEwQ0MsRUFBRTtJQUNqRCxNQUFNQyxNQUFNLENBQUMsR0FBR3JCLHlDQUFZLEVBQUc7SUFDOUIsSUFBR2dCLHlDQUF3QyxFQUFHO1FBQzNDSyxJQUFJQyxPQUFPLEdBQUdGO0lBQ2xCLEdBQUc7UUFDQ0E7S0FDSDtJQUNELGFBQWE7SUFDYixPQUFPLENBQUMsR0FBR2xCLDhDQUFpQixFQUFHLENBQUMsR0FBR3FCO1FBQy9CLE1BQU1DLElBQUlILElBQUlDLE9BQU87UUFDckIsT0FBT0UsS0FBS0Q7SUFDaEIsR0FBRyxFQUFFO0FBQ1Q7QUFHQSxTQUFTRSwwQ0FBMENDLFlBQVk7SUFDM0QsSUFBSSxDQUFDQyxRQUFPQyxTQUFTLEdBQUcsQ0FBQyxHQUFHOUIsMkNBQWMsRUFBRzRCO0lBQzdDLElBQUlHLFNBQVMsQ0FBQyxHQUFHN0IseUNBQVksRUFBRztJQUNoQywwRUFBMEU7SUFDMUUseUNBQXlDO0lBQ3pDLElBQUk4QixVQUFVLENBQUMsR0FBR1gseUNBQXdDLEVBQUc7UUFDekQsdUNBQXVDO1FBQ3ZDLElBQUlZLFdBQVdGLE9BQU9QLE9BQU8sQ0FBQ1UsSUFBSTtRQUNsQyw4Q0FBOEM7UUFDOUMsSUFBSUQsU0FBU0UsSUFBSSxFQUFFO1lBQ2ZKLE9BQU9QLE9BQU8s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Oi8vY2Fyem9uZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS91dGlscy9kaXN0L2ltcG9ydC5tanM/NDQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NsYW1wIGFzICQ0NTA3NDYxYTFiODcwMTIzJHJlX2V4cG9ydCRjbGFtcCwgc25hcFZhbHVlVG9TdGVwIGFzICQ0NTA3NDYxYTFiODcwMTIzJHJlX2V4cG9ydCRzbmFwVmFsdWVUb1N0ZXB9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuaW1wb3J0ICQxMnVHcCRyZWFjdCwge3VzZVN0YXRlIGFzICQxMnVHcCR1c2VTdGF0ZSwgdXNlUmVmIGFzICQxMnVHcCR1c2VSZWYsIHVzZUNhbGxiYWNrIGFzICQxMnVHcCR1c2VDYWxsYmFjaywgdXNlRWZmZWN0IGFzICQxMnVHcCR1c2VFZmZlY3QsIGNyZWF0ZUNvbnRleHQgYXMgJDEydUdwJGNyZWF0ZUNvbnRleHQsIHVzZU1lbW8gYXMgJDEydUdwJHVzZU1lbW8sIHVzZUNvbnRleHQgYXMgJDEydUdwJHVzZUNvbnRleHR9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VTU1JTYWZlSWQgYXMgJDEydUdwJHVzZVNTUlNhZmVJZCwgdXNlSXNTU1IgYXMgJDEydUdwJHVzZUlzU1NSfSBmcm9tIFwiQHJlYWN0LWFyaWEvc3NyXCI7XG5pbXBvcnQgJDEydUdwJGNsc3ggZnJvbSBcImNsc3hcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNvbnN0ICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gKDAsICQxMnVHcCRyZWFjdCkudXNlTGF5b3V0RWZmZWN0IDogKCk9Pnt9O1xuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkOGFlMDVlYWE1YzExNGU5YyRleHBvcnQkN2Y1NGZjMzE4MDUwOGE1Mihmbikge1xuICAgIGNvbnN0IHJlZiA9ICgwLCAkMTJ1R3AkdXNlUmVmKShudWxsKTtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIHJlZi5jdXJyZW50ID0gZm47XG4gICAgfSwgW1xuICAgICAgICBmblxuICAgIF0pO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKC4uLmFyZ3MpPT57XG4gICAgICAgIGNvbnN0IGYgPSByZWYuY3VycmVudDtcbiAgICAgICAgcmV0dXJuIGYoLi4uYXJncyk7XG4gICAgfSwgW10pO1xufVxuXG5cbmZ1bmN0aW9uICQxZGJlY2JlMjdhMDRmOWFmJGV4cG9ydCQxNGQyMzhmMzQyNzIzZjI1KGRlZmF1bHRWYWx1ZSkge1xuICAgIGxldCBbdmFsdWUsIHNldFZhbHVlXSA9ICgwLCAkMTJ1R3AkdXNlU3RhdGUpKGRlZmF1bHRWYWx1ZSk7XG4gICAgbGV0IGVmZmVjdCA9ICgwLCAkMTJ1R3AkdXNlUmVmKShudWxsKTtcbiAgICAvLyBTdG9yZSB0aGUgZnVuY3Rpb24gaW4gYSByZWYgc28gd2UgY2FuIGFsd2F5cyBhY2Nlc3MgdGhlIGN1cnJlbnQgdmVyc2lvblxuICAgIC8vIHdoaWNoIGhhcyB0aGUgcHJvcGVyIGB2YWx1ZWAgaW4gc2NvcGUuXG4gICAgbGV0IG5leHRSZWYgPSAoMCwgJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIpKCgpPT57XG4gICAgICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIHRvIHRoZSBuZXh0IHlpZWxkLlxuICAgICAgICBsZXQgbmV3VmFsdWUgPSBlZmZlY3QuY3VycmVudC5uZXh0KCk7XG4gICAgICAgIC8vIElmIHRoZSBnZW5lcmF0b3IgaXMgZG9uZSwgcmVzZXQgdGhlIGVmZmVjdC5cbiAgICAgICAgaWYgKG5ld1ZhbHVlLmRvbmUpIHtcbiAgICAgICAgICAgIGVmZmVjdC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgdmFsdWUsXG4gICAgICAgIC8vIHRoZW4gY29udGludWUgdG8gdGhlIG5leHQgeWllbGQuIE90aGVyd2lzZSxcbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZSBpbiBzdGF0ZSBhbmQgd2FpdCBmb3IgdGhlIG5leHQgbGF5b3V0IGVmZmVjdC5cbiAgICAgICAgaWYgKHZhbHVlID09PSBuZXdWYWx1ZS52YWx1ZSkgbmV4dFJlZigpO1xuICAgICAgICBlbHNlIHNldFZhbHVlKG5ld1ZhbHVlLnZhbHVlKTtcbiAgICB9KTtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGVmZmVjdCBjdXJyZW50bHkgcnVubmluZywgY29udGludWUgdG8gdGhlIG5leHQgeWllbGQuXG4gICAgICAgIGlmIChlZmZlY3QuY3VycmVudCkgbmV4dFJlZigpO1xuICAgIH0pO1xuICAgIGxldCBxdWV1ZSA9ICgwLCAkOGFlMDVlYWE1YzExNGU5YyRleHBvcnQkN2Y1NGZjMzE4MDUwOGE1MikoKGZuKT0+e1xuICAgICAgICBlZmZlY3QuY3VycmVudCA9IGZuKHZhbHVlKTtcbiAgICAgICAgbmV4dFJlZigpO1xuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBxdWV1ZVxuICAgIF07XG59XG5cblxuLy8gY29waWVkIGZyb20gU1NSUHJvdmlkZXIudHN4IHRvIHJlZHVjZSBleHBvcnRzLCBpZiBuZWVkZWQgYWdhaW4sIGNvbnNpZGVyIHNoYXJpbmdcbmxldCAkYmRiMTEwMTBjZWY3MDIzNiR2YXIkY2FuVXNlRE9NID0gQm9vbGVhbih0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5sZXQgJGJkYjExMDEwY2VmNzAyMzYkdmFyJGlkc1VwZGF0ZXJNYXAgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkZjY4MDg3N2EzNDcxMWUzNyhkZWZhdWx0SWQpIHtcbiAgICBsZXQgW3ZhbHVlLCBzZXRWYWx1ZV0gPSAoMCwgJDEydUdwJHVzZVN0YXRlKShkZWZhdWx0SWQpO1xuICAgIGxldCBuZXh0SWQgPSAoMCwgJDEydUdwJHVzZVJlZikobnVsbCk7XG4gICAgbGV0IHJlcyA9ICgwLCAkMTJ1R3AkdXNlU1NSU2FmZUlkKSh2YWx1ZSk7XG4gICAgbGV0IHVwZGF0ZVZhbHVlID0gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKHZhbCk9PntcbiAgICAgICAgbmV4dElkLmN1cnJlbnQgPSB2YWw7XG4gICAgfSwgW10pO1xuICAgIGlmICgkYmRiMTEwMTBjZWY3MDIzNiR2YXIkY2FuVXNlRE9NKSAkYmRiMTEwMTBjZWY3MDIzNiR2YXIkaWRzVXBkYXRlck1hcC5zZXQocmVzLCB1cGRhdGVWYWx1ZSk7XG4gICAgKDAsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjKSgoKT0+e1xuICAgICAgICBsZXQgciA9IHJlcztcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAkYmRiMTEwMTBjZWY3MDIzNiR2YXIkaWRzVXBkYXRlck1hcC5kZWxldGUocik7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByZXNcbiAgICBdKTtcbiAgICAvLyBUaGlzIGNhbm5vdCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wIGJlY2F1c2UgdGhlIHJlZiBpcyB1cGRhdGVkIGZpcnN0LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgbmV3SWQgPSBuZXh0SWQuY3VycmVudDtcbiAgICAgICAgaWYgKG5ld0lkKSB7XG4gICAgICAgICAgICBuZXh0SWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBzZXRWYWx1ZShuZXdJZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGNkOGM5Y2I2OGY4NDI2MjkoaWRBLCBpZEIpIHtcbiAgICBpZiAoaWRBID09PSBpZEIpIHJldHVybiBpZEE7XG4gICAgbGV0IHNldElkQSA9ICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwLmdldChpZEEpO1xuICAgIGlmIChzZXRJZEEpIHtcbiAgICAgICAgc2V0SWRBKGlkQik7XG4gICAgICAgIHJldHVybiBpZEI7XG4gICAgfVxuICAgIGxldCBzZXRJZEIgPSAkYmRiMTEwMTBjZWY3MDIzNiR2YXIkaWRzVXBkYXRlck1hcC5nZXQoaWRCKTtcbiAgICBpZiAoc2V0SWRCKSB7XG4gICAgICAgIHNldElkQihpZEEpO1xuICAgICAgICByZXR1cm4gaWRBO1xuICAgIH1cbiAgICByZXR1cm4gaWRCO1xufVxuZnVuY3Rpb24gJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGI0Y2MwOWM1OTJlOGZkYjgoZGVwQXJyYXkgPSBbXSkge1xuICAgIGxldCBpZCA9ICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRmNjgwODc3YTM0NzExZTM3KCk7XG4gICAgbGV0IFtyZXNvbHZlZElkLCBzZXRSZXNvbHZlZElkXSA9ICgwLCAkMWRiZWNiZTI3YTA0ZjlhZiRleHBvcnQkMTRkMjM4ZjM0MjcyM2YyNSkoaWQpO1xuICAgIGxldCB1cGRhdGVJZCA9ICgwLCAkMTJ1R3AkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldFJlc29sdmVkSWQoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgeWllbGQgaWQ7XG4gICAgICAgICAgICB5aWVsZCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgPyBpZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBpZCxcbiAgICAgICAgc2V0UmVzb2x2ZWRJZFxuICAgIF0pO1xuICAgICgwLCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYykodXBkYXRlSWQsIFtcbiAgICAgICAgaWQsXG4gICAgICAgIHVwZGF0ZUlkLFxuICAgICAgICAuLi5kZXBBcnJheVxuICAgIF0pO1xuICAgIHJldHVybiByZXNvbHZlZElkO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKipcbiAqIENhbGxzIGFsbCBmdW5jdGlvbnMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSBjaGFpbmVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzLlxuICovIGZ1bmN0aW9uICRmZjU5NjNlYjFmY2NmNTUyJGV4cG9ydCRlMDhlM2I2N2UzOTIxMDFlKC4uLmNhbGxiYWNrcykge1xuICAgIHJldHVybiAoLi4uYXJncyk9PntcbiAgICAgICAgZm9yIChsZXQgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKWlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgfTtcbn1cblxuXG5jb25zdCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyA9IChlbCk9PntcbiAgICB2YXIgX2VsX293bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIChfZWxfb3duZXJEb2N1bWVudCA9IGVsID09PSBudWxsIHx8IGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbC5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfZWxfb3duZXJEb2N1bWVudCAhPT0gdm9pZCAwID8gX2VsX293bmVyRG9jdW1lbnQgOiBkb2N1bWVudDtcbn07XG5jb25zdCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkZjIxYTFmZmFlMjYwMTQ1YSA9IChlbCk9PntcbiAgICBpZiAoZWwgJiYgXCJ3aW5kb3dcIiBpbiBlbCAmJiBlbC53aW5kb3cgPT09IGVsKSByZXR1cm4gZWw7XG4gICAgY29uc3QgZG9jID0gJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGIyMDRhZjE1ODA0MmZiYWMoZWwpO1xuICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xufTtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuZnVuY3Rpb24gJDNlZjQyNTc1ZGY4NGIzMGIkZXhwb3J0JDlkMTYxMWM3N2MyZmU5MjgoLi4uYXJncykge1xuICAgIC8vIFN0YXJ0IHdpdGggYSBiYXNlIGNsb25lIG9mIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhpcyBpcyBhIGxvdCBmYXN0ZXIgdGhhbiBzdGFydGluZ1xuICAgIC8vIHdpdGggYW4gZW1wdHkgb2JqZWN0IGFuZCBhZGRpbmcgcHJvcGVydGllcyBhcyB3ZSBnby5cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAuLi5hcmdzWzBdXG4gICAgfTtcbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGxldCBwcm9wcyA9IGFyZ3NbaV07XG4gICAgICAgIGZvcihsZXQga2V5IGluIHByb3BzKXtcbiAgICAgICAgICAgIGxldCBhID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICBsZXQgYiA9IHByb3BzW2tleV07XG4gICAgICAgICAgICAvLyBDaGFpbiBldmVudHNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBiID09PSBcImZ1bmN0aW9uXCIgJiYgLy8gVGhpcyBpcyBhIGxvdCBmYXN0ZXIgdGhhbiBhIHJlZ2V4LlxuICAgICAgICAgICAga2V5WzBdID09PSBcIm9cIiAmJiBrZXlbMV0gPT09IFwiblwiICYmIGtleS5jaGFyQ29kZUF0KDIpID49IC8qICdBJyAqLyA2NSAmJiBrZXkuY2hhckNvZGVBdCgyKSA8PSAvKiAnWicgKi8gOTApIHJlc3VsdFtrZXldID0gKDAsICRmZjU5NjNlYjFmY2NmNTUyJGV4cG9ydCRlMDhlM2I2N2UzOTIxMDFlKShhLCBiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKChrZXkgPT09IFwiY2xhc3NOYW1lXCIgfHwga2V5ID09PSBcIlVOU0FGRV9jbGFzc05hbWVcIikgJiYgdHlwZW9mIGEgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGIgPT09IFwic3RyaW5nXCIpIHJlc3VsdFtrZXldID0gKDAsICQxMnVHcCRjbHN4KShhLCBiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJpZFwiICYmIGEgJiYgYikgcmVzdWx0LmlkID0gKDAsICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRjZDhjOWNiNjhmODQyNjI5KShhLCBiKTtcbiAgICAgICAgICAgIGVsc2UgcmVzdWx0W2tleV0gPSBiICE9PSB1bmRlZmluZWQgPyBiIDogYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkNWRjOTU4OTliMzA2ZjYzMCRleHBvcnQkYzkwNTgzMTY3NjRjMTQwZSguLi5yZWZzKSB7XG4gICAgaWYgKHJlZnMubGVuZ3RoID09PSAxKSByZXR1cm4gcmVmc1swXTtcbiAgICByZXR1cm4gKHZhbHVlKT0+e1xuICAgICAgICBmb3IgKGxldCByZWYgb2YgcmVmcyl7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSByZWYodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjb25zdCAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkRE9NUHJvcE5hbWVzID0gbmV3IFNldChbXG4gICAgXCJpZFwiXG5dKTtcbmNvbnN0ICQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRsYWJlbGFibGVQcm9wTmFtZXMgPSBuZXcgU2V0KFtcbiAgICBcImFyaWEtbGFiZWxcIixcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiLFxuICAgIFwiYXJpYS1kZXNjcmliZWRieVwiLFxuICAgIFwiYXJpYS1kZXRhaWxzXCJcbl0pO1xuLy8gU2VlIExpbmtET01Qcm9wcyBpbiBkb20uZC50cy5cbmNvbnN0ICQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRsaW5rUHJvcE5hbWVzID0gbmV3IFNldChbXG4gICAgXCJocmVmXCIsXG4gICAgXCJ0YXJnZXRcIixcbiAgICBcInJlbFwiLFxuICAgIFwiZG93bmxvYWRcIixcbiAgICBcInBpbmdcIixcbiAgICBcInJlZmVycmVyUG9saWN5XCJcbl0pO1xuY29uc3QgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJHByb3BSZSA9IC9eKGRhdGEtLiopJC87XG5mdW5jdGlvbiAkNjU0ODRkMDJkY2I3ZWIzZSRleHBvcnQkNDU3YzNkNjUxOGRkNGM2Zihwcm9wcywgb3B0cyA9IHt9KSB7XG4gICAgbGV0IHsgbGFiZWxhYmxlOiBsYWJlbGFibGUsIGlzTGluazogaXNMaW5rLCBwcm9wTmFtZXM6IHByb3BOYW1lcyB9ID0gb3B0cztcbiAgICBsZXQgZmlsdGVyZWRQcm9wcyA9IHt9O1xuICAgIGZvcihjb25zdCBwcm9wIGluIHByb3BzKWlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3ApICYmICgkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkRE9NUHJvcE5hbWVzLmhhcyhwcm9wKSB8fCBsYWJlbGFibGUgJiYgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxhYmVsYWJsZVByb3BOYW1lcy5oYXMocHJvcCkgfHwgaXNMaW5rICYmICQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRsaW5rUHJvcE5hbWVzLmhhcyhwcm9wKSB8fCAocHJvcE5hbWVzID09PSBudWxsIHx8IHByb3BOYW1lcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcE5hbWVzLmhhcyhwcm9wKSkgfHwgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJHByb3BSZS50ZXN0KHByb3ApKSkgZmlsdGVyZWRQcm9wc1twcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgIHJldHVybiBmaWx0ZXJlZFByb3BzO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkNzIxNWFmYzZkZTYwNmQ2YiRleHBvcnQkZGU3OWUyYzY5NWUwNTJmMyhlbGVtZW50KSB7XG4gICAgaWYgKCQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGwoKSkgZWxlbWVudC5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHNjcm9sbGFibGVFbGVtZW50cyA9ICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRnZXRTY3JvbGxhYmxlRWxlbWVudHMoZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHJlc3RvcmVTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlRWxlbWVudHMpO1xuICAgIH1cbn1cbmxldCAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkc3VwcG9ydHNQcmV2ZW50U2Nyb2xsQ2FjaGVkID0gbnVsbDtcbmZ1bmN0aW9uICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGwoKSB7XG4gICAgaWYgKCQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPT0gbnVsbCkge1xuICAgICAgICAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkc3VwcG9ydHNQcmV2ZW50U2Nyb2xsQ2FjaGVkID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZm9jdXNFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGZvY3VzRWxlbS5mb2N1cyh7XG4gICAgICAgICAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwgKCkge1xuICAgICAgICAgICAgICAgICAgICAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkc3VwcG9ydHNQcmV2ZW50U2Nyb2xsQ2FjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWdub3JlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQ7XG59XG5mdW5jdGlvbiAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkZ2V0U2Nyb2xsYWJsZUVsZW1lbnRzKGVsZW1lbnQpIHtcbiAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHZhciBzY3JvbGxhYmxlRWxlbWVudHMgPSBbXTtcbiAgICB2YXIgcm9vdFNjcm9sbGluZ0VsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB3aGlsZShwYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBwYXJlbnQgIT09IHJvb3RTY3JvbGxpbmdFbGVtZW50KXtcbiAgICAgICAgaWYgKHBhcmVudC5vZmZzZXRIZWlnaHQgPCBwYXJlbnQuc2Nyb2xsSGVpZ2h0IHx8IHBhcmVudC5vZmZzZXRXaWR0aCA8IHBhcmVudC5zY3JvbGxXaWR0aCkgc2Nyb2xsYWJsZUVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgZWxlbWVudDogcGFyZW50LFxuICAgICAgICAgICAgc2Nyb2xsVG9wOiBwYXJlbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdDogcGFyZW50LnNjcm9sbExlZnRcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBpZiAocm9vdFNjcm9sbGluZ0VsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgc2Nyb2xsYWJsZUVsZW1lbnRzLnB1c2goe1xuICAgICAgICBlbGVtZW50OiByb290U2Nyb2xsaW5nRWxlbWVudCxcbiAgICAgICAgc2Nyb2xsVG9wOiByb290U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgIHNjcm9sbExlZnQ6IHJvb3RTY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnRcbiAgICB9KTtcbiAgICByZXR1cm4gc2Nyb2xsYWJsZUVsZW1lbnRzO1xufVxuZnVuY3Rpb24gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHJlc3RvcmVTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlRWxlbWVudHMpIHtcbiAgICBmb3IgKGxldCB7IGVsZW1lbnQ6IGVsZW1lbnQsIHNjcm9sbFRvcDogc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0IH0gb2Ygc2Nyb2xsYWJsZUVsZW1lbnRzKXtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkYWI3MWRhZGIwM2E2ZmIyZSRleHBvcnQkNjIyY2VhNDQ1YTFjNWI3ZChlbGVtZW50LCByZXZlcnNlLCBvcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgbGV0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChyZXZlcnNlKSByZXR1cm4gb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gcmVjdC5yaWdodCA6IHJlY3QuYm90dG9tO1xuICAgIHJldHVybiBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyByZWN0LmxlZnQgOiByZWN0LnRvcDtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0VXNlckFnZW50KHJlKSB7XG4gICAgdmFyIF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGE7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgd2luZG93Lm5hdmlnYXRvciA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICgoX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9IHdpbmRvdy5uYXZpZ2F0b3JbXCJ1c2VyQWdlbnREYXRhXCJdKSA9PT0gbnVsbCB8fCBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhLmJyYW5kcy5zb21lKChicmFuZCk9PnJlLnRlc3QoYnJhbmQuYnJhbmQpKSkgfHwgcmUudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFBsYXRmb3JtKHJlKSB7XG4gICAgdmFyIF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGE7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hdmlnYXRvciAhPSBudWxsID8gcmUudGVzdCgoKF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEgPSB3aW5kb3cubmF2aWdhdG9yW1widXNlckFnZW50RGF0YVwiXSkgPT09IG51bGwgfHwgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YS5wbGF0Zm9ybSkgfHwgd2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwKCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFBsYXRmb3JtKC9eTWFjL2kpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDE4NmM2OTY0Y2ExN2Q5OSgpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RQbGF0Zm9ybSgvXmlQaG9uZS9pKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0KCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFBsYXRmb3JtKC9eaVBhZC9pKSB8fCAvLyBpUGFkT1MgMTMgbGllcyBhbmQgc2F5cyBpdCdzIGEgTWFjLCBidXQgd2UgY2FuIGRpc3Rpbmd1aXNoIGJ5IGRldGVjdGluZyB0b3VjaCBzdXBwb3J0LlxuICAgICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwKCkgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRmZWRiMzY5Y2I3MDIwN2YxKCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkMTg2YzY5NjRjYTE3ZDk5KCkgfHwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDdiZWYwNDljZTkyZTQyMjQoKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRlMTg2NWMzYmVkY2Q4MjJiKCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCgpIHx8ICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRmZWRiMzY5Y2I3MDIwN2YxKCk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNzg1NTEwNDM1ODJhNmE5OCgpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQoL0FwcGxlV2ViS2l0L2kpICYmICEkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNjQ0NmExODZkMDllMzc5ZSgpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDY0NDZhMTg2ZDA5ZTM3OWUoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0VXNlckFnZW50KC9DaHJvbWUvaSk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCgpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQoL0FuZHJvaWQvaSk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYjdkNzg5OTNiNzRmNzY2ZCgpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQoL0ZpcmVmb3gvaSk7XG59XG5cblxuXG5cbmNvbnN0ICRlYThkY2JjYjllYTFiNTU2JHZhciRSb3V0ZXJDb250ZXh0ID0gLyojX19QVVJFX18qLyAoMCwgJDEydUdwJGNyZWF0ZUNvbnRleHQpKHtcbiAgICBpc05hdGl2ZTogdHJ1ZSxcbiAgICBvcGVuOiAkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkb3BlblN5bnRoZXRpY0xpbmtcbn0pO1xuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDMyM2U0ZmMyZmE0NzUzZmIocHJvcHMpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIG5hdmlnYXRlOiBuYXZpZ2F0ZSB9ID0gcHJvcHM7XG4gICAgbGV0IGN0eCA9ICgwLCAkMTJ1R3AkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBpc05hdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBvcGVuOiAodGFyZ2V0LCBtb2RpZmllcnMpPT57XG4gICAgICAgICAgICAgICAgJGVhOGRjYmNiOWVhMWI1NTYkdmFyJGdldFN5bnRoZXRpY0xpbmsodGFyZ2V0LCAobGluayk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCRlZmE4YzkwOTllNTMwMjM1KGxpbmssIG1vZGlmaWVycykpIG5hdmlnYXRlKGxpbmsucGF0aG5hbWUgKyBsaW5rLnNlYXJjaCArIGxpbmsuaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDk1MTg1ZDY5OWUwNWQ0ZDcobGluaywgbW9kaWZpZXJzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFtcbiAgICAgICAgbmF2aWdhdGVcbiAgICBdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDEydUdwJHJlYWN0KS5jcmVhdGVFbGVtZW50KCRlYThkY2JjYjllYTFiNTU2JHZhciRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBjdHhcbiAgICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOWEzMDJhNDVmNjVkMDU3MigpIHtcbiAgICByZXR1cm4gKDAsICQxMnVHcCR1c2VDb250ZXh0KSgkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkUm91dGVyQ29udGV4dCk7XG59XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkZWZhOGM5MDk5ZTUzMDIzNShsaW5rLCBtb2RpZmllcnMpIHtcbiAgICAvLyBVc2UgZ2V0QXR0cmlidXRlIGhlcmUgaW5zdGVhZCBvZiBsaW5rLnRhcmdldC4gRmlyZWZveCB3aWxsIGRlZmF1bHQgbGluay50YXJnZXQgdG8gXCJfcGFyZW50XCIgd2hlbiBpbnNpZGUgYW4gaWZyYW1lLlxuICAgIGxldCB0YXJnZXQgPSBsaW5rLmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcbiAgICByZXR1cm4gKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmIGxpbmsub3JpZ2luID09PSBsb2NhdGlvbi5vcmlnaW4gJiYgIWxpbmsuaGFzQXR0cmlidXRlKFwiZG93bmxvYWRcIikgJiYgIW1vZGlmaWVycy5tZXRhS2V5ICYmIC8vIG9wZW4gaW4gbmV3IHRhYiAobWFjKVxuICAgICFtb2RpZmllcnMuY3RybEtleSAmJiAvLyBvcGVuIGluIG5ldyB0YWIgKHdpbmRvd3MpXG4gICAgIW1vZGlmaWVycy5hbHRLZXkgJiYgLy8gZG93bmxvYWRcbiAgICAhbW9kaWZpZXJzLnNoaWZ0S2V5O1xufVxuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDk1MTg1ZDY5OWUwNWQ0ZDcodGFyZ2V0LCBtb2RpZmllcnMsIHNldE9wZW5pbmcgPSB0cnVlKSB7XG4gICAgdmFyIF93aW5kb3dfZXZlbnRfdHlwZSwgX3dpbmRvd19ldmVudDtcbiAgICBsZXQgeyBtZXRhS2V5OiBtZXRhS2V5LCBjdHJsS2V5OiBjdHJsS2V5LCBhbHRLZXk6IGFsdEtleSwgc2hpZnRLZXk6IHNoaWZ0S2V5IH0gPSBtb2RpZmllcnM7XG4gICAgLy8gRmlyZWZveCBkb2VzIG5vdCByZWNvZ25pemUga2V5Ym9hcmQgZXZlbnRzIGFzIGEgdXNlciBhY3Rpb24gYnkgZGVmYXVsdCwgYW5kIHRoZSBwb3B1cCBibG9ja2VyXG4gICAgLy8gd2lsbCBwcmV2ZW50IGxpbmtzIHdpdGggdGFyZ2V0PVwiX2JsYW5rXCIgZnJvbSBvcGVuaW5nLiBIb3dldmVyLCBpdCBkb2VzIGFsbG93IHRoZSBldmVudCBpZiB0aGVcbiAgICAvLyBDb21tYW5kL0NvbnRyb2wga2V5IGlzIGhlbGQsIHdoaWNoIG9wZW5zIHRoZSBsaW5rIGluIGEgYmFja2dyb3VuZCB0YWIuIFRoaXMgc2VlbXMgbGlrZSB0aGUgYmVzdCB3ZSBjYW4gZG8uXG4gICAgLy8gU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTI1Nzg3MCBhbmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzQ2NjQwLlxuICAgIGlmICgoMCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGI3ZDc4OTkzYjc0Zjc2NmQpKCkgJiYgKChfd2luZG93X2V2ZW50ID0gd2luZG93LmV2ZW50KSA9PT0gbnVsbCB8fCBfd2luZG93X2V2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3dpbmRvd19ldmVudF90eXBlID0gX3dpbmRvd19ldmVudC50eXBlKSA9PT0gbnVsbCB8fCBfd2luZG93X2V2ZW50X3R5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3dfZXZlbnRfdHlwZS5zdGFydHNXaXRoKFwia2V5XCIpKSAmJiB0YXJnZXQudGFyZ2V0ID09PSBcIl9ibGFua1wiKSB7XG4gICAgICAgIGlmICgoMCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTApKCkpIG1ldGFLZXkgPSB0cnVlO1xuICAgICAgICBlbHNlIGN0cmxLZXkgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBXZWJLaXQgZG9lcyBub3Qgc3VwcG9ydCBmaXJpbmcgY2xpY2sgZXZlbnRzIHdpdGggbW9kaWZpZXIga2V5cywgYnV0IGRvZXMgc3VwcG9ydCBrZXlib2FyZCBldmVudHMuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dlYktpdC9XZWJLaXQvYmxvYi9jMDNkMGFjNmU2ZGIxNzhmOTA5MjNhMGE2MzA4MGI1Y2EyMTBkMjVmL1NvdXJjZS9XZWJDb3JlL2h0bWwvSFRNTEFuY2hvckVsZW1lbnQuY3BwI0wxODRcbiAgICBsZXQgZXZlbnQgPSAoMCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDc4NTUxMDQzNTgyYTZhOTgpKCkgJiYgKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwKSgpICYmICEoMCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDdiZWYwNDljZTkyZTQyMjQpKCkgJiYgdHJ1ZSA/IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCB7XG4gICAgICAgIGtleUlkZW50aWZpZXI6IFwiRW50ZXJcIixcbiAgICAgICAgbWV0YUtleTogbWV0YUtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgYWx0S2V5OiBhbHRLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleVxuICAgIH0pIDogbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiLCB7XG4gICAgICAgIG1ldGFLZXk6IG1ldGFLZXksXG4gICAgICAgIGN0cmxLZXk6IGN0cmxLZXksXG4gICAgICAgIGFsdEtleTogYWx0S2V5LFxuICAgICAgICBzaGlmdEtleTogc2hpZnRLZXksXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgICAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNy5pc09wZW5pbmcgPSBzZXRPcGVuaW5nO1xuICAgICgwLCAkNzIxNWFmYzZkZTYwNmQ2YiRleHBvcnQkZGU3OWUyYzY5NWUwNTJmMykodGFyZ2V0KTtcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDk1MTg1ZDY5OWUwNWQ0ZDcuaXNPcGVuaW5nID0gZmFsc2U7XG59XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGFyY2VsLWJ1bmRsZXIvcGFyY2VsL2lzc3Vlcy84NzI0XG4kZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNy5pc09wZW5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JHZhciRnZXRTeW50aGV0aWNMaW5rKHRhcmdldCwgb3Blbikge1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCkgb3Blbih0YXJnZXQpO1xuICAgIGVsc2UgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWhyZWZcIikpIHtcbiAgICAgICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgbGluay5ocmVmID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtaHJlZlwiKTtcbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXRhcmdldFwiKSkgbGluay50YXJnZXQgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS10YXJnZXRcIik7XG4gICAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKFwiZGF0YS1yZWxcIikpIGxpbmsucmVsID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcmVsXCIpO1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtZG93bmxvYWRcIikpIGxpbmsuZG93bmxvYWQgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1kb3dubG9hZFwiKTtcbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXBpbmdcIikpIGxpbmsucGluZyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBpbmdcIik7XG4gICAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKFwiZGF0YS1yZWZlcnJlci1wb2xpY3lcIikpIGxpbmsucmVmZXJyZXJQb2xpY3kgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWZlcnJlci1wb2xpY3lcIik7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgb3BlbihsaW5rKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUNoaWxkKGxpbmspO1xuICAgIH1cbn1cbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JHZhciRvcGVuU3ludGhldGljTGluayh0YXJnZXQsIG1vZGlmaWVycykge1xuICAgICRlYThkY2JjYjllYTFiNTU2JHZhciRnZXRTeW50aGV0aWNMaW5rKHRhcmdldCwgKGxpbmspPT4kZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNyhsaW5rLCBtb2RpZmllcnMpKTtcbn1cbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ1MTQzN2Q1MDMzNzNkMjIzKHByb3BzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJkYXRhLWhyZWZcIjogcHJvcHMuaHJlZixcbiAgICAgICAgXCJkYXRhLXRhcmdldFwiOiBwcm9wcy50YXJnZXQsXG4gICAgICAgIFwiZGF0YS1yZWxcIjogcHJvcHMucmVsLFxuICAgICAgICBcImRhdGEtZG93bmxvYWRcIjogcHJvcHMuZG93bmxvYWQsXG4gICAgICAgIFwiZGF0YS1waW5nXCI6IHByb3BzLnBpbmcsXG4gICAgICAgIFwiZGF0YS1yZWZlcnJlci1wb2xpY3lcIjogcHJvcHMucmVmZXJyZXJQb2xpY3lcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBXZSBzdG9yZSBhIGdsb2JhbCBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgYXJlIGN1cnJlbnRseSB0cmFuc2l0aW9uaW5nLFxuLy8gbWFwcGVkIHRvIGEgc2V0IG9mIENTUyBwcm9wZXJ0aWVzIHRoYXQgYXJlIHRyYW5zaXRpb25pbmcgZm9yIHRoYXQgZWxlbWVudC5cbi8vIFRoaXMgaXMgbmVjZXNzYXJ5IHJhdGhlciB0aGFuIGEgc2ltcGxlIGNvdW50IG9mIHRyYW5zaXRpb25zIGJlY2F1c2Ugb2YgYnJvd3NlclxuLy8gYnVncywgZS5nLiBDaHJvbWUgc29tZXRpbWVzIGZpcmVzIGJvdGggdHJhbnNpdGlvbmVuZCBhbmQgdHJhbnNpdGlvbmNhbmNlbCByYXRoZXJcbi8vIHRoYW4gb25lIG9yIHRoZSBvdGhlci4gU28gd2UgbmVlZCB0byB0cmFjayB3aGF0J3MgYWN0dWFsbHkgdHJhbnNpdGlvbmluZyBzbyB0aGF0XG4vLyB3ZSBjYW4gaWdub3JlIHRoZXNlIGR1cGxpY2F0ZSBldmVudHMuXG5sZXQgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50ID0gbmV3IE1hcCgpO1xuLy8gQSBsaXN0IG9mIGNhbGxiYWNrcyB0byBjYWxsIG9uY2UgdGhlcmUgYXJlIG5vIHRyYW5zaXRpb25pbmcgZWxlbWVudHMuXG5sZXQgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25DYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiAkYmJlZDhiNDFmODU3YmNjMCR2YXIkc2V0dXBHbG9iYWxFdmVudHMoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICBsZXQgb25UcmFuc2l0aW9uU3RhcnQgPSAoZSk9PntcbiAgICAgICAgLy8gQWRkIHRoZSB0cmFuc2l0aW9uaW5nIHByb3BlcnR5IHRvIHRoZSBsaXN0IGZvciB0aGlzIGVsZW1lbnQuXG4gICAgICAgIGxldCB0cmFuc2l0aW9ucyA9ICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5nZXQoZS50YXJnZXQpO1xuICAgICAgICBpZiAoIXRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5zZXQoZS50YXJnZXQsIHRyYW5zaXRpb25zKTtcbiAgICAgICAgICAgIC8vIFRoZSB0cmFuc2l0aW9uY2FuY2VsIGV2ZW50IG11c3QgYmUgcmVnaXN0ZXJlZCBvbiB0aGUgZWxlbWVudCBpdHNlbGYsIHJhdGhlciB0aGFuIGFzIGEgZ2xvYmFsXG4gICAgICAgICAgICAvLyBldmVudC4gVGhpcyBlbmFibGVzIHVzIHRvIGhhbmRsZSB3aGVuIHRoZSBub2RlIGlzIGRlbGV0ZWQgZnJvbSB0aGUgZG9jdW1lbnQgd2hpbGUgaXQgaXMgdHJhbnNpdGlvbmluZy5cbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlIGNhbmNlbCBldmVudCB3b3VsZCBoYXZlIG5vd2hlcmUgdG8gYnViYmxlIHRvIHNvIHdlIG5lZWQgdG8gaGFuZGxlIGl0IGRpcmVjdGx5LlxuICAgICAgICAgICAgZS50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25jYW5jZWxcIiwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2l0aW9ucy5hZGQoZS5wcm9wZXJ0eU5hbWUpO1xuICAgIH07XG4gICAgbGV0IG9uVHJhbnNpdGlvbkVuZCA9IChlKT0+e1xuICAgICAgICAvLyBSZW1vdmUgcHJvcGVydHkgZnJvbSBsaXN0IG9mIHRyYW5zaXRpb25pbmcgcHJvcGVydGllcy5cbiAgICAgICAgbGV0IHByb3BlcnRpZXMgPSAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQuZ2V0KGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSByZXR1cm47XG4gICAgICAgIHByb3BlcnRpZXMuZGVsZXRlKGUucHJvcGVydHlOYW1lKTtcbiAgICAgICAgLy8gSWYgZW1wdHksIHJlbW92ZSB0cmFuc2l0aW9uY2FuY2VsIGV2ZW50LCBhbmQgcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIGxpc3Qgb2YgdHJhbnNpdGlvbmluZyBlbGVtZW50cy5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgZS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25jYW5jZWxcIiwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5kZWxldGUoZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHRyYW5zaXRpb25pbmcgZWxlbWVudHMsIGNhbGwgYWxsIG9mIHRoZSBxdWV1ZWQgY2FsbGJhY2tzLlxuICAgICAgICBpZiAoJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNiIG9mICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uQ2FsbGJhY2tzKWNiKCk7XG4gICAgICAgICAgICAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbkNhbGxiYWNrcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9ucnVuXCIsIG9uVHJhbnNpdGlvblN0YXJ0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIG9uVHJhbnNpdGlvbkVuZCk7XG59XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiKSAkYmJlZDhiNDFmODU3YmNjMCR2YXIkc2V0dXBHbG9iYWxFdmVudHMoKTtcbiAgICBlbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICRiYmVkOGI0MWY4NTdiY2MwJHZhciRzZXR1cEdsb2JhbEV2ZW50cyk7XG59XG5mdW5jdGlvbiAkYmJlZDhiNDFmODU3YmNjMCRleHBvcnQkMjQ0OTAzMTZmNzY0YzQzMChmbikge1xuICAgIC8vIFdhaXQgb25lIGZyYW1lIHRvIHNlZSBpZiBhbiBhbmltYXRpb24gc3RhcnRzLCBlLmcuIGEgdHJhbnNpdGlvbiBvbiBtb3VudC5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgLy8gSWYgbm8gdHJhbnNpdGlvbnMgYXJlIHJ1bm5pbmcsIGNhbGwgdGhlIGZ1bmN0aW9uIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBPdGhlcndpc2UsIGFkZCBpdCB0byBhIGxpc3Qgb2YgY2FsbGJhY2tzIHRvIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICAgIGlmICgkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQuc2l6ZSA9PT0gMCkgZm4oKTtcbiAgICAgICAgZWxzZSAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbkNhbGxiYWNrcy5hZGQoZm4pO1xuICAgIH0pO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKiBlc2xpbnQtZGlzYWJsZSBydWxlc2Rpci9wdXJlLXJlbmRlciAqLyBcblxuLy8gS2VlcCB0cmFjayBvZiBlbGVtZW50cyB0aGF0IHdlIGFyZSBjdXJyZW50bHkgaGFuZGxpbmcgZHJhZ2dpbmcgZm9yIHZpYSB1c2VEcmFnMUQuXG4vLyBJZiB0aGVyZSdzIGFuIGFuY2VzdG9yIGFuZCBhIGRlc2NlbmRhbnQgYm90aCB1c2luZyB1c2VEcmFnMUQoKSwgYW5kIHRoZSB1c2VyIHN0YXJ0c1xuLy8gZHJhZ2dpbmcgdGhlIGRlc2NlbmRhbnQsIHdlIGRvbid0IHdhbnQgdXNlRHJhZzFEIGV2ZW50cyB0byBmaXJlIGZvciB0aGUgYW5jZXN0b3IuXG5jb25zdCAkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cyA9IFtdO1xuZnVuY3Rpb24gJDljYzA5ZGY5ZmQ3Njc2YmUkZXhwb3J0JDdiYmVkNzVmZWJhMzk3MDYocHJvcHMpIHtcbiAgICBjb25zb2xlLndhcm4oXCJ1c2VEcmFnMUQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBgdXNlTW92ZWAgaW5zdGVhZCBodHRwczovL3JlYWN0LXNwZWN0cnVtLmFkb2JlLmNvbS9yZWFjdC1hcmlhL3VzZU1vdmUuaHRtbFwiKTtcbiAgICBsZXQgeyBjb250YWluZXJSZWY6IGNvbnRhaW5lclJlZiwgcmV2ZXJzZTogcmV2ZXJzZSwgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLCBvbkhvdmVyOiBvbkhvdmVyLCBvbkRyYWc6IG9uRHJhZywgb25Qb3NpdGlvbkNoYW5nZTogb25Qb3NpdGlvbkNoYW5nZSwgb25JbmNyZW1lbnQ6IG9uSW5jcmVtZW50LCBvbkRlY3JlbWVudDogb25EZWNyZW1lbnQsIG9uSW5jcmVtZW50VG9NYXg6IG9uSW5jcmVtZW50VG9NYXgsIG9uRGVjcmVtZW50VG9NaW46IG9uRGVjcmVtZW50VG9NaW4sIG9uQ29sbGFwc2VUb2dnbGU6IG9uQ29sbGFwc2VUb2dnbGUgfSA9IHByb3BzO1xuICAgIGxldCBnZXRQb3NpdGlvbiA9IChlKT0+b3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gZS5jbGllbnRYIDogZS5jbGllbnRZO1xuICAgIGxldCBnZXROZXh0T2Zmc2V0ID0gKGUpPT57XG4gICAgICAgIGxldCBjb250YWluZXJPZmZzZXQgPSAoMCwgJGFiNzFkYWRiMDNhNmZiMmUkZXhwb3J0JDYyMmNlYTQ0NWExYzViN2QpKGNvbnRhaW5lclJlZi5jdXJyZW50LCByZXZlcnNlLCBvcmllbnRhdGlvbik7XG4gICAgICAgIGxldCBtb3VzZU9mZnNldCA9IGdldFBvc2l0aW9uKGUpO1xuICAgICAgICBsZXQgbmV4dE9mZnNldCA9IHJldmVyc2UgPyBjb250YWluZXJPZmZzZXQgLSBtb3VzZU9mZnNldCA6IG1vdXNlT2Zmc2V0IC0gY29udGFpbmVyT2Zmc2V0O1xuICAgICAgICByZXR1cm4gbmV4dE9mZnNldDtcbiAgICB9O1xuICAgIGxldCBkcmFnZ2luZyA9ICgwLCAkMTJ1R3AkdXNlUmVmKShmYWxzZSk7XG4gICAgbGV0IHByZXZQb3NpdGlvbiA9ICgwLCAkMTJ1R3AkdXNlUmVmKSgwKTtcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IGhhbmRsZXJzIGluIGEgcmVmIHNvIHRoYXQgdGhlIGV2ZW50cyBjYW4gYWNjZXNzIHRoZW0uXG4gICAgbGV0IGhhbmRsZXJzID0gKDAsICQxMnVHcCR1c2VSZWYpKHtcbiAgICAgICAgb25Qb3NpdGlvbkNoYW5nZTogb25Qb3NpdGlvbkNoYW5nZSxcbiAgICAgICAgb25EcmFnOiBvbkRyYWdcbiAgICB9KTtcbiAgICBoYW5kbGVycy5jdXJyZW50Lm9uRHJhZyA9IG9uRHJhZztcbiAgICBoYW5kbGVycy5jdXJyZW50Lm9uUG9zaXRpb25DaGFuZ2UgPSBvblBvc2l0aW9uQ2hhbmdlO1xuICAgIGxldCBvbk1vdXNlRHJhZ2dlZCA9IChlKT0+e1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBuZXh0T2Zmc2V0ID0gZ2V0TmV4dE9mZnNldChlKTtcbiAgICAgICAgaWYgKCFkcmFnZ2luZy5jdXJyZW50KSB7XG4gICAgICAgICAgICBkcmFnZ2luZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycy5jdXJyZW50Lm9uRHJhZykgaGFuZGxlcnMuY3VycmVudC5vbkRyYWcodHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMuY3VycmVudC5vblBvc2l0aW9uQ2hhbmdlKSBoYW5kbGVycy5jdXJyZW50Lm9uUG9zaXRpb25DaGFuZ2UobmV4dE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZQb3NpdGlvbi5jdXJyZW50ID09PSBuZXh0T2Zmc2V0KSByZXR1cm47XG4gICAgICAgIHByZXZQb3NpdGlvbi5jdXJyZW50ID0gbmV4dE9mZnNldDtcbiAgICAgICAgaWYgKG9uUG9zaXRpb25DaGFuZ2UpIG9uUG9zaXRpb25DaGFuZ2UobmV4dE9mZnNldCk7XG4gICAgfTtcbiAgICBsZXQgb25Nb3VzZVVwID0gKGUpPT57XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBkcmFnZ2luZy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCBuZXh0T2Zmc2V0ID0gZ2V0TmV4dE9mZnNldChlKTtcbiAgICAgICAgaWYgKGhhbmRsZXJzLmN1cnJlbnQub25EcmFnKSBoYW5kbGVycy5jdXJyZW50Lm9uRHJhZyhmYWxzZSk7XG4gICAgICAgIGlmIChoYW5kbGVycy5jdXJyZW50Lm9uUG9zaXRpb25DaGFuZ2UpIGhhbmRsZXJzLmN1cnJlbnQub25Qb3NpdGlvbkNoYW5nZShuZXh0T2Zmc2V0KTtcbiAgICAgICAgJDljYzA5ZGY5ZmQ3Njc2YmUkdmFyJGRyYWdnaW5nRWxlbWVudHMuc3BsaWNlKCQ5Y2MwOWRmOWZkNzY3NmJlJHZhciRkcmFnZ2luZ0VsZW1lbnRzLmluZGV4T2YodGFyZ2V0KSwgMSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZURyYWdnZWQsIGZhbHNlKTtcbiAgICB9O1xuICAgIGxldCBvbk1vdXNlRG93biA9IChlKT0+e1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgaGFuZGxpbmcgZHJhZ2dpbmcgb24gYSBkZXNjZW5kYW50IHdpdGggdXNlRHJhZzFELCB0aGVuXG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gaGFuZGxlIHRoZSBkcmFnIG1vdGlvbiBvbiB0aGlzIHRhcmdldCBhcyB3ZWxsLlxuICAgICAgICBpZiAoJDljYzA5ZGY5ZmQ3Njc2YmUkdmFyJGRyYWdnaW5nRWxlbWVudHMuc29tZSgoZWx0KT0+dGFyZ2V0LmNvbnRhaW5zKGVsdCkpKSByZXR1cm47XG4gICAgICAgICQ5Y2MwOWRmOWZkNzY3NmJlJHZhciRkcmFnZ2luZ0VsZW1lbnRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZURyYWdnZWQsIGZhbHNlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgIH07XG4gICAgbGV0IG9uTW91c2VFbnRlciA9ICgpPT57XG4gICAgICAgIGlmIChvbkhvdmVyKSBvbkhvdmVyKHRydWUpO1xuICAgIH07XG4gICAgbGV0IG9uTW91c2VPdXQgPSAoKT0+e1xuICAgICAgICBpZiAob25Ib3Zlcikgb25Ib3ZlcihmYWxzZSk7XG4gICAgfTtcbiAgICBsZXQgb25LZXlEb3duID0gKGUpPT57XG4gICAgICAgIHN3aXRjaChlLmtleSl7XG4gICAgICAgICAgICBjYXNlIFwiTGVmdFwiOlxuICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25EZWNyZW1lbnQgJiYgIXJldmVyc2UpIG9uRGVjcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uSW5jcmVtZW50ICYmIHJldmVyc2UpIG9uSW5jcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlVwXCI6XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRGVjcmVtZW50ICYmICFyZXZlcnNlKSBvbkRlY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbkluY3JlbWVudCAmJiByZXZlcnNlKSBvbkluY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSaWdodFwiOlxuICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uSW5jcmVtZW50ICYmICFyZXZlcnNlKSBvbkluY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbkRlY3JlbWVudCAmJiByZXZlcnNlKSBvbkRlY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJEb3duXCI6XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25JbmNyZW1lbnQgJiYgIXJldmVyc2UpIG9uSW5jcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uRGVjcmVtZW50ICYmIHJldmVyc2UpIG9uRGVjcmVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uRGVjcmVtZW50VG9NaW4pIG9uRGVjcmVtZW50VG9NaW4oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJFbmRcIjpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uSW5jcmVtZW50VG9NYXgpIG9uSW5jcmVtZW50VG9NYXgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAob25Db2xsYXBzZVRvZ2dsZSkgb25Db2xsYXBzZVRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sXG4gICAgICAgIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLFxuICAgICAgICBvbk1vdXNlT3V0OiBvbk1vdXNlT3V0LFxuICAgICAgICBvbktleURvd246IG9uS2V5RG93blxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDAzZGViMjNmZjE0OTIwYzQkZXhwb3J0JDRlYWYwNGU1NGFhOGVlZDYoKSB7XG4gICAgbGV0IGdsb2JhbExpc3RlbmVycyA9ICgwLCAkMTJ1R3AkdXNlUmVmKShuZXcgTWFwKCkpO1xuICAgIGxldCBhZGRHbG9iYWxMaXN0ZW5lciA9ICgwLCAkMTJ1R3AkdXNlQ2FsbGJhY2spKChldmVudFRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpPT57XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSByZW1vdmUgdGhlIGxpc3RlbmVyIGFmdGVyIGl0IGlzIGNhbGxlZCB3aXRoIHRoZSBgb25jZWAgb3B0aW9uLlxuICAgICAgICBsZXQgZm4gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uY2UpID8gKC4uLmFyZ3MpPT57XG4gICAgICAgICAgICBnbG9iYWxMaXN0ZW5lcnMuY3VycmVudC5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICAgICAgbGlzdGVuZXIoLi4uYXJncyk7XG4gICAgICAgIH0gOiBsaXN0ZW5lcjtcbiAgICAgICAgZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuc2V0KGxpc3RlbmVyLCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZXZlbnRUYXJnZXQ6IGV2ZW50VGFyZ2V0LFxuICAgICAgICAgICAgZm46IGZuLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfSwgW10pO1xuICAgIGxldCByZW1vdmVHbG9iYWxMaXN0ZW5lciA9ICgwLCAkMTJ1R3AkdXNlQ2FsbGJhY2spKChldmVudFRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpPT57XG4gICAgICAgIHZhciBfZ2xvYmFsTGlzdGVuZXJzX2N1cnJlbnRfZ2V0O1xuICAgICAgICBsZXQgZm4gPSAoKF9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQgPSBnbG9iYWxMaXN0ZW5lcnMuY3VycmVudC5nZXQobGlzdGVuZXIpKSA9PT0gbnVsbCB8fCBfZ2xvYmFsTGlzdGVuZXJzX2N1cnJlbnRfZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2xvYmFsTGlzdGVuZXJzX2N1cnJlbnRfZ2V0LmZuKSB8fCBsaXN0ZW5lcjtcbiAgICAgICAgZXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9ucyk7XG4gICAgICAgIGdsb2JhbExpc3RlbmVycy5jdXJyZW50LmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfSwgW10pO1xuICAgIGxldCByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMgPSAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBnbG9iYWxMaXN0ZW5lcnMuY3VycmVudC5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xuICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIodmFsdWUuZXZlbnRUYXJnZXQsIHZhbHVlLnR5cGUsIGtleSwgdmFsdWUub3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXJcbiAgICBdKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICByZXR1cm4gcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzO1xuICAgIH0sIFtcbiAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXI6IGFkZEdsb2JhbExpc3RlbmVyLFxuICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcjogcmVtb3ZlR2xvYmFsTGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyczogcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzXG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMzEzYjk4ODYxZWU1ZGQ2YyRleHBvcnQkZDY4NzUxMjIxOTRjN2I0NChwcm9wcywgZGVmYXVsdExhYmVsKSB7XG4gICAgbGV0IHsgaWQ6IGlkLCBcImFyaWEtbGFiZWxcIjogbGFiZWwsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnkgfSA9IHByb3BzO1xuICAgIC8vIElmIHRoZXJlIGlzIGJvdGggYW4gYXJpYS1sYWJlbCBhbmQgYXJpYS1sYWJlbGxlZGJ5LFxuICAgIC8vIGNvbWJpbmUgdGhlbSBieSBwb2ludGluZyB0byB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgaWQgPSAoMCwgJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGY2ODA4NzdhMzQ3MTFlMzcpKGlkKTtcbiAgICBpZiAobGFiZWxsZWRCeSAmJiBsYWJlbCkge1xuICAgICAgICBsZXQgaWRzID0gbmV3IFNldChbXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIC4uLmxhYmVsbGVkQnkudHJpbSgpLnNwbGl0KC9cXHMrLylcbiAgICAgICAgXSk7XG4gICAgICAgIGxhYmVsbGVkQnkgPSBbXG4gICAgICAgICAgICAuLi5pZHNcbiAgICAgICAgXS5qb2luKFwiIFwiKTtcbiAgICB9IGVsc2UgaWYgKGxhYmVsbGVkQnkpIGxhYmVsbGVkQnkgPSBsYWJlbGxlZEJ5LnRyaW0oKS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIgXCIpO1xuICAgIC8vIElmIG5vIGxhYmVscyBhcmUgcHJvdmlkZWQsIHVzZSB0aGUgZGVmYXVsdFxuICAgIGlmICghbGFiZWwgJiYgIWxhYmVsbGVkQnkgJiYgZGVmYXVsdExhYmVsKSBsYWJlbCA9IGRlZmF1bHRMYWJlbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBsYWJlbCxcbiAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRCeVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIxIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJGRmNTYxNjRkZmY1Nzg1ZTIkZXhwb3J0JDQzMzhiNTMzMTVhYmY2NjYoZm9yd2FyZGVkUmVmKSB7XG4gICAgY29uc3Qgb2JqUmVmID0gKDAsICQxMnVHcCR1c2VSZWYpKCk7XG4gICAgcmV0dXJuICgwLCAkMTJ1R3AkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBnZXQgY3VycmVudCAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialJlZi5jdXJyZW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBjdXJyZW50ICh2YWx1ZSl7XG4gICAgICAgICAgICAgICAgb2JqUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gXCJmdW5jdGlvblwiKSBmb3J3YXJkZWRSZWYodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcndhcmRlZFJlZikgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFtcbiAgICAgICAgZm9yd2FyZGVkUmVmXG4gICAgXSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDRmNThjNWY3MmJjZjc5ZjckZXhwb3J0JDQ5NjMxNWExNjA4ZDk2MDIoZWZmZWN0LCBkZXBlbmRlbmNpZXMpIHtcbiAgICBjb25zdCBpc0luaXRpYWxNb3VudCA9ICgwLCAkMTJ1R3AkdXNlUmVmKSh0cnVlKTtcbiAgICBjb25zdCBsYXN0RGVwcyA9ICgwLCAkMTJ1R3AkdXNlUmVmKShudWxsKTtcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaXNJbml0aWFsTW91bnQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaXNJbml0aWFsTW91bnQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGlzSW5pdGlhbE1vdW50LmN1cnJlbnQpIGlzSW5pdGlhbE1vdW50LmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoIWxhc3REZXBzLmN1cnJlbnQgfHwgZGVwZW5kZW5jaWVzLnNvbWUoKGRlcCwgaSk9PiFPYmplY3QuaXMoZGVwLCBsYXN0RGVwc1tpXSkpKSBlZmZlY3QoKTtcbiAgICAgICAgbGFzdERlcHMuY3VycmVudCA9IGRlcGVuZGVuY2llcztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgZGVwZW5kZW5jaWVzKTtcbn1cblxuXG5cblxuZnVuY3Rpb24gJDlkYWFiMDJkNDYxODA5ZGIkdmFyJGhhc1Jlc2l6ZU9ic2VydmVyKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93LlJlc2l6ZU9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gJDlkYWFiMDJkNDYxODA5ZGIkZXhwb3J0JDY4MzQ4MGYxOTFjMGUzZWEob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcmVmOiByZWYsIG9uUmVzaXplOiBvblJlc2l6ZSB9ID0gb3B0aW9ucztcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IGVsZW1lbnQgPSByZWYgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG4gICAgICAgIGlmICghJDlkYWFiMDJkNDYxODA5ZGIkdmFyJGhhc1Jlc2l6ZU9ic2VydmVyKCkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVySW5zdGFuY2UgPSBuZXcgd2luZG93LlJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZW50cmllcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICAgICAgICBvblJlc2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlckluc3RhbmNlLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkgcmVzaXplT2JzZXJ2ZXJJbnN0YW5jZS51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBvblJlc2l6ZSxcbiAgICAgICAgcmVmXG4gICAgXSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJGU3ODAxYmU4MmI0YjJhNTMkZXhwb3J0JDRkZWJkYjFhM2YwZmE3OWUoY29udGV4dCwgcmVmKSB7XG4gICAgKDAsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjKSgoKT0+e1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LnJlZiAmJiByZWYpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVmLmN1cnJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkY2ZhMjIyNWU4NzkzODc4MShub2RlLCBjaGVja0Zvck92ZXJmbG93KSB7XG4gICAgaWYgKCQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmKG5vZGUsIGNoZWNrRm9yT3ZlcmZsb3cpKSBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHdoaWxlKG5vZGUgJiYgISQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmKG5vZGUsIGNoZWNrRm9yT3ZlcmZsb3cpKW5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIG5vZGUgfHwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiAkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkMmJiNzQ3NDBjNGUxOWRlZihub2RlLCBjaGVja0Zvck92ZXJmbG93KSB7XG4gICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgbGV0IGlzU2Nyb2xsYWJsZSA9IC8oYXV0b3xzY3JvbGwpLy50ZXN0KHN0eWxlLm92ZXJmbG93ICsgc3R5bGUub3ZlcmZsb3dYICsgc3R5bGUub3ZlcmZsb3dZKTtcbiAgICBpZiAoaXNTY3JvbGxhYmxlICYmIGNoZWNrRm9yT3ZlcmZsb3cpIGlzU2Nyb2xsYWJsZSA9IG5vZGUuc2Nyb2xsSGVpZ2h0ICE9PSBub2RlLmNsaWVudEhlaWdodCB8fCBub2RlLnNjcm9sbFdpZHRoICE9PSBub2RlLmNsaWVudFdpZHRoO1xuICAgIHJldHVybiBpc1Njcm9sbGFibGU7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG4vLyBAdHMtaWdub3JlXG5sZXQgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcbmZ1bmN0aW9uICQ1ZGY2NGIzODA3ZGMxNWVlJGV4cG9ydCRkNjk5OTA1ZGQ1N2M3M2NhKCkge1xuICAgIGxldCBpc1NTUiA9ICgwLCAkMTJ1R3AkdXNlSXNTU1IpKCk7XG4gICAgbGV0IFtzaXplLCBzZXRTaXplXSA9ICgwLCAkMTJ1R3AkdXNlU3RhdGUpKCgpPT5pc1NTUiA/IHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0gOiAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkZ2V0Vmlld3BvcnRTaXplKCkpO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICAvLyBVc2UgdmlzdWFsVmlld3BvcnQgYXBpIHRvIHRyYWNrIGF2YWlsYWJsZSBoZWlnaHQgZXZlbiBvbiBpT1MgdmlydHVhbCBrZXlib2FyZCBvcGVuaW5nXG4gICAgICAgIGxldCBvblJlc2l6ZSA9ICgpPT57XG4gICAgICAgICAgICBzZXRTaXplKChzaXplKT0+e1xuICAgICAgICAgICAgICAgIGxldCBuZXdTaXplID0gJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJGdldFZpZXdwb3J0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTaXplLndpZHRoID09PSBzaXplLndpZHRoICYmIG5ld1NpemUuaGVpZ2h0ID09PSBzaXplLmhlaWdodCkgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NpemU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCEkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplKTtcbiAgICAgICAgZWxzZSAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKCEkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQpIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplKTtcbiAgICAgICAgICAgIGVsc2UgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciRnZXRWaWV3cG9ydFNpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6ICgkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQud2lkdGgpIHx8IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6ICgkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQuaGVpZ2h0KSB8fCB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxubGV0ICRlZjA2MjU2MDc5Njg2YmEwJHZhciRkZXNjcmlwdGlvbklkID0gMDtcbmNvbnN0ICRlZjA2MjU2MDc5Njg2YmEwJHZhciRkZXNjcmlwdGlvbk5vZGVzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gJGVmMDYyNTYwNzk2ODZiYTAkZXhwb3J0JGY4YWVkYTdiMTA3NTNmYTEoZGVzY3JpcHRpb24pIHtcbiAgICBsZXQgW2lkLCBzZXRJZF0gPSAoMCwgJDEydUdwJHVzZVN0YXRlKSh1bmRlZmluZWQpO1xuICAgICgwLCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYykoKCk9PntcbiAgICAgICAgaWYgKCFkZXNjcmlwdGlvbikgcmV0dXJuO1xuICAgICAgICBsZXQgZGVzYyA9ICRlZjA2MjU2MDc5Njg2YmEwJHZhciRkZXNjcmlwdGlvbk5vZGVzLmdldChkZXNjcmlwdGlvbik7XG4gICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgbGV0IGlkID0gYHJlYWN0LWFyaWEtZGVzY3JpcHRpb24tJHskZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25JZCsrfWA7XG4gICAgICAgICAgICBzZXRJZChpZCk7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBub2RlLmlkID0gaWQ7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIHJlZkNvdW50OiAwLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5vZGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25Ob2Rlcy5zZXQoZGVzY3JpcHRpb24sIGRlc2MpO1xuICAgICAgICB9IGVsc2Ugc2V0SWQoZGVzYy5lbGVtZW50LmlkKTtcbiAgICAgICAgZGVzYy5yZWZDb3VudCsrO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmICgtLWRlc2MucmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZXNjLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgJGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uTm9kZXMuZGVsZXRlKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGRlc2NyaXB0aW9uXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGRlc2NyaXB0aW9uID8gaWQgOiB1bmRlZmluZWRcbiAgICB9O1xufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIxIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkZTlmYWFmYjY0MWUxNjdkYiRleHBvcnQkOTBmYzNhMTdkOTNmNzA0YyhyZWYsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGhhbmRsZUV2ZW50ID0gKDAsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKShoYW5kbGVyKTtcbiAgICBsZXQgaXNEaXNhYmxlZCA9IGhhbmRsZXIgPT0gbnVsbDtcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVFdmVudCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVFdmVudCwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByZWYsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICBoYW5kbGVFdmVudFxuICAgIF0pO1xufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDJmMDRjYmM0NGVlMzBjZTAkZXhwb3J0JDUzYTA5MTBmMDM4MzM3YmQoc2Nyb2xsVmlldywgZWxlbWVudCkge1xuICAgIGxldCBvZmZzZXRYID0gJDJmMDRjYmM0NGVlMzBjZTAkdmFyJHJlbGF0aXZlT2Zmc2V0KHNjcm9sbFZpZXcsIGVsZW1lbnQsIFwibGVmdFwiKTtcbiAgICBsZXQgb2Zmc2V0WSA9ICQyZjA0Y2JjNDRlZTMwY2UwJHZhciRyZWxhdGl2ZU9mZnNldChzY3JvbGxWaWV3LCBlbGVtZW50LCBcInRvcFwiKTtcbiAgICBsZXQgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIGxldCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICBsZXQgeCA9IHNjcm9sbFZpZXcuc2Nyb2xsTGVmdDtcbiAgICBsZXQgeSA9IHNjcm9sbFZpZXcuc2Nyb2xsVG9wO1xuICAgIC8vIEFjY291bnQgZm9yIHRvcC9sZWZ0IGJvcmRlciBvZmZzZXR0aW5nIHRoZSBzY3JvbGwgdG9wL0xlZnRcbiAgICBsZXQgeyBib3JkZXJUb3BXaWR0aDogYm9yZGVyVG9wV2lkdGgsIGJvcmRlckxlZnRXaWR0aDogYm9yZGVyTGVmdFdpZHRoIH0gPSBnZXRDb21wdXRlZFN0eWxlKHNjcm9sbFZpZXcpO1xuICAgIGxldCBib3JkZXJBZGp1c3RlZFggPSBzY3JvbGxWaWV3LnNjcm9sbExlZnQgKyBwYXJzZUludChib3JkZXJMZWZ0V2lkdGgsIDEwKTtcbiAgICBsZXQgYm9yZGVyQWRqdXN0ZWRZID0gc2Nyb2xsVmlldy5zY3JvbGxUb3AgKyBwYXJzZUludChib3JkZXJUb3BXaWR0aCwgMTApO1xuICAgIC8vIElnbm9yZSBlbmQvYm90dG9tIGJvcmRlciB2aWEgY2xpZW50SGVpZ2h0L1dpZHRoIGluc3RlYWQgb2Ygb2Zmc2V0SGVpZ2h0L1dpZHRoXG4gICAgbGV0IG1heFggPSBib3JkZXJBZGp1c3RlZFggKyBzY3JvbGxWaWV3LmNsaWVudFdpZHRoO1xuICAgIGxldCBtYXhZID0gYm9yZGVyQWRqdXN0ZWRZICsgc2Nyb2xsVmlldy5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKG9mZnNldFggPD0geCkgeCA9IG9mZnNldFggLSBwYXJzZUludChib3JkZXJMZWZ0V2lkdGgsIDEwKTtcbiAgICBlbHNlIGlmIChvZmZzZXRYICsgd2lkdGggPiBtYXhYKSB4ICs9IG9mZnNldFggKyB3aWR0aCAtIG1heFg7XG4gICAgaWYgKG9mZnNldFkgPD0gYm9yZGVyQWRqdXN0ZWRZKSB5ID0gb2Zmc2V0WSAtIHBhcnNlSW50KGJvcmRlclRvcFdpZHRoLCAxMCk7XG4gICAgZWxzZSBpZiAob2Zmc2V0WSArIGhlaWdodCA+IG1heFkpIHkgKz0gb2Zmc2V0WSArIGhlaWdodCAtIG1heFk7XG4gICAgc2Nyb2xsVmlldy5zY3JvbGxMZWZ0ID0geDtcbiAgICBzY3JvbGxWaWV3LnNjcm9sbFRvcCA9IHk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBvZmZzZXQgbGVmdCBvciB0b3AgZnJvbSBjaGlsZCB0byBhbmNlc3RvciBieSBhY2N1bXVsYXRpbmdcbiAqIG9mZnNldExlZnQgb3Igb2Zmc2V0VG9wIHRocm91Z2ggaW50ZXJ2ZW5pbmcgb2Zmc2V0UGFyZW50cy5cbiAqLyBmdW5jdGlvbiAkMmYwNGNiYzQ0ZWUzMGNlMCR2YXIkcmVsYXRpdmVPZmZzZXQoYW5jZXN0b3IsIGNoaWxkLCBheGlzKSB7XG4gICAgY29uc3QgcHJvcCA9IGF4aXMgPT09IFwibGVmdFwiID8gXCJvZmZzZXRMZWZ0XCIgOiBcIm9mZnNldFRvcFwiO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIHdoaWxlKGNoaWxkLm9mZnNldFBhcmVudCl7XG4gICAgICAgIHN1bSArPSBjaGlsZFtwcm9wXTtcbiAgICAgICAgaWYgKGNoaWxkLm9mZnNldFBhcmVudCA9PT0gYW5jZXN0b3IpIGJyZWFrO1xuICAgICAgICBlbHNlIGlmIChjaGlsZC5vZmZzZXRQYXJlbnQuY29udGFpbnMoYW5jZXN0b3IpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYW5jZXN0b3IgaXMgbm90IGBwb3NpdGlvbjpyZWxhdGl2ZWAsIHRoZW4gd2Ugc3RvcCBhdFxuICAgICAgICAgICAgLy8gX2l0c18gb2Zmc2V0IHBhcmVudCwgYW5kIHdlIHN1YnRyYWN0IG9mZiBfaXRzXyBvZmZzZXQsIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIHdlIGVuZCB1cCB3aXRoIHRoZSBwcm9wZXIgb2Zmc2V0IGZyb20gY2hpbGQgdG8gYW5jZXN0b3IuXG4gICAgICAgICAgICBzdW0gLT0gYW5jZXN0b3JbcHJvcF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLm9mZnNldFBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbmZ1bmN0aW9uICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCRjODI2ODYwNzk2MzA5ZDFiKHRhcmdldEVsZW1lbnQsIG9wdHMpIHtcbiAgICBpZiAoZG9jdW1lbnQuY29udGFpbnModGFyZ2V0RWxlbWVudCkpIHtcbiAgICAgICAgbGV0IHJvb3QgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgbGV0IGlzU2Nyb2xsUHJldmVudGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocm9vdCkub3ZlcmZsb3cgPT09IFwiaGlkZGVuXCI7XG4gICAgICAgIC8vIElmIHNjcm9sbGluZyBpcyBub3QgY3VycmVudGx5IHByZXZlbnRlZCB0aGVuIHdlIGFyZW7igJl0IGluIGEgb3ZlcmxheSBub3IgaXMgYSBvdmVybGF5IG9wZW4sIGp1c3QgdXNlIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcgdG8gYnJpbmcgdGhlIGVsZW1lbnQgaW50byB2aWV3XG4gICAgICAgIGlmICghaXNTY3JvbGxQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHZhciAvLyB1c2Ugc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiAnbmVhcmVzdCd9KSBpbnN0ZWFkIG9mIC5mb2N1cyB0byBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyBmdWxseSBpbiB2aWV3IG9yIG5vdCBzaW5jZSAuZm9jdXMoKVxuICAgICAgICAgICAgLy8gd29uJ3QgY2F1c2UgYSBzY3JvbGwgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkIGFuZCBkb2Vzbid0IGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBhbiBlbGVtZW50IGlzIHBhcnRpYWxseSBvdXQgb2YgdmlldyBob3Jpem9udGFsbHkgdnMgdmVydGljYWxseVxuICAgICAgICAgICAgX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgICAgICBsZXQgeyBsZWZ0OiBvcmlnaW5hbExlZnQsIHRvcDogb3JpZ2luYWxUb3AgfSA9IHRhcmdldEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50ID09PSBudWxsIHx8IHRhcmdldEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldyA9IHRhcmdldEVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcpID09PSBudWxsIHx8IF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldy5jYWxsKHRhcmdldEVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHsgbGVmdDogbmV3TGVmdCwgdG9wOiBuZXdUb3AgfSA9IHRhcmdldEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBBY2NvdW50IGZvciBzdWIgcGl4ZWwgZGlmZmVyZW5jZXMgZnJvbSByb3VuZGluZ1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG9yaWdpbmFsTGVmdCAtIG5ld0xlZnQpID4gMSB8fCBNYXRoLmFicyhvcmlnaW5hbFRvcCAtIG5ld1RvcCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50X3Njcm9sbEludG9WaWV3LCBfb3B0c19jb250YWluaW5nRWxlbWVudCwgX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcxO1xuICAgICAgICAgICAgICAgIG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50ID0gb3B0cy5jb250YWluaW5nRWxlbWVudCkgPT09IG51bGwgfHwgX29wdHNfY29udGFpbmluZ0VsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfb3B0c19jb250YWluaW5nRWxlbWVudF9zY3JvbGxJbnRvVmlldyA9IF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50LnNjcm9sbEludG9WaWV3KSA9PT0gbnVsbCB8fCBfb3B0c19jb250YWluaW5nRWxlbWVudF9zY3JvbGxJbnRvVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHNfY29udGFpbmluZ0VsZW1lbnRfc2Nyb2xsSW50b1ZpZXcuY2FsbChfb3B0c19jb250YWluaW5nRWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICBibG9jazogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lOiBcImNlbnRlclwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgKF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MSA9IHRhcmdldEVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcpID09PSBudWxsIHx8IF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcxLmNhbGwodGFyZ2V0RWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxQYXJlbnQgPSAoMCwgJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JGNmYTIyMjVlODc5Mzg3ODEpKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gSWYgc2Nyb2xsaW5nIGlzIHByZXZlbnRlZCwgd2UgZG9uJ3Qgd2FudCB0byBzY3JvbGwgdGhlIGJvZHkgc2luY2UgaXQgbWlnaHQgbW92ZSB0aGUgb3ZlcmxheSBwYXJ0aWFsbHkgb2Zmc2NyZWVuIGFuZCB0aGUgdXNlciBjYW4ndCBzY3JvbGwgaXQgYmFjayBpbnRvIHZpZXcuXG4gICAgICAgICAgICB3aGlsZSh0YXJnZXRFbGVtZW50ICYmIHNjcm9sbFBhcmVudCAmJiB0YXJnZXRFbGVtZW50ICE9PSByb290ICYmIHNjcm9sbFBhcmVudCAhPT0gcm9vdCl7XG4gICAgICAgICAgICAgICAgJDJmMDRjYmM0NGVlMzBjZTAkZXhwb3J0JDUzYTA5MTBmMDM4MzM3YmQoc2Nyb2xsUGFyZW50LCB0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gc2Nyb2xsUGFyZW50O1xuICAgICAgICAgICAgICAgIHNjcm9sbFBhcmVudCA9ICgwLCAkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkY2ZhMjIyNWU4NzkzODc4MSkodGFyZ2V0RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkNjAyNzg4NzE0NTc2MjJkZShldmVudCkge1xuICAgIC8vIEpBV1MvTlZEQSB3aXRoIEZpcmVmb3guXG4gICAgaWYgKGV2ZW50Lm1veklucHV0U291cmNlID09PSAwICYmIGV2ZW50LmlzVHJ1c3RlZCkgcmV0dXJuIHRydWU7XG4gICAgLy8gQW5kcm9pZCBUYWxrQmFjaydzIGRldGFpbCB2YWx1ZSB2YXJpZXMgZGVwZW5kaW5nIG9uIHRoZSBldmVudCBsaXN0ZW5lciBwcm92aWRpbmcgdGhlIGV2ZW50IHNvIHdlIGhhdmUgc3BlY2lmaWMgbG9naWMgaGVyZSBpbnN0ZWFkXG4gICAgLy8gSWYgcG9pbnRlclR5cGUgaXMgZGVmaW5lZCwgZXZlbnQgaXMgZnJvbSBhIGNsaWNrIGxpc3RlbmVyLiBGb3IgZXZlbnRzIGZyb20gbW91c2Vkb3duIGxpc3RlbmVyLCBkZXRhaWwgPT09IDAgaXMgYSBzdWZmaWNpZW50IGNoZWNrXG4gICAgLy8gdG8gZGV0ZWN0IFRhbGtCYWNrIHZpcnR1YWwgY2xpY2tzLlxuICAgIGlmICgoMCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGExMWIwMDU5OTAwY2VlYzgpKCkgJiYgZXZlbnQucG9pbnRlclR5cGUpIHJldHVybiBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMTtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsID09PSAwICYmICFldmVudC5wb2ludGVyVHlwZTtcbn1cbmZ1bmN0aW9uICQ2YTdkYjg1NDMyNDQ4ZjdmJGV4cG9ydCQyOWJmMWI1ZjJjNTZjZjYzKGV2ZW50KSB7XG4gICAgLy8gSWYgdGhlIHBvaW50ZXIgc2l6ZSBpcyB6ZXJvLCB0aGVuIHdlIGFzc3VtZSBpdCdzIGZyb20gYSBzY3JlZW4gcmVhZGVyLlxuICAgIC8vIEFuZHJvaWQgVGFsa0JhY2sgZG91YmxlIHRhcCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gYSBldmVudCB3aXRoIHdpZHRoIGFuZCBoZWlnaHQgb2YgMVxuICAgIC8vIGFuZCBwb2ludGVyVHlwZSA9PT0gJ21vdXNlJyBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBhIHNwZWNpZmljIGNvbWJpbmF0aW9uIG9mIGV2ZW50IGF0dHJpYnV0ZXMuXG4gICAgLy8gQ2Fubm90IHVzZSBcImV2ZW50LnByZXNzdXJlID09PSAwXCIgYXMgdGhlIHNvbGUgY2hlY2sgZHVlIHRvIFNhZmFyaSBwb2ludGVyIGV2ZW50cyBhbHdheXMgcmV0dXJuaW5nIHByZXNzdXJlID09PSAwXG4gICAgLy8gaW5zdGVhZCBvZiAuNSwgc2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDYyMTYuIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIGlzIHRvIGRpc3Rpbmd1c2hcbiAgICAvLyBUYWxrYmFjayBkb3VibGUgdGFwIGZyb20gV2luZG93cyBGaXJlZm94IHRvdWNoIHNjcmVlbiBwcmVzc1xuICAgIHJldHVybiAhKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4KSgpICYmIGV2ZW50LndpZHRoID09PSAwICYmIGV2ZW50LmhlaWdodCA9PT0gMCB8fCBldmVudC53aWR0aCA9PT0gMSAmJiBldmVudC5oZWlnaHQgPT09IDEgJiYgZXZlbnQucHJlc3N1cmUgPT09IDAgJiYgZXZlbnQuZGV0YWlsID09PSAwICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCI7XG59XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLyogZXNsaW50LWRpc2FibGUgcnVsZXNkaXIvcHVyZS1yZW5kZXIgKi8gXG5mdW5jdGlvbiAkNWEzODdjYzQ5MzUwZTZkYiRleHBvcnQkNzIyZGViYzBlNTZmZWEzOSh2YWx1ZSwgaXNFcXVhbCkge1xuICAgIC8vIFVzaW5nIGEgcmVmIGR1cmluZyByZW5kZXIgaXMgb2sgaGVyZSBiZWNhdXNlIGl0J3Mgb25seSBhbiBvcHRpbWl6YXRpb24g4oCTIGJvdGggdmFsdWVzIGFyZSBlcXVpdmFsZW50LlxuICAgIC8vIElmIGEgcmVuZGVyIGlzIHRocm93biBhd2F5LCBpdCdsbCBzdGlsbCB3b3JrIHRoZSBzYW1lIG5vIG1hdHRlciBpZiB0aGUgbmV4dCByZW5kZXIgaXMgdGhlIHNhbWUgb3Igbm90LlxuICAgIGxldCBsYXN0VmFsdWUgPSAoMCwgJDEydUdwJHVzZVJlZikobnVsbCk7XG4gICAgaWYgKHZhbHVlICYmIGxhc3RWYWx1ZS5jdXJyZW50ICYmIGlzRXF1YWwodmFsdWUsIGxhc3RWYWx1ZS5jdXJyZW50KSkgdmFsdWUgPSBsYXN0VmFsdWUuY3VycmVudDtcbiAgICBsYXN0VmFsdWUuY3VycmVudCA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ5OWZhY2FiNzMyNjZmNjYyJGV4cG9ydCQ1YWRkMWQwMDYyOTNkMTM2KHJlZiwgaW5pdGlhbFZhbHVlLCBvblJlc2V0KSB7XG4gICAgbGV0IHJlc2V0VmFsdWUgPSAoMCwgJDEydUdwJHVzZVJlZikoaW5pdGlhbFZhbHVlKTtcbiAgICBsZXQgaGFuZGxlUmVzZXQgPSAoMCwgJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIpKCgpPT57XG4gICAgICAgIGlmIChvblJlc2V0KSBvblJlc2V0KHJlc2V0VmFsdWUuY3VycmVudCk7XG4gICAgfSk7XG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHZhciBfcmVmX2N1cnJlbnQ7XG4gICAgICAgIGxldCBmb3JtID0gcmVmID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9yZWZfY3VycmVudCA9IHJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVmX2N1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWZfY3VycmVudC5mb3JtO1xuICAgICAgICBmb3JtID09PSBudWxsIHx8IGZvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0XCIsIGhhbmRsZVJlc2V0KTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBmb3JtID09PSBudWxsIHx8IGZvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2V0XCIsIGhhbmRsZVJlc2V0KTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHJlZixcbiAgICAgICAgaGFuZGxlUmVzZXRcbiAgICBdKTtcbn1cblxuXG5cblxuZXhwb3J0IHskYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkZjY4MDg3N2EzNDcxMWUzNyBhcyB1c2VJZCwgJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGNkOGM5Y2I2OGY4NDI2MjkgYXMgbWVyZ2VJZHMsICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRiNGNjMDljNTkyZThmZGI4IGFzIHVzZVNsb3RJZCwgJGZmNTk2M2ViMWZjY2Y1NTIkZXhwb3J0JGUwOGUzYjY3ZTM5MjEwMWUgYXMgY2hhaW4sICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjIGFzIGdldE93bmVyRG9jdW1lbnQsICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhIGFzIGdldE93bmVyV2luZG93LCAkM2VmNDI1NzVkZjg0YjMwYiRleHBvcnQkOWQxNjExYzc3YzJmZTkyOCBhcyBtZXJnZVByb3BzLCAkNWRjOTU4OTliMzA2ZjYzMCRleHBvcnQkYzkwNTgzMTY3NjRjMTQwZSBhcyBtZXJnZVJlZnMsICQ2NTQ4NGQwMmRjYjdlYjNlJGV4cG9ydCQ0NTdjM2Q2NTE4ZGQ0YzZmIGFzIGZpbHRlckRPTVByb3BzLCAkNzIxNWFmYzZkZTYwNmQ2YiRleHBvcnQkZGU3OWUyYzY5NWUwNTJmMyBhcyBmb2N1c1dpdGhvdXRTY3JvbGxpbmcsICRhYjcxZGFkYjAzYTZmYjJlJGV4cG9ydCQ2MjJjZWE0NDVhMWM1YjdkIGFzIGdldE9mZnNldCwgJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDk1MTg1ZDY5OWUwNWQ0ZDcgYXMgb3BlbkxpbmssICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ1MTQzN2Q1MDMzNzNkMjIzIGFzIGdldFN5bnRoZXRpY0xpbmtQcm9wcywgJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDMyM2U0ZmMyZmE0NzUzZmIgYXMgUm91dGVyUHJvdmlkZXIsICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCRlZmE4YzkwOTllNTMwMjM1IGFzIHNob3VsZENsaWVudE5hdmlnYXRlLCAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOWEzMDJhNDVmNjVkMDU3MiBhcyB1c2VSb3V0ZXIsICRiYmVkOGI0MWY4NTdiY2MwJGV4cG9ydCQyNDQ5MDMxNmY3NjRjNDMwIGFzIHJ1bkFmdGVyVHJhbnNpdGlvbiwgJDljYzA5ZGY5ZmQ3Njc2YmUkZXhwb3J0JDdiYmVkNzVmZWJhMzk3MDYgYXMgdXNlRHJhZzFELCAkMDNkZWIyM2ZmMTQ5MjBjNCRleHBvcnQkNGVhZjA0ZTU0YWE4ZWVkNiBhcyB1c2VHbG9iYWxMaXN0ZW5lcnMsICQzMTNiOTg4NjFlZTVkZDZjJGV4cG9ydCRkNjg3NTEyMjE5NGM3YjQ0IGFzIHVzZUxhYmVscywgJGRmNTYxNjRkZmY1Nzg1ZTIkZXhwb3J0JDQzMzhiNTMzMTVhYmY2NjYgYXMgdXNlT2JqZWN0UmVmLCAkNGY1OGM1ZjcyYmNmNzlmNyRleHBvcnQkNDk2MzE1YTE2MDhkOTYwMiBhcyB1c2VVcGRhdGVFZmZlY3QsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjIGFzIHVzZUxheW91dEVmZmVjdCwgJDlkYWFiMDJkNDYxODA5ZGIkZXhwb3J0JDY4MzQ4MGYxOTFjMGUzZWEgYXMgdXNlUmVzaXplT2JzZXJ2ZXIsICRlNzgwMWJlODJiNGIyYTUzJGV4cG9ydCQ0ZGViZGIxYTNmMGZhNzllIGFzIHVzZVN5bmNSZWYsICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCRjZmEyMjI1ZTg3OTM4NzgxIGFzIGdldFNjcm9sbFBhcmVudCwgJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JDJiYjc0NzQwYzRlMTlkZWYgYXMgaXNTY3JvbGxhYmxlLCAkNWRmNjRiMzgwN2RjMTVlZSRleHBvcnQkZDY5OTkwNWRkNTdjNzNjYSBhcyB1c2VWaWV3cG9ydFNpemUsICRlZjA2MjU2MDc5Njg2YmEwJGV4cG9ydCRmOGFlZGE3YjEwNzUzZmExIGFzIHVzZURlc2NyaXB0aW9uLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCBhcyBpc01hYywgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDE4NmM2OTY0Y2ExN2Q5OSBhcyBpc0lQaG9uZSwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDdiZWYwNDljZTkyZTQyMjQgYXMgaXNJUGFkLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZmVkYjM2OWNiNzAyMDdmMSBhcyBpc0lPUywgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGUxODY1YzNiZWRjZDgyMmIgYXMgaXNBcHBsZURldmljZSwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDc4NTUxMDQzNTgyYTZhOTggYXMgaXNXZWJLaXQsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ2NDQ2YTE4NmQwOWUzNzllIGFzIGlzQ2hyb21lLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCBhcyBpc0FuZHJvaWQsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRiN2Q3ODk5M2I3NGY3NjZkIGFzIGlzRmlyZWZveCwgJGU5ZmFhZmI2NDFlMTY3ZGIkZXhwb3J0JDkwZmMzYTE3ZDkzZjcwNGMgYXMgdXNlRXZlbnQsICQxZGJlY2JlMjdhMDRmOWFmJGV4cG9ydCQxNGQyMzhmMzQyNzIzZjI1IGFzIHVzZVZhbHVlRWZmZWN0LCAkMmYwNGNiYzQ0ZWUzMGNlMCRleHBvcnQkNTNhMDkxMGYwMzgzMzdiZCBhcyBzY3JvbGxJbnRvVmlldywgJDJmMDRjYmM0NGVlMzBjZTAkZXhwb3J0JGM4MjY4NjA3OTYzMDlkMWIgYXMgc2Nyb2xsSW50b1ZpZXdwb3J0LCAkNDUwNzQ2MWExYjg3MDEyMyRyZV9leHBvcnQkY2xhbXAgYXMgY2xhbXAsICQ0NTA3NDYxYTFiODcwMTIzJHJlX2V4cG9ydCRzbmFwVmFsdWVUb1N0ZXAgYXMgc25hcFZhbHVlVG9TdGVwLCAkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkNjAyNzg4NzE0NTc2MjJkZSBhcyBpc1ZpcnR1YWxDbGljaywgJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDI5YmYxYjVmMmM1NmNmNjMgYXMgaXNWaXJ0dWFsUG9pbnRlckV2ZW50LCAkOGFlMDVlYWE1YzExNGU5YyRleHBvcnQkN2Y1NGZjMzE4MDUwOGE1MiBhcyB1c2VFZmZlY3RFdmVudCwgJDVhMzg3Y2M0OTM1MGU2ZGIkZXhwb3J0JDcyMmRlYmMwZTU2ZmVhMzkgYXMgdXNlRGVlcE1lbW8sICQ5OWZhY2FiNzMyNjZmNjYyJGV4cG9ydCQ1YWRkMWQwMDYyOTNkMTM2IGFzIHVzZUZvcm1SZXNldH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiY2xhbXAiLCIkNDUwNzQ2MWExYjg3MDEyMyRyZV9leHBvcnQkY2xhbXAiLCJzbmFwVmFsdWVUb1N0ZXAiLCIkNDUwNzQ2MWExYjg3MDEyMyRyZV9leHBvcnQkc25hcFZhbHVlVG9TdGVwIiwiJDEydUdwJHJlYWN0IiwidXNlU3RhdGUiLCIkMTJ1R3AkdXNlU3RhdGUiLCJ1c2VSZWYiLCIkMTJ1R3AkdXNlUmVmIiwidXNlQ2FsbGJhY2siLCIkMTJ1R3AkdXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCIkMTJ1R3AkdXNlRWZmZWN0IiwiY3JlYXRlQ29udGV4dCIsIiQxMnVHcCRjcmVhdGVDb250ZXh0IiwidXNlTWVtbyIsIiQxMnVHcCR1c2VNZW1vIiwidXNlQ29udGV4dCIsIiQxMnVHcCR1c2VDb250ZXh0IiwidXNlU1NSU2FmZUlkIiwiJDEydUdwJHVzZVNTUlNhZmVJZCIsInVzZUlzU1NSIiwiJDEydUdwJHVzZUlzU1NSIiwiJDEydUdwJGNsc3giLCIkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYyIsImRvY3VtZW50IiwidXNlTGF5b3V0RWZmZWN0IiwiJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIiLCJmbiIsInJlZiIsImN1cnJlbnQiLCJhcmdzIiwiZiIsIiQxZGJlY2JlMjdhMDRmOWFmJGV4cG9ydCQxNGQyMzhmMzQyNzIzZjI1IiwiZGVmYXVsdFZhbHVlIiwidmFsdWUiLCJzZXRWYWx1ZSIsImVmZmVjdCIsIm5leHRSZWYiLCJuZXdWYWx1ZSIsIm5leHQiLCJkb25lIiwicXVldWUiLCIkYmRiMTEwMTBjZWY3MDIzNiR2YXIkY2FuVXNlRE9NIiwiQm9vbGVhbiIsIndpbmRvdyIsImNyZWF0ZUVsZW1lbnQiLCIkYmRiMTEwMTBjZWY3MDIzNiR2YXIkaWRzVXBkYXRlck1hcCIsIk1hcCIsIiRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRmNjgwODc3YTM0NzExZTM3IiwiZGVmYXVsdElkIiwibmV4dElkIiwicmVzIiwidXBkYXRlVmFsdWUiLCJ2YWwiLCJzZXQiLCJyIiwiZGVsZXRlIiwibmV3SWQiLCIkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkY2Q4YzljYjY4Zjg0MjYyOSIsImlkQSIsImlkQiIsInNldElkQSIsImdldCIsInNldElkQiIsIiRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRiNGNjMDljNTkyZThmZGI4IiwiZGVwQXJyYXkiLCJpZCIsInJlc29sdmVkSWQiLCJzZXRSZXNvbHZlZElkIiwidXBkYXRlSWQiLCJnZXRFbGVtZW50QnlJZCIsInVuZGVmaW5lZCIsIiRmZjU5NjNlYjFmY2NmNTUyJGV4cG9ydCRlMDhlM2I2N2UzOTIxMDFlIiwiY2FsbGJhY2tzIiwiY2FsbGJhY2siLCIkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyIsImVsIiwiX2VsX293bmVyRG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGYyMWExZmZhZTI2MDE0NWEiLCJkb2MiLCJkZWZhdWx0VmlldyIsIiQzZWY0MjU3NWRmODRiMzBiJGV4cG9ydCQ5ZDE2MTFjNzdjMmZlOTI4IiwicmVzdWx0IiwiaSIsImxlbmd0aCIsInByb3BzIiwia2V5IiwiYSIsImIiLCJjaGFyQ29kZUF0IiwiJDVkYzk1ODk5YjMwNmY2MzAkZXhwb3J0JGM5MDU4MzE2NzY0YzE0MGUiLCJyZWZzIiwiJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJERPTVByb3BOYW1lcyIsIlNldCIsIiQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRsYWJlbGFibGVQcm9wTmFtZXMiLCIkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkbGlua1Byb3BOYW1lcyIsIiQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRwcm9wUmUiLCIkNjU0ODRkMDJkY2I3ZWIzZSRleHBvcnQkNDU3YzNkNjUxOGRkNGM2ZiIsIm9wdHMiLCJsYWJlbGFibGUiLCJpc0xpbmsiLCJwcm9wTmFtZXMiLCJmaWx0ZXJlZFByb3BzIiwicHJvcCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImhhcyIsInRlc3QiLCIkNzIxNWFmYzZkZTYwNmQ2YiRleHBvcnQkZGU3OWUyYzY5NWUwNTJmMyIsImVsZW1lbnQiLCIkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkc3VwcG9ydHNQcmV2ZW50U2Nyb2xsIiwiZm9jdXMiLCJwcmV2ZW50U2Nyb2xsIiwic2Nyb2xsYWJsZUVsZW1lbnRzIiwiJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJGdldFNjcm9sbGFibGVFbGVtZW50cyIsIiQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCIkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkc3VwcG9ydHNQcmV2ZW50U2Nyb2xsQ2FjaGVkIiwiZm9jdXNFbGVtIiwiZSIsInBhcmVudCIsInBhcmVudE5vZGUiLCJyb290U2Nyb2xsaW5nRWxlbWVudCIsInNjcm9sbGluZ0VsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIm9mZnNldEhlaWdodCIsInNjcm9sbEhlaWdodCIsIm9mZnNldFdpZHRoIiwic2Nyb2xsV2lkdGgiLCJwdXNoIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsIiRhYjcxZGFkYjAzYTZmYjJlJGV4cG9ydCQ2MjJjZWE0NDVhMWM1YjdkIiwicmV2ZXJzZSIsIm9yaWVudGF0aW9uIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInRvcCIsIiRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0VXNlckFnZW50IiwicmUiLCJfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhIiwibmF2aWdhdG9yIiwiYnJhbmRzIiwic29tZSIsImJyYW5kIiwidXNlckFnZW50IiwiJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RQbGF0Zm9ybSIsInBsYXRmb3JtIiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkMTg2YzY5NjRjYTE3ZDk5IiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDdiZWYwNDljZTkyZTQyMjQiLCJtYXhUb3VjaFBvaW50cyIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRmZWRiMzY5Y2I3MDIwN2YxIiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGUxODY1YzNiZWRjZDgyMmIiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNzg1NTEwNDM1ODJhNmE5OCIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ2NDQ2YTE4NmQwOWUzNzllIiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGExMWIwMDU5OTAwY2VlYzgiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYjdkNzg5OTNiNzRmNzY2ZCIsIiRlYThkY2JjYjllYTFiNTU2JHZhciRSb3V0ZXJDb250ZXh0IiwiaXNOYXRpdmUiLCJvcGVuIiwiJGVhOGRjYmNiOWVhMWI1NTYkdmFyJG9wZW5TeW50aGV0aWNMaW5rIiwiJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDMyM2U0ZmMyZmE0NzUzZmIiLCJjaGlsZHJlbiIsIm5hdmlnYXRlIiwiY3R4IiwidGFyZ2V0IiwibW9kaWZpZXJzIiwiJGVhOGRjYmNiOWVhMWI1NTYkdmFyJGdldFN5bnRoZXRpY0xpbmsiLCJsaW5rIiwiJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JGVmYThjOTA5OWU1MzAyMzUiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCIkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNyIsIlByb3ZpZGVyIiwiJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDlhMzAyYTQ1ZjY1ZDA1NzIiLCJnZXRBdHRyaWJ1dGUiLCJvcmlnaW4iLCJsb2NhdGlvbiIsImhhc0F0dHJpYnV0ZSIsIm1ldGFLZXkiLCJjdHJsS2V5IiwiYWx0S2V5Iiwic2hpZnRLZXkiLCJzZXRPcGVuaW5nIiwiX3dpbmRvd19ldmVudF90eXBlIiwiX3dpbmRvd19ldmVudCIsImV2ZW50IiwidHlwZSIsInN0YXJ0c1dpdGgiLCJLZXlib2FyZEV2ZW50Iiwia2V5SWRlbnRpZmllciIsIk1vdXNlRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImlzT3BlbmluZyIsImRpc3BhdGNoRXZlbnQiLCJIVE1MQW5jaG9yRWxlbWVudCIsImhyZWYiLCJyZWwiLCJkb3dubG9hZCIsInBpbmciLCJyZWZlcnJlclBvbGljeSIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCIkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkNTE0MzdkNTAzMzczZDIyMyIsIiRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudCIsIiRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uQ2FsbGJhY2tzIiwiJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHNldHVwR2xvYmFsRXZlbnRzIiwib25UcmFuc2l0aW9uU3RhcnQiLCJ0cmFuc2l0aW9ucyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblRyYW5zaXRpb25FbmQiLCJhZGQiLCJwcm9wZXJ0eU5hbWUiLCJwcm9wZXJ0aWVzIiwic2l6ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYiIsImNsZWFyIiwiYm9keSIsInJlYWR5U3RhdGUiLCIkYmJlZDhiNDFmODU3YmNjMCRleHBvcnQkMjQ0OTAzMTZmNzY0YzQzMCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIiQ5Y2MwOWRmOWZkNzY3NmJlJHZhciRkcmFnZ2luZ0VsZW1lbnRzIiwiJDljYzA5ZGY5ZmQ3Njc2YmUkZXhwb3J0JDdiYmVkNzVmZWJhMzk3MDYiLCJjb25zb2xlIiwid2FybiIsImNvbnRhaW5lclJlZiIsIm9uSG92ZXIiLCJvbkRyYWciLCJvblBvc2l0aW9uQ2hhbmdlIiwib25JbmNyZW1lbnQiLCJvbkRlY3JlbWVudCIsIm9uSW5jcmVtZW50VG9NYXgiLCJvbkRlY3JlbWVudFRvTWluIiwib25Db2xsYXBzZVRvZ2dsZSIsImdldFBvc2l0aW9uIiwiY2xpZW50WCIsImNsaWVudFkiLCJnZXROZXh0T2Zmc2V0IiwiY29udGFpbmVyT2Zmc2V0IiwibW91c2VPZmZzZXQiLCJuZXh0T2Zmc2V0IiwiZHJhZ2dpbmciLCJwcmV2UG9zaXRpb24iLCJoYW5kbGVycyIsIm9uTW91c2VEcmFnZ2VkIiwicHJldmVudERlZmF1bHQiLCJvbk1vdXNlVXAiLCJzcGxpY2UiLCJpbmRleE9mIiwib25Nb3VzZURvd24iLCJjdXJyZW50VGFyZ2V0IiwiZWx0IiwiY29udGFpbnMiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlT3V0Iiwib25LZXlEb3duIiwiJDAzZGViMjNmZjE0OTIwYzQkZXhwb3J0JDRlYWYwNGU1NGFhOGVlZDYiLCJnbG9iYWxMaXN0ZW5lcnMiLCJhZGRHbG9iYWxMaXN0ZW5lciIsImV2ZW50VGFyZ2V0IiwibGlzdGVuZXIiLCJvcHRpb25zIiwib25jZSIsInJlbW92ZUdsb2JhbExpc3RlbmVyIiwiX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldCIsInJlbW92ZUFsbEdsb2JhbExpc3RlbmVycyIsImZvckVhY2giLCIkMzEzYjk4ODYxZWU1ZGQ2YyRleHBvcnQkZDY4NzUxMjIxOTRjN2I0NCIsImRlZmF1bHRMYWJlbCIsImxhYmVsIiwibGFiZWxsZWRCeSIsImlkcyIsInRyaW0iLCJzcGxpdCIsImpvaW4iLCIkZGY1NjE2NGRmZjU3ODVlMiRleHBvcnQkNDMzOGI1MzMxNWFiZjY2NiIsImZvcndhcmRlZFJlZiIsIm9ialJlZiIsIiQ0ZjU4YzVmNzJiY2Y3OWY3JGV4cG9ydCQ0OTYzMTVhMTYwOGQ5NjAyIiwiZGVwZW5kZW5jaWVzIiwiaXNJbml0aWFsTW91bnQiLCJsYXN0RGVwcyIsImRlcCIsImlzIiwiJDlkYWFiMDJkNDYxODA5ZGIkdmFyJGhhc1Jlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCIkOWRhYWIwMmQ0NjE4MDlkYiRleHBvcnQkNjgzNDgwZjE5MWMwZTNlYSIsIm9uUmVzaXplIiwicmVzaXplT2JzZXJ2ZXJJbnN0YW5jZSIsImVudHJpZXMiLCJvYnNlcnZlIiwidW5vYnNlcnZlIiwiJGU3ODAxYmU4MmI0YjJhNTMkZXhwb3J0JDRkZWJkYjFhM2YwZmE3OWUiLCJjb250ZXh0IiwiJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JGNmYTIyMjVlODc5Mzg3ODEiLCJub2RlIiwiY2hlY2tGb3JPdmVyZmxvdyIsIiQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmIiwicGFyZW50RWxlbWVudCIsInN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzU2Nyb2xsYWJsZSIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCIkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQiLCJ2aXN1YWxWaWV3cG9ydCIsIiQ1ZGY2NGIzODA3ZGMxNWVlJGV4cG9ydCRkNjk5OTA1ZGQ1N2M3M2NhIiwiaXNTU1IiLCJzZXRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCIkNWRmNjRiMzgwN2RjMTVlZSR2YXIkZ2V0Vmlld3BvcnRTaXplIiwibmV3U2l6ZSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIiRlZjA2MjU2MDc5Njg2YmEwJHZhciRkZXNjcmlwdGlvbklkIiwiJGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uTm9kZXMiLCIkZWYwNjI1NjA3OTY4NmJhMCRleHBvcnQkZjhhZWRhN2IxMDc1M2ZhMSIsImRlc2NyaXB0aW9uIiwic2V0SWQiLCJkZXNjIiwiZGlzcGxheSIsInRleHRDb250ZW50IiwicmVmQ291bnQiLCJyZW1vdmUiLCIkZTlmYWFmYjY0MWUxNjdkYiRleHBvcnQkOTBmYzNhMTdkOTNmNzA0YyIsImhhbmRsZXIiLCJoYW5kbGVFdmVudCIsImlzRGlzYWJsZWQiLCIkMmYwNGNiYzQ0ZWUzMGNlMCRleHBvcnQkNTNhMDkxMGYwMzgzMzdiZCIsInNjcm9sbFZpZXciLCJvZmZzZXRYIiwiJDJmMDRjYmM0NGVlMzBjZTAkdmFyJHJlbGF0aXZlT2Zmc2V0Iiwib2Zmc2V0WSIsIngiLCJ5IiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJBZGp1c3RlZFgiLCJwYXJzZUludCIsImJvcmRlckFkanVzdGVkWSIsIm1heFgiLCJtYXhZIiwiYW5jZXN0b3IiLCJjaGlsZCIsImF4aXMiLCJzdW0iLCJvZmZzZXRQYXJlbnQiLCIkMmYwNGNiYzQ0ZWUzMGNlMCRleHBvcnQkYzgyNjg2MDc5NjMwOWQxYiIsInRhcmdldEVsZW1lbnQiLCJyb290IiwiaXNTY3JvbGxQcmV2ZW50ZWQiLCJfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldyIsIm9yaWdpbmFsTGVmdCIsIm9yaWdpbmFsVG9wIiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsIm5ld0xlZnQiLCJuZXdUb3AiLCJNYXRoIiwiYWJzIiwiX29wdHNfY29udGFpbmluZ0VsZW1lbnRfc2Nyb2xsSW50b1ZpZXciLCJfb3B0c19jb250YWluaW5nRWxlbWVudCIsIl90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MSIsImNvbnRhaW5pbmdFbGVtZW50IiwiaW5saW5lIiwic2Nyb2xsUGFyZW50IiwiJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDYwMjc4ODcxNDU3NjIyZGUiLCJtb3pJbnB1dFNvdXJjZSIsImlzVHJ1c3RlZCIsInBvaW50ZXJUeXBlIiwiYnV0dG9ucyIsImRldGFpbCIsIiQ2YTdkYjg1NDMyNDQ4ZjdmJGV4cG9ydCQyOWJmMWI1ZjJjNTZjZjYzIiwicHJlc3N1cmUiLCIkNWEzODdjYzQ5MzUwZTZkYiRleHBvcnQkNzIyZGViYzBlNTZmZWEzOSIsImlzRXF1YWwiLCJsYXN0VmFsdWUiLCIkOTlmYWNhYjczMjY2ZjY2MiRleHBvcnQkNWFkZDFkMDA2MjkzZDEzNiIsImluaXRpYWxWYWx1ZSIsIm9uUmVzZXQiLCJyZXNldFZhbHVlIiwiaGFuZGxlUmVzZXQiLCJfcmVmX2N1cnJlbnQiLCJmb3JtIiwidXNlSWQiLCJtZXJnZUlkcyIsInVzZVNsb3RJZCIsImNoYWluIiwiZ2V0T3duZXJEb2N1bWVudCIsImdldE93bmVyV2luZG93IiwibWVyZ2VQcm9wcyIsIm1lcmdlUmVmcyIsImZpbHRlckRPTVByb3BzIiwiZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwiZ2V0T2Zmc2V0Iiwib3BlbkxpbmsiLCJnZXRTeW50aGV0aWNMaW5rUHJvcHMiLCJSb3V0ZXJQcm92aWRlciIsInNob3VsZENsaWVudE5hdmlnYXRlIiwidXNlUm91dGVyIiwicnVuQWZ0ZXJUcmFuc2l0aW9uIiwidXNlRHJhZzFEIiwidXNlR2xvYmFsTGlzdGVuZXJzIiwidXNlTGFiZWxzIiwidXNlT2JqZWN0UmVmIiwidXNlVXBkYXRlRWZmZWN0IiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJ1c2VTeW5jUmVmIiwiZ2V0U2Nyb2xsUGFyZW50IiwidXNlVmlld3BvcnRTaXplIiwidXNlRGVzY3JpcHRpb24iLCJpc01hYyIsImlzSVBob25lIiwiaXNJUGFkIiwiaXNJT1MiLCJpc0FwcGxlRGV2aWNlIiwiaXNXZWJLaXQiLCJpc0Nocm9tZSIsImlzQW5kcm9pZCIsImlzRmlyZWZveCIsInVzZUV2ZW50IiwidXNlVmFsdWVFZmZlY3QiLCJzY3JvbGxJbnRvVmlld3BvcnQiLCJpc1ZpcnR1YWxDbGljayIsImlzVmlydHVhbFBvaW50ZXJFdmVudCIsInVzZUVmZmVjdEV2ZW50IiwidXNlRGVlcE1lbW8iLCJ1c2VGb3JtUmVzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/utils/node_modules/@react-aria/ssr/dist/import.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@react-aria/utils/node_modules/@react-aria/ssr/dist/import.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SSRProvider: () => (/* binding */ $b5e257d569688ac6$export$9f8ac96af4b1b2ae),\n/* harmony export */   useIsSSR: () => (/* binding */ $b5e257d569688ac6$export$535bd6ca7f90a273),\n/* harmony export */   useSSRSafeId: () => (/* binding */ $b5e257d569688ac6$export$619500959fc48b26)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is\n// guarded by a check that it only runs on the client side.\n// eslint-disable-next-line rulesdir/useLayoutEffectRule\n// Default context value to use in case there is no SSRProvider. This is fine for\n// client-only apps. In order to support multiple copies of React Aria potentially\n// being on the page at once, the prefix is set to a random number. SSRProvider\n// will reset this to zero for consistency between server and client, so in the\n// SSR case multiple copies of React Aria is not supported.\nconst $b5e257d569688ac6$var$defaultContext = {\n    prefix: String(Math.round(Math.random() * 10000000000)),\n    current: 0\n};\nconst $b5e257d569688ac6$var$SSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext($b5e257d569688ac6$var$defaultContext);\nconst $b5e257d569688ac6$var$IsSSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(false);\n// This is only used in React < 18.\nfunction $b5e257d569688ac6$var$LegacySSRProvider(props) {\n    let cur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let counter = $b5e257d569688ac6$var$useCounter(cur === $b5e257d569688ac6$var$defaultContext);\n    let [isSSR, setIsSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            // If this is the first SSRProvider, start with an empty string prefix, otherwise\n            // append and increment the counter.\n            prefix: cur === $b5e257d569688ac6$var$defaultContext ? \"\" : `${cur.prefix}-${counter}`,\n            current: 0\n        }), [\n        cur,\n        counter\n    ]);\n    // If on the client, and the component was initially server rendered,\n    // then schedule a layout effect to update the component after hydration.\n    if (typeof document !== \"undefined\") // because the condition never changes after mounting.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        setIsSSR(false);\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$SSRContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$IsSSRContext.Provider, {\n        value: isSSR\n    }, props.children));\n}\nlet $b5e257d569688ac6$var$warnedAboutSSRProvider = false;\nfunction $b5e257d569688ac6$export$9f8ac96af4b1b2ae(props) {\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\") {\n        if ( true && !$b5e257d569688ac6$var$warnedAboutSSRProvider) {\n            console.warn(\"In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.\");\n            $b5e257d569688ac6$var$warnedAboutSSRProvider = true;\n        }\n        return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, react__WEBPACK_IMPORTED_MODULE_0__).Fragment, null, props.children);\n    }\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$LegacySSRProvider, props);\n}\nlet $b5e257d569688ac6$var$canUseDOM = Boolean( false && 0);\nlet $b5e257d569688ac6$var$componentIds = new WeakMap();\nfunction $b5e257d569688ac6$var$useCounter(isDisabled = false) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // eslint-disable-next-line rulesdir/pure-render\n    if (ref.current === null && !isDisabled) {\n        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.\n        // This means our id counter will be incremented twice instead of once. This is a problem because on the\n        // server, components are only rendered once and so ids generated on the server won't match the client.\n        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this\n        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.\n        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.\n        // To ensure that we only increment the global counter once, we store the starting id for this component in\n        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.\n        // Since React runs the second render immediately after the first, this is safe.\n        // @ts-ignore\n        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, react__WEBPACK_IMPORTED_MODULE_0__).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;\n        if (currentOwner) {\n            let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);\n            if (prevComponentValue == null) $b5e257d569688ac6$var$componentIds.set(currentOwner, {\n                id: ctx.current,\n                state: currentOwner.memoizedState\n            });\n            else if (currentOwner.memoizedState !== prevComponentValue.state) {\n                // On the second render, the memoizedState gets reset by React.\n                // Reset the counter, and remove from the weak map so we don't\n                // do this for subsequent useId calls.\n                ctx.current = prevComponentValue.id;\n                $b5e257d569688ac6$var$componentIds.delete(currentOwner);\n            }\n        }\n        // eslint-disable-next-line rulesdir/pure-render\n        ref.current = ++ctx.current;\n    }\n    // eslint-disable-next-line rulesdir/pure-render\n    return ref.current;\n}\nfunction $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    // If we are rendering in a non-DOM environment, and there's no SSRProvider,\n    // provide a warning to hint to the developer to add one.\n    if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM) console.warn(\"When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.\");\n    let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);\n    let prefix = ctx === $b5e257d569688ac6$var$defaultContext && \"development\" === \"test\" ? 0 : `react-aria${ctx.prefix}`;\n    return defaultId || `${prefix}-${counter}`;\n}\nfunction $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {\n    // @ts-ignore\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__).useId();\n    let [didSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());\n    let prefix = didSSR || \"development\" === \"test\" ? \"react-aria\" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;\n    return defaultId || `${prefix}-${id}`;\n}\nconst $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;\nfunction $b5e257d569688ac6$var$getSnapshot() {\n    return false;\n}\nfunction $b5e257d569688ac6$var$getServerSnapshot() {\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction $b5e257d569688ac6$var$subscribe(onStoreChange) {\n    // noop\n    return ()=>{};\n}\nfunction $b5e257d569688ac6$export$535bd6ca7f90a273() {\n    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"] === \"function\") return (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$IsSSRContext);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3Nzci9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnTTtBQUVoTTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHLDBGQUEwRjtBQUM5RiwyREFBMkQ7QUFDM0Qsd0RBQXdEO0FBRXhELGlGQUFpRjtBQUNqRixrRkFBa0Y7QUFDbEYsK0VBQStFO0FBQy9FLCtFQUErRTtBQUMvRSwyREFBMkQ7QUFDM0QsTUFBTVcsdUNBQXVDO0lBQ3pDQyxRQUFRQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSztJQUMxQ0MsU0FBUztBQUNiO0FBQ0EsTUFBTUMsbUNBQWlELFdBQUgsR0FBSSxJQUFHbEIsa0NBQVcsRUFBR21CLGFBQWEsQ0FBQ1I7QUFDdkYsTUFBTVMscUNBQW1ELFdBQUgsR0FBSSxJQUFHcEIsa0NBQVcsRUFBR21CLGFBQWEsQ0FBQztBQUN6RixtQ0FBbUM7QUFDbkMsU0FBU0Usd0NBQXdDQyxLQUFLO0lBQ2xELElBQUlDLE1BQU0sQ0FBQyxHQUFHckIsNkNBQWdCLEVBQUdnQjtJQUNqQyxJQUFJTSxVQUFVQyxpQ0FBaUNGLFFBQVFaO0lBQ3ZELElBQUksQ0FBQ2UsT0FBT0MsU0FBUyxHQUFHLENBQUMsR0FBR3ZCLDJDQUFjLEVBQUc7SUFDN0MsSUFBSXdCLFFBQVEsQ0FBQyxHQUFHdEIsMENBQWEsRUFBRyxJQUFLO1lBQzdCLGlGQUFpRjtZQUNqRixvQ0FBb0M7WUFDcENNLFFBQVFXLFFBQVFaLHVDQUF1QyxLQUFLLENBQUMsRUFBRVksSUFBSVgsTUFBTSxDQUFDLENBQUMsRUFBRVksUUFBUSxDQUFDO1lBQ3RGUCxTQUFTO1FBQ2IsSUFBSTtRQUNKTTtRQUNBQztLQUNIO0lBQ0QscUVBQXFFO0lBQ3JFLHlFQUF5RTtJQUN6RSxJQUFJLE9BQU9LLGFBQWEsYUFHeEIsc0RBRnNEO0lBQ3RELHNEQUFzRDtJQUNyRCxJQUFHckIsa0RBQXFCLEVBQUc7UUFDeEJtQixTQUFTO0lBQ2IsR0FBRyxFQUFFO0lBQ0wsT0FBcUIsV0FBSCxHQUFJLElBQUczQixrQ0FBVyxFQUFHOEIsYUFBYSxDQUFDWixpQ0FBaUNhLFFBQVEsRUFBRTtRQUM1RkgsT0FBT0E7SUFDWCxHQUFpQixXQUFILEdBQUksSUFBRzVCLGtDQUFXLEVBQUc4QixhQUFhLENBQUNWLG1DQUFtQ1csUUFBUSxFQUFFO1FBQzFGSCxPQUFPRjtJQUNYLEdBQUdKLE1BQU1VLFFBQVE7QUFDckI7QUFDQSxJQUFJQywrQ0FBK0M7QUFDbkQsU0FBU0MsMENBQTBDWixLQUFLO0lBQ3BELElBQUksT0FBTyxDQUFDLEdBQUd0QixrQ0FBVyxDQUFFLENBQUMsUUFBUSxLQUFLLFlBQVk7UUFDbEQsSUFBSW1DLEtBQStCLElBQUksQ0FBQ0YsOENBQThDO1lBQ2xGRyxRQUFRQyxJQUFJLENBQUM7WUFDYkosK0NBQStDO1FBQ25EO1FBQ0EsT0FBcUIsV0FBSCxHQUFJLElBQUdqQyxrQ0FBVyxFQUFHOEIsYUFBYSxDQUFDLENBQUMsR0FBRzlCLGtDQUFXLEVBQUdzQyxRQUFRLEVBQUUsTUFBTWhCLE1BQU1VLFFBQVE7SUFDekc7SUFDQSxPQUFxQixXQUFILEdBQUksSUFBR2hDLGtDQUFXLEVBQUc4QixhQUFhLENBQUNULHlDQUF5Q0M7QUFDbEc7QUFDQSxJQUFJaUIsa0NBQWtDQyxRQUFRLE1BQWdELElBQUlDLENBQTZCO0FBQy9ILElBQUlDLHFDQUFxQyxJQUFJQztBQUM3QyxTQUFTbEIsaUNBQWlDbUIsYUFBYSxLQUFLO0lBQ3hELElBQUlDLE1BQU0sQ0FBQyxHQUFHM0MsNkNBQWdCLEVBQUdnQjtJQUNqQyxJQUFJNEIsTUFBTSxDQUFDLEdBQUdwQyx5Q0FBWSxFQUFHO0lBQzdCLGdEQUFnRDtJQUNoRCxJQUFJb0MsSUFBSTdCLE9BQU8sS0FBSyxRQUFRLENBQUMyQixZQUFZO1FBQ3JDLElBQUlHLDZFQUE2RUM7UUFDakYsMEdBQTBHO1FBQzFHLHdHQUF3RztRQUN4Ryx1R0FBdUc7UUFDdkcsK0dBQStHO1FBQy9HLGdIQUFnSDtRQUNoSCx1SEFBdUg7UUFDdkgsMkdBQTJHO1FBQzNHLHlHQUF5RztRQUN6RyxnRkFBZ0Y7UUFDaEYsYUFBYTtRQUNiLElBQUlDLGVBQWUsQ0FBQ0QsNERBQTRELENBQUMsR0FBR2hELGtDQUFXLEVBQUdrRCxrREFBa0QsTUFBTSxRQUFRRiw4REFBOEQsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFDRCw4RUFBOEVDLDBEQUEwREcsaUJBQWlCLE1BQU0sUUFBUUosZ0ZBQWdGLEtBQUssSUFBSSxLQUFLLElBQUlBLDRFQUE0RTlCLE9BQU87UUFDL2tCLElBQUlnQyxjQUFjO1lBQ2QsSUFBSUcscUJBQXFCVixtQ0FBbUNXLEdBQUcsQ0FBQ0o7WUFDaEUsSUFBSUcsc0JBQXNCLE1BQzFCVixtQ0FBbUNZLEdBQUcsQ0FBQ0wsY0FBYztnQkFDakRNLElBQUlWLElBQUk1QixPQUFPO2dCQUNmdUMsT0FBT1AsYUFBYVEsYUFBYTtZQUNyQztpQkFDSyxJQUFJUixhQUFhUSxhQUFhLEtBQUtMLG1CQUFtQkksS0FBSyxFQUFFO2dCQUM5RCwrREFBK0Q7Z0JBQy9ELDhEQUE4RDtnQkFDOUQsc0NBQXNDO2dCQUN0Q1gsSUFBSTVCLE9BQU8sR0FBR21DLG1CQUFtQkcsRUFBRTtnQkFDbkNiLG1DQUFtQ2dCLE1BQU0sQ0FBQ1Q7WUFDOUM7UUFDSjtRQUNBLGdEQUFnRDtRQUNoREgsSUFBSTdCLE9BQU8sR0FBRyxFQUFFNEIsSUFBSTVCLE9BQU87SUFDL0I7SUFDQSxnREFBZ0Q7SUFDaEQsT0FBTzZCLElBQUk3QixPQUFPO0FBQ3RCO0FBQ0EsU0FBUzBDLHlDQUF5Q0MsU0FBUztJQUN2RCxJQUFJZixNQUFNLENBQUMsR0FBRzNDLDZDQUFnQixFQUFHZ0I7SUFDakMsNEVBQTRFO0lBQzVFLHlEQUF5RDtJQUN6RCxJQUFJMkIsUUFBUWxDLHdDQUF3QyxDQUFDNEIsaUNBQWlDSCxRQUFRQyxJQUFJLENBQUM7SUFDbkcsSUFBSWIsVUFBVUMsaUNBQWlDLENBQUMsQ0FBQ21DO0lBQ2pELElBQUloRCxTQUFTaUMsUUFBUWxDLHdDQUF3Q3dCLGtCQUF5QixTQUFTLENBQVksR0FBRyxDQUFDLFVBQVUsRUFBRVUsSUFBSWpDLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZJLE9BQU9nRCxhQUFhLENBQUMsRUFBRWhELE9BQU8sQ0FBQyxFQUFFWSxRQUFRLENBQUM7QUFDOUM7QUFDQSxTQUFTcUMseUNBQXlDRCxTQUFTO0lBQ3ZELGFBQWE7SUFDYixJQUFJTCxLQUFLLENBQUMsR0FBR3ZELGtDQUFXLEVBQUc4RCxLQUFLO0lBQ2hDLElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUMsR0FBRzNELDJDQUFjLEVBQUc0RDtJQUNwQyxJQUFJcEQsU0FBU21ELFVBQVU1QixrQkFBeUIsU0FBUyxlQUFlLENBQUMsVUFBVSxFQUFFeEIscUNBQXFDQyxNQUFNLENBQUMsQ0FBQztJQUNsSSxPQUFPZ0QsYUFBYSxDQUFDLEVBQUVoRCxPQUFPLENBQUMsRUFBRTJDLEdBQUcsQ0FBQztBQUN6QztBQUNBLE1BQU1VLDRDQUE0QyxPQUFPLENBQUMsR0FBR2pFLGtDQUFXLENBQUUsQ0FBQyxRQUFRLEtBQUssYUFBYTZELDJDQUEyQ0Y7QUFDaEosU0FBU087SUFDTCxPQUFPO0FBQ1g7QUFDQSxTQUFTQztJQUNMLE9BQU87QUFDWDtBQUNBLDZEQUE2RDtBQUM3RCxTQUFTQyxnQ0FBZ0NDLGFBQWE7SUFDbEQsT0FBTztJQUNQLE9BQU8sS0FBSztBQUNoQjtBQUNBLFNBQVNMO0lBQ0wsaUdBQWlHO0lBQ2pHLElBQUksT0FBTyxDQUFDLEdBQUdoRSxrQ0FBVyxDQUFFLENBQUMsdUJBQXVCLEtBQUssWUFBWSxPQUFPLENBQUMsR0FBR0Esa0NBQVcsQ0FBRSxDQUFDLHVCQUF1QixDQUFDb0UsaUNBQWlDRixtQ0FBbUNDO0lBQzFMLHNEQUFzRDtJQUN0RCxPQUFPLENBQUMsR0FBR2pFLDZDQUFnQixFQUFHa0I7QUFDbEM7QUFLb0wsQ0FDcEwsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2Fyem9uZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS91dGlscy9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvc3NyL2Rpc3QvaW1wb3J0Lm1qcz9kYWMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkNzNTSngkcmVhY3QsIHt1c2VDb250ZXh0IGFzICQ3M1NKeCR1c2VDb250ZXh0LCB1c2VTdGF0ZSBhcyAkNzNTSngkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDczU0p4JHVzZU1lbW8sIHVzZUxheW91dEVmZmVjdCBhcyAkNzNTSngkdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgYXMgJDczU0p4JHVzZVJlZn0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gV2UgbXVzdCBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCBAcmVhY3QtYXJpYS91dGlscywgYW5kIHRoaXMgdXNlTGF5b3V0RWZmZWN0IGlzXG4vLyBndWFyZGVkIGJ5IGEgY2hlY2sgdGhhdCBpdCBvbmx5IHJ1bnMgb24gdGhlIGNsaWVudCBzaWRlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3VzZUxheW91dEVmZmVjdFJ1bGVcblxuLy8gRGVmYXVsdCBjb250ZXh0IHZhbHVlIHRvIHVzZSBpbiBjYXNlIHRoZXJlIGlzIG5vIFNTUlByb3ZpZGVyLiBUaGlzIGlzIGZpbmUgZm9yXG4vLyBjbGllbnQtb25seSBhcHBzLiBJbiBvcmRlciB0byBzdXBwb3J0IG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBBcmlhIHBvdGVudGlhbGx5XG4vLyBiZWluZyBvbiB0aGUgcGFnZSBhdCBvbmNlLCB0aGUgcHJlZml4IGlzIHNldCB0byBhIHJhbmRvbSBudW1iZXIuIFNTUlByb3ZpZGVyXG4vLyB3aWxsIHJlc2V0IHRoaXMgdG8gemVybyBmb3IgY29uc2lzdGVuY3kgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCwgc28gaW4gdGhlXG4vLyBTU1IgY2FzZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgQXJpYSBpcyBub3Qgc3VwcG9ydGVkLlxuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0ID0ge1xuICAgIHByZWZpeDogU3RyaW5nKE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKSksXG4gICAgY3VycmVudDogMFxufTtcbmNvbnN0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRTU1JDb250ZXh0ID0gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVDb250ZXh0KCRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCk7XG5jb25zdCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0ID0gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8vIFRoaXMgaXMgb25seSB1c2VkIGluIFJlYWN0IDwgMTguXG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkTGVnYWN5U1NSUHJvdmlkZXIocHJvcHMpIHtcbiAgICBsZXQgY3VyID0gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCk7XG4gICAgbGV0IGNvdW50ZXIgPSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlcihjdXIgPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCk7XG4gICAgbGV0IFtpc1NTUiwgc2V0SXNTU1JdID0gKDAsICQ3M1NKeCR1c2VTdGF0ZSkodHJ1ZSk7XG4gICAgbGV0IHZhbHVlID0gKDAsICQ3M1NKeCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IFNTUlByb3ZpZGVyLCBzdGFydCB3aXRoIGFuIGVtcHR5IHN0cmluZyBwcmVmaXgsIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gYXBwZW5kIGFuZCBpbmNyZW1lbnQgdGhlIGNvdW50ZXIuXG4gICAgICAgICAgICBwcmVmaXg6IGN1ciA9PT0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0ID8gXCJcIiA6IGAke2N1ci5wcmVmaXh9LSR7Y291bnRlcn1gLFxuICAgICAgICAgICAgY3VycmVudDogMFxuICAgICAgICB9KSwgW1xuICAgICAgICBjdXIsXG4gICAgICAgIGNvdW50ZXJcbiAgICBdKTtcbiAgICAvLyBJZiBvbiB0aGUgY2xpZW50LCBhbmQgdGhlIGNvbXBvbmVudCB3YXMgaW5pdGlhbGx5IHNlcnZlciByZW5kZXJlZCxcbiAgICAvLyB0aGVuIHNjaGVkdWxlIGEgbGF5b3V0IGVmZmVjdCB0byB1cGRhdGUgdGhlIGNvbXBvbmVudCBhZnRlciBoeWRyYXRpb24uXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikgLy8gVGhpcyBpZiBzdGF0ZW1lbnQgdGVjaG5pY2FsbHkgYnJlYWtzIHRoZSBydWxlcyBvZiBob29rcywgYnV0IGlzIHNhZmVcbiAgICAvLyBiZWNhdXNlIHRoZSBjb25kaXRpb24gbmV2ZXIgY2hhbmdlcyBhZnRlciBtb3VudGluZy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAoMCwgJDczU0p4JHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgc2V0SXNTU1IoZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVFbGVtZW50KCRiNWUyNTdkNTY5Njg4YWM2JHZhciRTU1JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBpc1NTUlxuICAgIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5sZXQgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIgPSBmYWxzZTtcbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ5ZjhhYzk2YWY0YjFiMmFlKHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZUlkXCJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJiAhJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkluIFJlYWN0IDE4LCBTU1JQcm92aWRlciBpcyBub3QgbmVjZXNzYXJ5IGFuZCBpcyBhIG5vb3AuIFlvdSBjYW4gcmVtb3ZlIGl0IGZyb20geW91ciBhcHAuXCIpO1xuICAgICAgICAgICAgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkNzNTSngkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoKDAsICQ3M1NKeCRyZWFjdCkuRnJhZ21lbnQsIG51bGwsIHByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkTGVnYWN5U1NSUHJvdmlkZXIsIHByb3BzKTtcbn1cbmxldCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY2FuVXNlRE9NID0gQm9vbGVhbih0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5sZXQgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNvbXBvbmVudElkcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlcihpc0Rpc2FibGVkID0gZmFsc2UpIHtcbiAgICBsZXQgY3R4ID0gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCk7XG4gICAgbGV0IHJlZiA9ICgwLCAkNzNTSngkdXNlUmVmKShudWxsKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcnVsZXNkaXIvcHVyZS1yZW5kZXJcbiAgICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgdmFyIF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lciwgX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgICAgICAvLyBJbiBzdHJpY3QgbW9kZSwgUmVhY3QgcmVuZGVycyBjb21wb25lbnRzIHR3aWNlLCBhbmQgdGhlIHJlZiB3aWxsIGJlIHJlc2V0IHRvIG51bGwgb24gdGhlIHNlY29uZCByZW5kZXIuXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgb3VyIGlkIGNvdW50ZXIgd2lsbCBiZSBpbmNyZW1lbnRlZCB0d2ljZSBpbnN0ZWFkIG9mIG9uY2UuIFRoaXMgaXMgYSBwcm9ibGVtIGJlY2F1c2Ugb24gdGhlXG4gICAgICAgIC8vIHNlcnZlciwgY29tcG9uZW50cyBhcmUgb25seSByZW5kZXJlZCBvbmNlIGFuZCBzbyBpZHMgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgd29uJ3QgbWF0Y2ggdGhlIGNsaWVudC5cbiAgICAgICAgLy8gSW4gUmVhY3QgMTgsIHVzZUlkIHdhcyBpbnRyb2R1Y2VkIHRvIHNvbHZlIHRoaXMsIGJ1dCBpdCBpcyBub3QgYXZhaWxhYmxlIGluIG9sZGVyIHZlcnNpb25zLiBTbyB0byBzb2x2ZSB0aGlzXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gdXNlIHNvbWUgUmVhY3QgaW50ZXJuYWxzIHRvIGFjY2VzcyB0aGUgdW5kZXJseWluZyBGaWJlciBpbnN0YW5jZSwgd2hpY2ggaXMgc3RhYmxlIGJldHdlZW4gcmVuZGVycy5cbiAgICAgICAgLy8gVGhpcyBpcyBleHBvc2VkIGFzIFJlYWN0Q3VycmVudE93bmVyIGluIGRldmVsb3BtZW50LCB3aGljaCBpcyBhbGwgd2UgbmVlZCBzaW5jZSBTdHJpY3RNb2RlIG9ubHkgcnVucyBpbiBkZXZlbG9wbWVudC5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHRoYXQgd2Ugb25seSBpbmNyZW1lbnQgdGhlIGdsb2JhbCBjb3VudGVyIG9uY2UsIHdlIHN0b3JlIHRoZSBzdGFydGluZyBpZCBmb3IgdGhpcyBjb21wb25lbnQgaW5cbiAgICAgICAgLy8gYSB3ZWFrIG1hcCBhc3NvY2lhdGVkIHdpdGggdGhlIEZpYmVyLiBPbiB0aGUgc2Vjb25kIHJlbmRlciwgd2UgcmVzZXQgdGhlIGdsb2JhbCBjb3VudGVyIHRvIHRoaXMgdmFsdWUuXG4gICAgICAgIC8vIFNpbmNlIFJlYWN0IHJ1bnMgdGhlIHNlY29uZCByZW5kZXIgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGZpcnN0LCB0aGlzIGlzIHNhZmUuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IGN1cnJlbnRPd25lciA9IChfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSAoMCwgJDczU0p4JHJlYWN0KS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCkgPT09IG51bGwgfHwgX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEX1JlYWN0Q3VycmVudE93bmVyID0gX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyKSA9PT0gbnVsbCB8fCBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgICBpZiAoY3VycmVudE93bmVyKSB7XG4gICAgICAgICAgICBsZXQgcHJldkNvbXBvbmVudFZhbHVlID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNvbXBvbmVudElkcy5nZXQoY3VycmVudE93bmVyKTtcbiAgICAgICAgICAgIGlmIChwcmV2Q29tcG9uZW50VmFsdWUgPT0gbnVsbCkgLy8gT24gdGhlIGZpcnN0IHJlbmRlciwgYW5kIGZpcnN0IGNhbGwgdG8gdXNlSWQsIHN0b3JlIHRoZSBpZCBhbmQgc3RhdGUgaW4gb3VyIHdlYWsgbWFwLlxuICAgICAgICAgICAgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNvbXBvbmVudElkcy5zZXQoY3VycmVudE93bmVyLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGN0eC5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHN0YXRlOiBjdXJyZW50T3duZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50T3duZXIubWVtb2l6ZWRTdGF0ZSAhPT0gcHJldkNvbXBvbmVudFZhbHVlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gdGhlIHNlY29uZCByZW5kZXIsIHRoZSBtZW1vaXplZFN0YXRlIGdldHMgcmVzZXQgYnkgUmVhY3QuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvdW50ZXIsIGFuZCByZW1vdmUgZnJvbSB0aGUgd2VhayBtYXAgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBkbyB0aGlzIGZvciBzdWJzZXF1ZW50IHVzZUlkIGNhbGxzLlxuICAgICAgICAgICAgICAgIGN0eC5jdXJyZW50ID0gcHJldkNvbXBvbmVudFZhbHVlLmlkO1xuICAgICAgICAgICAgICAgICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuZGVsZXRlKGN1cnJlbnRPd25lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3B1cmUtcmVuZGVyXG4gICAgICAgIHJlZi5jdXJyZW50ID0gKytjdHguY3VycmVudDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3B1cmUtcmVuZGVyXG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUxlZ2FjeVNTUlNhZmVJZChkZWZhdWx0SWQpIHtcbiAgICBsZXQgY3R4ID0gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCk7XG4gICAgLy8gSWYgd2UgYXJlIHJlbmRlcmluZyBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIGFuZCB0aGVyZSdzIG5vIFNTUlByb3ZpZGVyLFxuICAgIC8vIHByb3ZpZGUgYSB3YXJuaW5nIHRvIGhpbnQgdG8gdGhlIGRldmVsb3BlciB0byBhZGQgb25lLlxuICAgIGlmIChjdHggPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCAmJiAhJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNhblVzZURPTSkgY29uc29sZS53YXJuKFwiV2hlbiBzZXJ2ZXIgcmVuZGVyaW5nLCB5b3UgbXVzdCB3cmFwIHlvdXIgYXBwbGljYXRpb24gaW4gYW4gPFNTUlByb3ZpZGVyPiB0byBlbnN1cmUgY29uc2lzdGVudCBpZHMgYXJlIGdlbmVyYXRlZCBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHNlcnZlci5cIik7XG4gICAgbGV0IGNvdW50ZXIgPSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlcighIWRlZmF1bHRJZCk7XG4gICAgbGV0IHByZWZpeCA9IGN0eCA9PT0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IFwicmVhY3QtYXJpYVwiIDogYHJlYWN0LWFyaWEke2N0eC5wcmVmaXh9YDtcbiAgICByZXR1cm4gZGVmYXVsdElkIHx8IGAke3ByZWZpeH0tJHtjb3VudGVyfWA7XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTW9kZXJuU1NSU2FmZUlkKGRlZmF1bHRJZCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZXQgaWQgPSAoMCwgJDczU0p4JHJlYWN0KS51c2VJZCgpO1xuICAgIGxldCBbZGlkU1NSXSA9ICgwLCAkNzNTSngkdXNlU3RhdGUpKCRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczKCkpO1xuICAgIGxldCBwcmVmaXggPSBkaWRTU1IgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gXCJyZWFjdC1hcmlhXCIgOiBgcmVhY3QtYXJpYSR7JGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0LnByZWZpeH1gO1xuICAgIHJldHVybiBkZWZhdWx0SWQgfHwgYCR7cHJlZml4fS0ke2lkfWA7XG59XG5jb25zdCAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNjE5NTAwOTU5ZmM0OGIyNiA9IHR5cGVvZiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZUlkXCJdID09PSBcImZ1bmN0aW9uXCIgPyAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTW9kZXJuU1NSU2FmZUlkIDogJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUxlZ2FjeVNTUlNhZmVJZDtcbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTbmFwc2hvdCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpIHtcbiAgICAvLyBub29wXG4gICAgcmV0dXJuICgpPT57fTtcbn1cbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczKCkge1xuICAgIC8vIEluIFJlYWN0IDE4LCB3ZSBjYW4gdXNlIHVzZVN5bmNFeHRlcm5hbFN0b3JlIHRvIGRldGVjdCBpZiB3ZSdyZSBzZXJ2ZXIgcmVuZGVyaW5nIG9yIGh5ZHJhdGluZy5cbiAgICBpZiAodHlwZW9mICgwLCAkNzNTSngkcmVhY3QpW1widXNlU3luY0V4dGVybmFsU3RvcmVcIl0gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuICgwLCAkNzNTSngkcmVhY3QpW1widXNlU3luY0V4dGVybmFsU3RvcmVcIl0oJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHN1YnNjcmliZSwgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNuYXBzaG90LCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHJldHVybiAoMCwgJDczU0p4JHVzZUNvbnRleHQpKCRiNWUyNTdkNTY5Njg4YWM2JHZhciRJc1NTUkNvbnRleHQpO1xufVxuXG5cblxuXG5leHBvcnQgeyRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ5ZjhhYzk2YWY0YjFiMmFlIGFzIFNTUlByb3ZpZGVyLCAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNjE5NTAwOTU5ZmM0OGIyNiBhcyB1c2VTU1JTYWZlSWQsICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczIGFzIHVzZUlzU1NSfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyIkNzNTSngkcmVhY3QiLCJ1c2VDb250ZXh0IiwiJDczU0p4JHVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsIiQ3M1NKeCR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkNzNTSngkdXNlTWVtbyIsInVzZUxheW91dEVmZmVjdCIsIiQ3M1NKeCR1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCIkNzNTSngkdXNlUmVmIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGRlZmF1bHRDb250ZXh0IiwicHJlZml4IiwiU3RyaW5nIiwiTWF0aCIsInJvdW5kIiwicmFuZG9tIiwiY3VycmVudCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRTU1JDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRJc1NTUkNvbnRleHQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkTGVnYWN5U1NSUHJvdmlkZXIiLCJwcm9wcyIsImN1ciIsImNvdW50ZXIiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlQ291bnRlciIsImlzU1NSIiwic2V0SXNTU1IiLCJ2YWx1ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwiY2hpbGRyZW4iLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkd2FybmVkQWJvdXRTU1JQcm92aWRlciIsIiRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ5ZjhhYzk2YWY0YjFiMmFlIiwicHJvY2VzcyIsImNvbnNvbGUiLCJ3YXJuIiwiRnJhZ21lbnQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY2FuVXNlRE9NIiwiQm9vbGVhbiIsIndpbmRvdyIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMiLCJXZWFrTWFwIiwiaXNEaXNhYmxlZCIsImN0eCIsInJlZiIsIl9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lciIsIl9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImN1cnJlbnRPd25lciIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiUmVhY3RDdXJyZW50T3duZXIiLCJwcmV2Q29tcG9uZW50VmFsdWUiLCJnZXQiLCJzZXQiLCJpZCIsInN0YXRlIiwibWVtb2l6ZWRTdGF0ZSIsImRlbGV0ZSIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VMZWdhY3lTU1JTYWZlSWQiLCJkZWZhdWx0SWQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTW9kZXJuU1NSU2FmZUlkIiwidXNlSWQiLCJkaWRTU1IiLCIkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MyIsIiRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ2MTk1MDA5NTlmYzQ4YjI2IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNuYXBzaG90IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNlcnZlclNuYXBzaG90IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHN1YnNjcmliZSIsIm9uU3RvcmVDaGFuZ2UiLCJTU1JQcm92aWRlciIsInVzZVNTUlNhZmVJZCIsInVzZUlzU1NSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/utils/node_modules/@react-aria/ssr/dist/import.mjs\n");

/***/ })

};
;